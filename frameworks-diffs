diff --git a/./frameworks/av/camera/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/camera/Android.mk
index 60a5bf2..7286f92 100644
--- a/./frameworks/av/camera/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/camera/Android.mk
@@ -21,19 +21,3 @@ LOCAL_SHARED_LIBRARIES := \
 LOCAL_MODULE:= libcamera_client
 
 include $(BUILD_SHARED_LIBRARY)
-
-
-
-
-ifdef OMAP_ENHANCEMENT_CPCAM
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES += \
-    ShotParameters.cpp
-
-LOCAL_MODULE:= libcpcamcamera_client
-
-include $(BUILD_STATIC_LIBRARY)
-
-endif
diff --git a/./frameworks/av/camera/Camera.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/camera/Camera.cpp
index b66349b..d43cb0b 100644
--- a/./frameworks/av/camera/Camera.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/camera/Camera.cpp
@@ -296,23 +296,9 @@ status_t Camera::takePicture(int msgType)
     ALOGV("takePicture: 0x%x", msgType);
     sp <ICamera> c = mCamera;
     if (c == 0) return NO_INIT;
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    return c->takePicture(msgType, String8());
-#else
     return c->takePicture(msgType);
-#endif
 }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-status_t Camera::takePictureWithParameters(int msgType, const String8& params)
-{
-    ALOGV("takePicture: 0x%x", msgType);
-    sp <ICamera> c = mCamera;
-    if (c == 0) return NO_INIT;
-    return c->takePicture(msgType, params);
-}
-#endif
-
 // set preview/capture parameters - key/value pairs
 status_t Camera::setParameters(const String8& params)
 {
@@ -417,29 +403,6 @@ void Camera::dataCallbackTimestamp(nsecs_t timestamp, int32_t msgType, const sp<
     }
 }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-status_t Camera::reprocess(int msgType, const String8& params)
-{
-    ALOGV("reprocess: 0x%x", msgType);
-    sp <ICamera> c = mCamera;
-    if (c == 0) return NO_INIT;
-    return c->reprocess(msgType, params);
-}
-
-// pass the buffered ISurfaceTexture to the camera service
-status_t Camera::setBufferSource(const sp<ISurfaceTexture>& tapin,
-                                 const sp<ISurfaceTexture>& tapout)
-{
-    ALOGV("setBufferSource(%p,%p)", tapin.get(), tapout.get());
-    sp <ICamera> c = mCamera;
-    if (c == 0) return NO_INIT;
-    if (tapin == 0 && tapout == 0) {
-        ALOGD("app passed NULL surface");
-    }
-    return c->setBufferSource(tapin, tapout);
-}
-#endif
-
 void Camera::binderDied(const wp<IBinder>& who) {
     ALOGW("ICamera died");
     notifyCallback(CAMERA_MSG_ERROR, CAMERA_ERROR_SERVER_DIED, 0);
diff --git a/./frameworks/av/camera/ICamera.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/camera/ICamera.cpp
index b91d994..8d8408c 100644
--- a/./frameworks/av/camera/ICamera.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/camera/ICamera.cpp
@@ -49,10 +49,6 @@ enum {
     RECORDING_ENABLED,
     RELEASE_RECORDING_FRAME,
     STORE_META_DATA_IN_BUFFERS,
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    SET_BUFFER_SOURCE,
-    REPROCESS,
-#endif
 };
 
 class BpCamera: public BpInterface<ICamera>
@@ -206,19 +202,12 @@ public:
     }
 
     // take a picture - returns an IMemory (ref-counted mmap)
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    status_t takePicture(int msgType, const String8& params)
-#else
     status_t takePicture(int msgType)
-#endif
     {
         ALOGV("takePicture: 0x%x", msgType);
         Parcel data, reply;
         data.writeInterfaceToken(ICamera::getInterfaceDescriptor());
         data.writeInt32(msgType);
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        data.writeString8(params);
-#endif
         remote()->transact(TAKE_PICTURE, data, &reply);
         status_t ret = reply.readInt32();
         return ret;
@@ -244,7 +233,6 @@ public:
         remote()->transact(GET_PARAMETERS, data, &reply);
         return reply.readString8();
     }
-
     virtual status_t sendCommand(int32_t cmd, int32_t arg1, int32_t arg2)
     {
         ALOGV("sendCommand");
@@ -278,35 +266,6 @@ public:
         remote()->transact(UNLOCK, data, &reply);
         return reply.readInt32();
     }
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    // pass the buffered SurfaceTexture to the camera service
-    // TODO(XX): Find a good name for this tap-in/tap-out buffer source
-    status_t setBufferSource(const sp<ISurfaceTexture>& tapin,
-                             const sp<ISurfaceTexture>& tapout)
-    {
-        ALOGV("setBufferSource");
-        Parcel data, reply;
-        data.writeInterfaceToken(ICamera::getInterfaceDescriptor());
-        data.writeStrongBinder(tapin->asBinder());
-        data.writeStrongBinder(tapout->asBinder());
-        remote()->transact(SET_BUFFER_SOURCE, data, &reply);
-        return reply.readInt32();
-    }
-
-    // take a picture - returns an IMemory (ref-counted mmap)
-    status_t reprocess(int msgType, const String8& params)
-    {
-        ALOGV("reprocess: 0x%x", msgType);
-        Parcel data, reply;
-        data.writeInterfaceToken(ICamera::getInterfaceDescriptor());
-        data.writeInt32(msgType);
-        data.writeString8(params);
-        remote()->transact(REPROCESS, data, &reply);
-        status_t ret = reply.readInt32();
-        return ret;
-    }
-#endif
 };
 
 IMPLEMENT_META_INTERFACE(Camera, "android.hardware.ICamera");
@@ -410,12 +369,7 @@ status_t BnCamera::onTransact(
             ALOGV("TAKE_PICTURE");
             CHECK_INTERFACE(ICamera, data, reply);
             int msgType = data.readInt32();
-#ifdef OMAP_ENHANCEMENT_CPCAM
-            String8 params(data.readString8());
-            reply->writeInt32(takePicture(msgType, params));
-#else
             reply->writeInt32(takePicture(msgType));
-#endif
             return NO_ERROR;
         } break;
         case SET_PARAMETERS: {
@@ -440,24 +394,6 @@ status_t BnCamera::onTransact(
             reply->writeInt32(sendCommand(command, arg1, arg2));
             return NO_ERROR;
          } break;
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        case SET_BUFFER_SOURCE: {
-            ALOGV("SET_BUFFER_SOURCE");
-            CHECK_INTERFACE(ICamera, data, reply);
-            sp<ISurfaceTexture> tapin = interface_cast<ISurfaceTexture>(data.readStrongBinder());
-            sp<ISurfaceTexture> tapout = interface_cast<ISurfaceTexture>(data.readStrongBinder());
-            reply->writeInt32(setBufferSource(tapin, tapout));
-            return NO_ERROR;
-        } break;
-        case REPROCESS: {
-            ALOGV("REPROCESS");
-            CHECK_INTERFACE(ICamera, data, reply);
-            int msgType = data.readInt32();
-            String8 params(data.readString8());
-            reply->writeInt32(reprocess(msgType, params));
-            return NO_ERROR;
-        } break;
-#endif
         case CONNECT: {
             CHECK_INTERFACE(ICamera, data, reply);
             sp<ICameraClient> cameraClient = interface_cast<ICameraClient>(data.readStrongBinder());
diff --git a/./frameworks/av/camera/ICameraClient.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/camera/ICameraClient.cpp
index 5a3be15..205c8ba 100644
--- a/./frameworks/av/camera/ICameraClient.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/camera/ICameraClient.cpp
@@ -60,10 +60,6 @@ public:
         data.writeInt32(msgType);
         data.writeStrongBinder(imageData->asBinder());
         if (metadata) {
-#ifdef OMAP_ENHANCEMENT_CPCAM
-            data.writeInt32(metadata->exposure_time);
-            data.writeInt32(metadata->analog_gain);
-#endif
             data.writeInt32(metadata->number_of_faces);
             data.write(metadata->faces, sizeof(camera_face_t) * metadata->number_of_faces);
         }
@@ -108,10 +104,6 @@ status_t BnCameraClient::onTransact(
             camera_frame_metadata_t *metadata = NULL;
             if (data.dataAvail() > 0) {
                 metadata = new camera_frame_metadata_t;
-#ifdef OMAP_ENHANCEMENT_CPCAM
-                metadata->exposure_time = data.readInt32();
-                metadata->analog_gain = data.readInt32();
-#endif
                 metadata->number_of_faces = data.readInt32();
                 metadata->faces = (camera_face_t *) data.readInplace(
                         sizeof(camera_face_t) * metadata->number_of_faces);
diff --git a/./frameworks/av/camera/ShotParameters.cpp b/./frameworks/av/camera/ShotParameters.cpp
deleted file mode 100644
index d1c9761..0000000
--- a/./frameworks/av/camera/ShotParameters.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-**
-** Copyright 2008, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#define LOG_TAG "ShotParams"
-#include <utils/Log.h>
-
-#include <string.h>
-#include <stdlib.h>
-#include <camera/ShotParameters.h>
-
-namespace android {
-// Parameter keys to communicate between camera application and driver.
-const char ShotParameters::KEY_BURST[] = "burst-capture";
-const char ShotParameters::KEY_EXP_GAIN_PAIRS[] = "exp-gain-pairs";
-const char ShotParameters::KEY_EXP_COMPENSATION[] = "exp-compensation";
-const char ShotParameters::KEY_FLUSH_CONFIG[] = "flush";
-const char ShotParameters::TRUE[] = "true";
-const char ShotParameters::FALSE[] = "false";
-
-void ShotParameters::setBurst(int num_shots)
-{
-    set(KEY_BURST, num_shots);
-}
-
-void ShotParameters::setExposureGainPairs(const char *pairs)
-{
-    set(KEY_EXP_GAIN_PAIRS, pairs);
-}
-
-void ShotParameters::setExposureCompensation(const char *comp)
-{
-    set(KEY_EXP_COMPENSATION, comp);
-}
-
-void ShotParameters::setFlushConfig(bool flush)
-{
-    set(KEY_FLUSH_CONFIG, flush ? TRUE : FALSE);
-}
-
-}; // namespace android
diff --git a/./frameworks/av/cmds/stagefright/stagefright.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/cmds/stagefright/stagefright.cpp
index ae18372..0362f39 100644
--- a/./frameworks/av/cmds/stagefright/stagefright.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/cmds/stagefright/stagefright.cpp
@@ -978,9 +978,6 @@ int main(int argc, char **argv) {
 
         Vector<sp<MediaSource> > mediaSources;
         sp<MediaSource> mediaSource;
-#ifdef OMAP_ENHANCEMENT
-        sp<MediaExtractor> extractor;
-#endif
 
         if (isJPEG) {
             mediaSource = new JPEGSource(dataSource);
@@ -999,9 +996,7 @@ int main(int argc, char **argv) {
                 mediaSources.push(mediaSource);
             }
         } else {
-#ifndef OMAP_ENHANCEMENT
             sp<MediaExtractor> extractor;
-#endif
 
             if (!strncasecmp("httplive://", filename, 11)) {
                 String8 uri("http://");
diff --git a/./frameworks/av/include/camera/Camera.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/camera/Camera.h
index 4cfee86..234e165 100644
--- a/./frameworks/av/include/camera/Camera.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/camera/Camera.h
@@ -118,9 +118,6 @@ public:
 
             // take a picture - picture returned from callback
             status_t    takePicture(int msgType);
-#ifdef OMAP_ENHANCEMENT_CPCAM
-            status_t    takePictureWithParameters(int msgType, const String8& params);
-#endif
 
             // set preview/capture parameters - key/value pairs
             status_t    setParameters(const String8& params);
@@ -134,13 +131,6 @@ public:
             // tell camera hal to store meta data or real YUV in video buffers.
             status_t    storeMetaDataInBuffers(bool enabled);
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-            status_t    reprocess(int msgType, const String8& params);
-            // pass the buffered ISurfaceTexture to the camera service
-            status_t    setBufferSource(const sp<ISurfaceTexture>& tapin,
-                                        const sp<ISurfaceTexture>& tapout);
-#endif
-
             void        setListener(const sp<CameraListener>& listener);
             void        setRecordingProxyListener(const sp<ICameraRecordingProxyListener>& listener);
             void        setPreviewCallbackFlags(int preview_callback_flag);
diff --git a/./frameworks/av/include/camera/CameraMetadata.h b/./frameworks/av/include/camera/CameraMetadata.h
deleted file mode 100644
index 85ee2eb..0000000
--- a/./frameworks/av/include/camera/CameraMetadata.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef CAMERA_METADATA_H
-#define CAMERA_METADATA_H
-
-#include <utils/Timers.h>
-
-typedef struct camera_metadata_face {
-    int32_t top;
-    int32_t left;
-    int32_t bottom;
-    int32_t right;
-} camera_metadata_face_t;
-
-// Structure that handles the Camera Frame metadata
-typedef struct camera_metadata
-{
-    // Used to store the information about frame
-    // number in processing sequence (i.e preview)
-    uint32_t frame_number;
-
-    // Used to store the information about shot number
-    // in a burst sequence.
-    uint32_t shot_number;
-
-    // Used to store analog gain information for
-    // current frame. Metadata is represented as 100*EV.
-    uint32_t analog_gain;
-
-    // Used for storing analog gain information
-    // requested by application for current frame. Metadata is represented as 100*EV.
-    int32_t analog_gain_req;
-
-    // Used for storing the analog gain
-    // lower limit for current frame. Metadata is represented as 100*EV.
-    uint32_t analog_gain_min;
-
-    // Used for storing the analog gain
-    // upper limit for current frame. Metadata is represented as 100*EV.
-    uint32_t analog_gain_max;
-
-    // Used for storing the analog gain
-    // deviation after flicker reduction for current frame. Metadata is represented as 100*EV.
-    int32_t analog_gain_dev;
-
-    // Used for storing analog gain error for
-    // current frame. Represents the difference between requested value and actual value.
-    uint32_t analog_gain_error;
-
-    // Used for storing the exposure time for current frame.
-    // Metadata is represented in us.
-    uint32_t exposure_time;
-
-    // Used for storing the exposure time requested by
-    // application for current frame. Metadata is represented in us.
-    int32_t exposure_time_req;
-
-    // Used for storing the exposure time lower limit for
-    // current frame. Metadata is represented in us.
-    uint32_t exposure_time_min;
-
-    // Used for storing the exposure time upper limit for
-    // current frame. Metadata is represented in us.
-    uint32_t exposure_time_max;
-
-    // Used for storing the exposure time
-    // deviation after flicker reduction for current frame. Metadata is represented in us.
-    int32_t exposure_time_dev;
-
-    // Used for storing the time difference between
-    // requested exposure time and actual exposure time.
-    int32_t exposure_time_error;
-
-    // Used for storing the current total exposure
-    // compensation requested by application for current frame.  Metadata is represented as 100*EV.
-    int32_t exposure_compensation_req;
-
-    // Used for storing current total exposure
-    // deviation for current frame.  Metadata is represented as 100*EV.
-    int32_t exposure_dev;
-
-    // Represents the timestamp in terms of a reference clock.
-    nsecs_t timestamp;
-
-    // Represents the temperature of current scene in Kelvin
-    uint32_t awb_temp;
-
-    // Represent gains applied to each RGGB color channel.
-    uint32_t gain_r;
-    uint32_t gain_gr;
-    uint32_t gain_gb;
-    uint32_t gain_b;
-
-    // Represent offsets applied to each RGGB color channel.
-    uint32_t offset_r;
-    uint32_t offset_gr;
-    uint32_t offset_gb;
-    uint32_t offset_b;
-
-    // Offset to a lens shading correction table.  The table consists of an
-    // N by M array of elements.  Each element has 4 integer values
-    // ranging from 0 to 1000, corresponding to a multiplier for
-    // each of the Bayer color filter channels (R, Gr, Gb, B).
-    // Correction is performed on pixels in a Bayer image by interpolating
-    // the corresponding color filter channel in the array, and then
-    // multiplying by (value/1000).
-    uint32_t lsc_table_offset;
-
-    // Stores the size of the lens shading correction table
-    size_t lsc_table_size;
-
-    // Indicates whether LSC table is applied or not
-    uint32_t lsc_table_applied;
-
-    // The number of detected faces in the frame.
-    int32_t number_of_faces;
-
-    // Offset to an 'camera_metadata_face' array of the detected faces.
-    //  The length is number_of_faces.
-    uint32_t faces_offset;
-
-    void *handle;
-} camera_metadata_t;
-
-#endif //CAMERA_METADATA_H
-
diff --git a/./frameworks/av/include/camera/ICamera.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/camera/ICamera.h
index 199654f..3d18837 100644
--- a/./frameworks/av/include/camera/ICamera.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/camera/ICamera.h
@@ -91,11 +91,7 @@ public:
      * CAMERA_MSG_SHUTTER, CAMERA_MSG_RAW_IMAGE, CAMERA_MSG_COMPRESSED_IMAGE,
      * and CAMERA_MSG_POSTVIEW_FRAME. Any other message types will be ignored.
      */
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    virtual status_t        takePicture(int msgType, const String8& params) = 0;
-#else
     virtual status_t        takePicture(int msgType) = 0;
-#endif
 
     // set preview/capture parameters - key/value pairs
     virtual status_t        setParameters(const String8& params) = 0;
@@ -108,14 +104,6 @@ public:
 
     // tell the camera hal to store meta data or real YUV data in video buffers.
     virtual status_t        storeMetaDataInBuffers(bool enabled) = 0;
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    virtual status_t        reprocess(int msgType, const String8& params) = 0;
-
-    // pass the buffered ISurfaceTexture to the camera service
-    virtual status_t        setBufferSource(const sp<ISurfaceTexture>& tapin,
-                                            const sp<ISurfaceTexture>& tapout) = 0;
-#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/./frameworks/av/include/camera/ShotParameters.h b/./frameworks/av/include/camera/ShotParameters.h
deleted file mode 100644
index dac7694..0000000
--- a/./frameworks/av/include/camera/ShotParameters.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_HARDWARE_SHOT_PARAMETERS_H
-#define ANDROID_HARDWARE_SHOT_PARAMETERS_H
-
-#include <utils/KeyedVector.h>
-#include <utils/String8.h>
-#include <camera/CameraParameters.h>
-
-namespace android {
-
-class ShotParameters : public CameraParameters
-{
-public:
-    ShotParameters() : CameraParameters() {}
-    ShotParameters(const String8 &params) : CameraParameters(params) { }
-
-    void setBurst(int num_shots);
-    void setExposureGainPairs(const char *pairs);
-    void setExposureCompensation(const char *comp);
-    void setFlushConfig(bool flush);
-
-    // Parameter keys to communicate between camera application and driver.
-    // The access (read/write, read only, or write only) is viewed from the
-    // perspective of applications, not driver.
-
-    static const char KEY_BURST[];
-    static const char KEY_EXP_GAIN_PAIRS[];
-    static const char KEY_EXP_COMPENSATION[];
-    static const char KEY_FLUSH_CONFIG[];
-
-    // Values for boolean type parameters
-    static const char TRUE[];
-    static const char FALSE[];
-
-};
-
-}; // namespace android
-
-#endif
diff --git a/./frameworks/av/include/media/IAudioFlinger.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/IAudioFlinger.h
index 8a0453e..86e228b 100644
--- a/./frameworks/av/include/media/IAudioFlinger.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/IAudioFlinger.h
@@ -111,13 +111,6 @@ public:
                                     audio_io_handle_t output) const = 0;
     virtual     bool        streamMute(audio_stream_type_t stream) const = 0;
 
-#ifdef OMAP_ENHANCEMENT
-    /* This will tell playback thread that FM Rx is active
-     * and device will not go to standby
-     */
-    virtual     status_t    setFMRxActive(bool state) = 0;
-#endif
-
     // set audio mode
     virtual     status_t    setMode(audio_mode_t mode) = 0;
 
diff --git a/./frameworks/av/include/media/MediaProfiles.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/MediaProfiles.h
index 6715ddb..9fc962c 100644
--- a/./frameworks/av/include/media/MediaProfiles.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/MediaProfiles.h
@@ -67,9 +67,6 @@ enum videoeditor_capability {
 
 enum video_decoder {
     VIDEO_DECODER_WMV,
-#ifdef OMAP_ENHANCEMENT
-    VIDEO_DECODER_MPEG2,
-#endif
 };
 
 enum audio_decoder {
diff --git a/./frameworks/av/include/media/stagefright/AudioPlayer.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/AudioPlayer.h
index f21dae8..1dc408f 100644
--- a/./frameworks/av/include/media/stagefright/AudioPlayer.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/AudioPlayer.h
@@ -23,20 +23,12 @@
 #include <media/stagefright/TimeSource.h>
 #include <utils/threads.h>
 
-#ifdef OMAP_ENHANCEMENT
-#define OMAP_TIME_INTERPOLATOR
-#endif
-
 namespace android {
 
 class MediaSource;
 class AudioTrack;
 class AwesomePlayer;
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-class TimeInterpolator;
-#endif
-
 class AudioPlayer : public TimeSource {
 public:
     enum {
@@ -127,12 +119,6 @@ private:
 
     AudioPlayer(const AudioPlayer &);
     AudioPlayer &operator=(const AudioPlayer &);
-
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    sp<TimeInterpolator> mRealTimeInterpolator;
-public:
-    int64_t latency() const;
-#endif
 };
 
 }  // namespace android
diff --git a/./frameworks/av/include/media/stagefright/ColorConverter.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/ColorConverter.h
index b0c91f1..85ba920 100644
--- a/./frameworks/av/include/media/stagefright/ColorConverter.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/ColorConverter.h
@@ -25,10 +25,6 @@
 
 #include <OMX_Video.h>
 
-#ifdef OMAP_ENHANCEMENT
-#include <OMX_TI_Video.h>
-#endif
-
 namespace android {
 
 struct ColorConverter {
@@ -47,18 +43,6 @@ struct ColorConverter {
             size_t dstCropLeft, size_t dstCropTop,
             size_t dstCropRight, size_t dstCropBottom);
 
-#ifdef OMAP_ENHANCEMENT
-    status_t convertInterlacedBuffer(
-            const void *srcBits,
-            size_t srcWidth, size_t srcHeight,
-            size_t srcCropLeft, size_t srcCropTop,
-            size_t srcCropRight, size_t srcCropBottom,
-            OMX_TI_INTERLACETYPE buff_layout,
-            void *dstBits,
-            size_t dstWidth, size_t dstHeight,
-            size_t dstCropLeft, size_t dstCropTop,
-            size_t dstCropRight, size_t dstCropBottom);
-#endif
 private:
     struct BitmapParams {
         BitmapParams(
@@ -95,11 +79,6 @@ private:
     status_t convertTIYUV420PackedSemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
 
-#ifdef OMAP_ENHANCEMENT
-    status_t convertTIYUV420PackedSemiPlanarInterlaced(
-            const BitmapParams &src, const BitmapParams &dst);
-#endif
-
     ColorConverter(const ColorConverter &);
     ColorConverter &operator=(const ColorConverter &);
 };
diff --git a/./frameworks/av/include/media/stagefright/MediaDefs.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/MediaDefs.h
index ba56ffc..457d5d7 100644
--- a/./frameworks/av/include/media/stagefright/MediaDefs.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/MediaDefs.h
@@ -54,14 +54,6 @@ extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS;
 extern const char *MEDIA_MIMETYPE_CONTAINER_WVM;
 
 extern const char *MEDIA_MIMETYPE_TEXT_3GPP;
-
-#ifdef OMAP_ENHANCEMENT
-extern const char *MEDIA_MIMETYPE_CONTAINER_ASF;
-extern const char *MEDIA_MIMETYPE_VIDEO_WMV;
-extern const char *MEDIA_MIMETYPE_AUDIO_WMA;
-extern const char *MEDIA_MIMETYPE_AUDIO_WMAPRO;
-extern const char *MEDIA_MIMETYPE_AUDIO_WMALSL;
-#endif
 extern const char *MEDIA_MIMETYPE_TEXT_SUBRIP;
 
 }  // namespace android
diff --git a/./frameworks/av/include/media/stagefright/MediaSource.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/MediaSource.h
index f98584c..3818e63 100644
--- a/./frameworks/av/include/media/stagefright/MediaSource.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/MediaSource.h
@@ -23,9 +23,6 @@
 #include <media/stagefright/MediaErrors.h>
 #include <utils/RefBase.h>
 #include <utils/Vector.h>
-#ifdef OMAP_ENHANCEMENT
-#include <utils/String8.h>
-#endif
 
 namespace android {
 
@@ -118,26 +115,7 @@ protected:
 private:
     MediaSource(const MediaSource &);
     MediaSource &operator=(const MediaSource &);
-
-#ifdef OMAP_ENHANCEMENT
-public:
-    virtual status_t setParameter(const String8 &key, const String8 &value){
-        return OK;
-    }
-#endif
-};
-
-#ifdef OMAP_ENHANCEMENT
-struct MediaSourceWithHaveDeltaTable : public MediaSource
-{
-public:
-    virtual bool haveDeltaTable() const {
-        // Assume true by default.
-        // This means extractor can set presentation time correctly.
-        return true;
-    }
 };
-#endif /* OMAP_ENHANCEMENT */
 
 }  // namespace android
 
diff --git a/./frameworks/av/include/media/stagefright/MetaData.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/MetaData.h
index 0d43655..3c25a14 100644
--- a/./frameworks/av/include/media/stagefright/MetaData.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/MetaData.h
@@ -51,9 +51,6 @@ enum {
     kKeyESDS              = 'esds',  // raw data
     kKeyAACProfile        = 'aacp',  // int32_t
     kKeyAVCC              = 'avcc',  // raw data
-#ifdef OMAP_ENHANCEMENT
-    kKeyHdr               = 'hdrd',  // raw data
-#endif
     kKeyD263              = 'd263',  // raw data
     kKeyVorbisInfo        = 'vinf',  // raw data
     kKeyVorbisBooks       = 'vboo',  // raw data
@@ -132,9 +129,7 @@ enum {
     kKeyTextFormatData    = 'text',  // raw data
 
     kKeyRequiresSecureBuffers = 'secu',  // bool (int32_t)
-#ifdef OMAP_ENHANCEMENT
-    kKeyVideoFPS          = 'vfps', // int32_t
-#endif
+
     kKeyIsADTS            = 'adts',  // bool (int32_t)
 
     // If a MediaBuffer's data represents (at least partially) encrypted
@@ -159,22 +154,11 @@ enum {
     kKeyCryptoKey         = 'cryK',  // uint8_t[16]
     kKeyCryptoIV          = 'cryI',  // uint8_t[16]
     kKeyCryptoMode        = 'cryM',  // int32_t
-
-#ifdef OMAP_ENHANCEMENT
-    kKeyBufferLayout      = 'lout',
-#endif
-#ifdef OMAP_ENHANCEMENT_S3D
-    kKeyS3DLayout         = 's3dl',
-#endif
-
 };
 
 enum {
     kTypeESDS        = 'esds',
     kTypeAVCC        = 'avcc',
-#ifdef OMAP_ENHANCEMENT
-    kTypeHdr         = 'hdrd',
-#endif
     kTypeD263        = 'd263',
 };
 
diff --git a/./frameworks/av/include/media/stagefright/OMXCodec.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/OMXCodec.h
index de9445b..81350ca 100644
--- a/./frameworks/av/include/media/stagefright/OMXCodec.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/OMXCodec.h
@@ -60,11 +60,6 @@ struct OMXCodec : public MediaSource,
 
         // Secure decoding mode
         kUseSecureInputBuffers = 256,
-
-#ifdef OMAP_ENHANCEMENT
-        // To request codec to return frames in decode order
-        kEnableTimeStampInDecodeOrder         = 512,
-#endif
     };
     static sp<MediaSource> Create(
             const sp<IOMX> &omx,
@@ -360,18 +355,6 @@ private:
 
     OMXCodec(const OMXCodec &);
     OMXCodec &operator=(const OMXCodec &);
-
-#ifdef OMAP_ENHANCEMENT_S3D
-    void handle_extradata(void *data);
-    void setupAVCEncoderS3DParameters(int32_t s3dLayout);
-#endif
-
-#ifdef OMAP_ENHANCEMENT
-    OMX_U32 mInputMinBufferSize;
-public:
-    int32_t mVideoFPS;
-    status_t setParameter(const String8 &key, const String8 &value);
-#endif
 };
 
 struct CodecCapabilities {
diff --git a/./frameworks/av/include/media/stagefright/Utils.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/Utils.h
index 8a68c4d..d87902e 100644
--- a/./frameworks/av/include/media/stagefright/Utils.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/include/media/stagefright/Utils.h
@@ -22,50 +22,11 @@
 #include <utils/Errors.h>
 #include <utils/RefBase.h>
 
-#ifdef OMAP_ENHANCEMENT
-#include <media/openmax/OMX_Types.h>
-#include <media/openmax/OMX_Index.h>
-#endif
-
 namespace android {
 
 #define FOURCC(c1, c2, c3, c4) \
     (c1 << 24 | c2 << 16 | c3 << 8 | c4)
 
-#ifdef OMAP_ENHANCEMENT
-#ifndef MAKEFOURCC_WMC
-#define MAKEFOURCC_WMC(ch0, ch1, ch2, ch3) \
-        ((OMX_U32)(OMX_U8)(ch0) | ((OMX_U32)(OMX_U8)(ch1) << 8) |   \
-        ((OMX_U32)(OMX_U8)(ch2) << 16) | ((OMX_U32)(OMX_U8)(ch3) << 24 ))
-
-#define mmioFOURCC_WMC(ch0, ch1, ch2, ch3)  MAKEFOURCC_WMC(ch0, ch1, ch2, ch3)
-#endif
-
-#define FOURCC_WMV3     mmioFOURCC_WMC('W','M','V','3')
-#define FOURCC_WMV2     mmioFOURCC_WMC('W','M','V','2')
-#define FOURCC_WMV1     mmioFOURCC_WMC('W','M','V','1')
-#define FOURCC_WMVA     mmioFOURCC_WMC('W','M','V','A')
-#define FOURCC_WVC1     mmioFOURCC_WMC('W','V','C','1')
-
-#define VIDDEC_WMV_ELEMSTREAM                           0
-#define VIDDEC_WMV_RCVSTREAM                            1
-
-typedef enum VIDDEC_CUSTOM_PARAM_INDEX
-{
-    VideoDecodeCustomParamProcessMode = (OMX_IndexVendorStartUnused + 1),
-    VideoDecodeCustomParamH264BitStreamFormat,
-    VideoDecodeCustomParamWMVProfile,
-    VideoDecodeCustomParamWMVFileType,
-    VideoDecodeCustomParamParserEnabled,
-} VIDDEC_CUSTOM_PARAM_INDEX;
-
-typedef struct OMX_PARAM_WMVFILETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nWmvFileType;
-} OMX_PARAM_WMVFILETYPE;
-#endif
-
 uint16_t U16_AT(const uint8_t *ptr);
 uint32_t U32_AT(const uint8_t *ptr);
 uint64_t U64_AT(const uint8_t *ptr);
diff --git a/./frameworks/av/libvideoeditor/lvpp/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/libvideoeditor/lvpp/Android.mk
index e6a3ab7..c018d74 100755
--- a/./frameworks/av/libvideoeditor/lvpp/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/libvideoeditor/lvpp/Android.mk
@@ -79,6 +79,7 @@ LOCAL_C_INCLUDES += \
     $(TOP)/frameworks/av/libvideoeditor/lvpp \
     $(TOP)/frameworks/av/services/audioflinger \
     $(TOP)/frameworks/native/include/media/editor \
+    $(TOP)/frameworks/native/include/media/openmax \
     $(TOP)/frameworks/native/services/audioflinger
 
 
@@ -98,12 +99,6 @@ LOCAL_CFLAGS += -Wno-multichar \
     -DUSE_STAGEFRIGHT_READERS \
     -DUSE_STAGEFRIGHT_3GPP_READER
 
-ifdef OMAP_ENHANCEMENT
-LOCAL_C_INCLUDES += $(DOMX_PATH)/omx_core/inc
-else
-LOCAL_C_INCLUDES += $(TOP)/frameworks/native/include/media/openmax
-endif
-
 include $(BUILD_SHARED_LIBRARY)
 
 #include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/./frameworks/av/media/libmedia/IAudioFlinger.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmedia/IAudioFlinger.cpp
index 7bfaad7..e8dd438 100644
--- a/./frameworks/av/media/libmedia/IAudioFlinger.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmedia/IAudioFlinger.cpp
@@ -70,9 +70,6 @@ enum {
     GET_EFFECT_DESCRIPTOR,
     CREATE_EFFECT,
     MOVE_EFFECTS,
-#ifdef OMAP_ENHANCEMENT
-    SET_FMRX_ACTIVE,
-#endif
     LOAD_HW_MODULE
 };
 
@@ -277,17 +274,6 @@ public:
         return reply.readInt32();
     }
 
-#ifdef OMAP_ENHANCEMENT
-    virtual status_t setFMRxActive( bool state)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
-        data.writeInt32(state);
-        remote()->transact(SET_FMRX_ACTIVE, data, &reply);
-        return reply.readInt32();
-    }
-#endif
-
     virtual float streamVolume(audio_stream_type_t stream, audio_io_handle_t output) const
     {
         Parcel data, reply;
@@ -805,13 +791,6 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32( setStreamMute((audio_stream_type_t) stream, data.readInt32()) );
             return NO_ERROR;
         } break;
-#ifdef OMAP_ENHANCEMENT
-        case SET_FMRX_ACTIVE: {
-            CHECK_INTERFACE(IAudioFlinger, data, reply);
-            reply->writeInt32( setFMRxActive(data.readInt32()) );
-            return NO_ERROR;
-        } break;
-#endif
         case STREAM_VOLUME: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             int stream = data.readInt32();
diff --git a/./frameworks/av/media/libmedia/MediaProfiles.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmedia/MediaProfiles.cpp
index 80f5311..6929efa 100644
--- a/./frameworks/av/media/libmedia/MediaProfiles.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmedia/MediaProfiles.cpp
@@ -55,9 +55,6 @@ const MediaProfiles::NameToTagMap MediaProfiles::sFileFormatMap[] = {
 
 const MediaProfiles::NameToTagMap MediaProfiles::sVideoDecoderNameMap[] = {
     {"wmv", VIDEO_DECODER_WMV}
-#ifdef OMAP_ENHANCEMENT
-    ,{"mpeg2", VIDEO_DECODER_MPEG2}
-#endif
 };
 
 const MediaProfiles::NameToTagMap MediaProfiles::sAudioDecoderNameMap[] = {
diff --git a/./frameworks/av/media/libmedia/mediarecorder.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmedia/mediarecorder.cpp
index 27e0684..9541015 100644
--- a/./frameworks/av/media/libmedia/mediarecorder.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmedia/mediarecorder.cpp
@@ -398,9 +398,7 @@ status_t MediaRecorder::setParameters(const String8& params) {
 
     bool isInvalidState = (mCurrentState &
                            (MEDIA_RECORDER_PREPARED |
-#ifndef OMAP_ENHANCEMENT
                             MEDIA_RECORDER_RECORDING |
-#endif
                             MEDIA_RECORDER_ERROR));
     if (isInvalidState) {
         ALOGE("setParameters is called in an invalid state: %d", mCurrentState);
diff --git a/./frameworks/av/media/libmediaplayerservice/StagefrightRecorder.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmediaplayerservice/StagefrightRecorder.cpp
index e56171f..727fd0d 100644
--- a/./frameworks/av/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -68,9 +68,6 @@ static void addBatteryData(uint32_t params) {
 StagefrightRecorder::StagefrightRecorder()
     : mWriter(NULL),
       mOutputFd(-1),
-#ifdef OMAP_ENHANCEMENT
-      mVidEncoder(NULL),
-#endif
       mAudioSource(AUDIO_SOURCE_CNT),
       mVideoSource(VIDEO_SOURCE_LIST_END),
       mStarted(false), mSurfaceMediaSource(NULL) {
@@ -686,14 +683,6 @@ status_t StagefrightRecorder::setParameter(
             return setParamTimeBetweenTimeLapseFrameCapture(
                     1000LL * timeBetweenTimeLapseFrameCaptureMs);
         }
-#ifdef OMAP_ENHANCEMENT
-    } else if ((key == "video-param-insert-i-frame") ||
-               (key == "video-param-nalsize-bytes") ||
-               (key == "video-param-nalsize-macroblocks") ||
-               (key == "video-config-encoding-bitrate") ||
-               (key == "video-config-encoding-framerate")) {
-        return mVidEncoder->setParameter(key, value);
-#endif
     } else {
         ALOGE("setParameter: failed to find key %s", key.string());
     }
@@ -1416,13 +1405,6 @@ status_t StagefrightRecorder::setupVideoEncoder(
         enc_meta->setInt32(kKeyVideoLevel, mVideoEncoderLevel);
     }
 
-#ifdef OMAP_ENHANCEMENT_S3D
-    int32_t s3dLayout;
-    if (meta->findInt32(kKeyS3DLayout, &s3dLayout)) {
-        enc_meta->setInt32(kKeyS3DLayout, s3dLayout);
-    }
-#endif
-
     OMXClient client;
     CHECK_EQ(client.connect(), (status_t)OK);
 
@@ -1510,10 +1492,6 @@ status_t StagefrightRecorder::setupMPEG4Recording(
             return err;
         }
 
-#ifdef OMAP_ENHANCEMENT
-        mVidEncoder = encoder;
-#endif
-
         writer->addSource(encoder);
         *totalBitRate += videoBitRate;
     }
diff --git a/./frameworks/av/media/libmediaplayerservice/StagefrightRecorder.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmediaplayerservice/StagefrightRecorder.h
index 6a53bd9..ec5ce7e 100644
--- a/./frameworks/av/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libmediaplayerservice/StagefrightRecorder.h
@@ -76,9 +76,6 @@ private:
     int mOutputFd;
     sp<AudioSource> mAudioSourceNode;
 
-#ifdef OMAP_ENHANCEMENT
-    sp<MediaSource> mVidEncoder;
-#endif
     audio_source_t mAudioSource;
     video_source mVideoSource;
     output_format mOutputFormat;
diff --git a/./frameworks/av/media/libstagefright/AACExtractor.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/AACExtractor.cpp
index 4ed43ff..4d1072f 100644
--- a/./frameworks/av/media/libstagefright/AACExtractor.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/AACExtractor.cpp
@@ -136,12 +136,7 @@ AACExtractor::AACExtractor(
         const sp<DataSource> &source, const sp<AMessage> &_meta)
     : mDataSource(source),
       mInitCheck(NO_INIT),
-#ifdef OMAP_ENHANCEMENT
-      mFrameDurationUs(0),
-      mApeMeta(new MetaData) {
-#else
       mFrameDurationUs(0) {
-#endif
     sp<AMessage> meta = _meta;
 
     if (meta == NULL) {
@@ -175,33 +170,11 @@ AACExtractor::AACExtractor(
     off64_t streamSize, numFrames = 0;
     size_t frameSize = 0;
     int64_t duration = 0;
-#ifdef OMAP_ENHANCEMENT
-    uint8_t apeTag[8];
-#endif
 
     if (mDataSource->getSize(&streamSize) == OK) {
          while (offset < streamSize) {
-#ifdef OMAP_ENHANCEMENT
-            mDataSource->readAt(offset, &apeTag, 8);
-            if (ape.isAPE(apeTag)) {
-                size_t apeSize = 0;
-                mDataSource->readAt(offset + 8 + 4, &apeSize, 1);
-
-                if (ape.parceAPE(source, offset, &apeSize, mApeMeta) == false) {
-                    break;
-                }
-
-                mOffsetVector.push(offset);
-                offset += apeSize;
-                continue;
-            }
-#endif
             if ((frameSize = getAdtsFrameLength(source, offset, NULL)) == 0) {
-#ifdef OMAP_ENHANCEMENT
-                break;
-#else
                 return;
-#endif
             }
 
             mOffsetVector.push(offset);
@@ -223,26 +196,15 @@ AACExtractor::~AACExtractor() {
 }
 
 sp<MetaData> AACExtractor::getMetaData() {
-#ifndef OMAP_ENHANCEMENT
     sp<MetaData> meta = new MetaData;
-#endif
 
     if (mInitCheck != OK) {
-#ifdef OMAP_ENHANCEMENT
-        return mApeMeta;
-#else
         return meta;
-#endif
     }
-#ifdef OMAP_ENHANCEMENT
-    mApeMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC_ADTS);
 
-    return mApeMeta;
-#else
     meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC_ADTS);
 
     return meta;
-#endif
 }
 
 size_t AACExtractor::countTracks() {
diff --git a/./frameworks/av/media/libstagefright/ACodec.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/ACodec.cpp
index 74dbb14..c4743a1 100644
--- a/./frameworks/av/media/libstagefright/ACodec.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/ACodec.cpp
@@ -33,9 +33,6 @@
 #include <media/stagefright/OMXCodec.h>
 
 #include <OMX_Component.h>
-#ifdef OMAP_ENHANCEMENT
-#include <OMX_TI_IVCommon.h>
-#endif
 
 namespace android {
 
diff --git a/./frameworks/av/media/libstagefright/APE.cpp b/./frameworks/av/media/libstagefright/APE.cpp
deleted file mode 100644
index 7b74756..0000000
--- a/./frameworks/av/media/libstagefright/APE.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) Texas Instruments - http://www.ti.com/
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "APE_TAG"
-#include <utils/Log.h>
-
-#include "include/APE.h"
-
-namespace android {
-
-APE::APE(){
-
-}
-
-APE::~APE(){
-
-}
-
-bool APE::isAPE(uint8_t *apeTag) const {
-    if(apeTag[0] == 'A' && apeTag[1] == 'P' && apeTag[2] == 'E' &&
-        apeTag[3] == 'T' && apeTag[4] == 'A' && apeTag[5] == 'G' &&
-        apeTag[6] == 'E' && apeTag[7] == 'X'){
-        return true;
-    }
-    return false;
-}
-
-size_t sizeItemKey(const sp<DataSource> &source, off64_t offset){
-    off64_t ItemKeyOffset = offset;
-    uint8_t keyTerminator;
-    size_t keySize = 0;
-    while (keyTerminator != 0){
-        source->readAt(ItemKeyOffset, &keyTerminator, 1);
-        ItemKeyOffset++;
-        keySize++;
-    }
-    return keySize - 1;
-}
-
-bool APE::parceAPE(const sp<DataSource> &source, off64_t offset,
-        size_t* headerSize, sp<MetaData> &meta){
-
-    struct Map {
-            int key;
-            const char *tag;
-    } const kMap[] = {
-            { kKeyAlbum, "Album" },
-            { kKeyArtist, "Artist" },
-            { kKeyAlbumArtist, "Album" },
-            { kKeyComposer, "Composer" },
-            { kKeyGenre, "Genre" },
-            { kKeyTitle, "Title" },
-            { kKeyYear, "Year" },
-            { kKeyCDTrackNumber, "Track" },
-            { kKeyDate, "Record Date"},
-    };
-
-    static const size_t kNumMapEntries = sizeof(kMap) / sizeof(kMap[0]);
-
-    off64_t headerOffset = offset;
-    headerOffset += 16;
-    itemNumber = 0;
-    if (source->readAt(headerOffset, &itemNumber, 1) == 0)
-        return false;
-
-    headerOffset += 16;
-
-    for(uint32_t it = 0; it < itemNumber; it++){
-        lenValue = 0;
-        if (source->readAt(headerOffset, &lenValue, 1) == 0)
-            return false;
-
-        headerOffset += 4;
-
-        itemFlags = 0;
-        if (source->readAt(headerOffset, &itemFlags, 1) == 0)
-            return false;
-
-        headerOffset += 4;
-
-        size_t sizeKey = sizeItemKey(source, headerOffset);
-
-        char *key = new char[sizeKey];
-
-        if (source->readAt(headerOffset, key, sizeKey) == 0)
-            return false;
-
-        key[sizeKey] = '\0';
-        headerOffset += sizeKey + 1;
-
-        char *val = new char[lenValue + 1];
-
-        if (source->readAt(headerOffset, val, lenValue) == 0)
-            return false;
-
-        val[lenValue] = '\0';
-
-        for (size_t i = 0; i < kNumMapEntries; i++){
-            if (!strcmp(key, kMap[i].tag)){
-                if (itemFlags == 0)
-                    meta->setCString(kMap[i].key, (const char *)val);
-                break;
-            }
-        }
-        headerOffset += lenValue;
-        delete[] key;
-        delete[] val;
-    }
-
-    return true;
-}
-} //namespace android
diff --git a/./frameworks/av/media/libstagefright/ASFExtractor.cpp b/./frameworks/av/media/libstagefright/ASFExtractor.cpp
deleted file mode 100644
index 5d05eac..0000000
--- a/./frameworks/av/media/libstagefright/ASFExtractor.cpp
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- *****************************************************************************
- *
- *                                Android
- *                  ITTIAM SYSTEMS PVT LTD, BANGALORE
- *                           COPYRIGHT(C) 2010-20
- *
- *  This program  is  proprietary to  Ittiam  Systems  Private  Limited  and
- *  is protected under Indian  Copyright Law as an unpublished work. Its use
- *  and  disclosure  is  limited by  the terms  and  conditions of a license
- *  agreement. It may not be copied or otherwise  reproduced or disclosed to
- *  persons outside the licensee's organization except in accordance with the
- *  terms  and  conditions   of  such  an  agreement.  All  copies  and
- *  reproductions shall be the property of Ittiam Systems Private Limited and
- *  must bear this notice in its entirety.
- *
- *****************************************************************************
- */
-/**
- *****************************************************************************
- *
- *  @file     ASFExtractor.cpp
- *
- *  @brief    This file works as a wrapper to the ASFExtractor class
- *
- *****************************************************************************
- */
-
-#define LOG_TAG "ASFDummyExtractor"
-#include <utils/Log.h>
-
-#include <media/stagefright/MediaSource.h>
-#include <media/stagefright/MetaData.h>
-#include <media/stagefright/MediaExtractor.h>
-#include <utils/Vector.h>
-#include <dlfcn.h>   /* For dynamic loading */
-#include "include/ASFExtractor.h"
-
-namespace android {
-    static void * pASFHandle = NULL;
-
-ASFExtractor::ASFExtractor(const sp<DataSource> &source) {
-    const char *errstr;
-    ALOGD("Dummy ASFExtractor contructor");
-
-    pASFParser = new ASF_WRAPER;
-
-    pASFParser->ASFExtractor =     ( ASFExtractorImpl* (*)(const android::sp<android::DataSource>&))dlsym(pASFHandle, "ASFExtractor");
-    if((errstr = dlerror()) != NULL){
-        ALOGE("dlsym(), err: %s", errstr);
-        dlclose(pASFHandle);
-        delete pASFParser;
-        return;
-    }
-    pASFParser->destructorASFExtractor =     (void (*)(ASFExtractorImpl *))dlsym(pASFHandle, "destructorASFExtractor");
-    if((errstr = dlerror()) != NULL){
-        ALOGE("dlsym(), err: %s", errstr);
-        dlclose(pASFHandle);
-        delete pASFParser;
-        return;
-    }
-    pASFParser->countTracks =       (size_t (*)(ASFExtractorImpl *))dlsym(pASFHandle, "countTracks");
-    if((errstr = dlerror()) != NULL){
-        ALOGE("dlsym(), err: %s", errstr);
-        dlclose(pASFHandle);
-        delete pASFParser;
-        return;
-    }
-    pASFParser->getTrack =          (android::sp<android::MediaSource> (*)(size_t, ASFExtractorImpl *))dlsym(pASFHandle, "getTrack");
-    if((errstr = dlerror()) != NULL){
-        ALOGE("dlsym(), err: %s", errstr);
-        dlclose(pASFHandle);
-        delete pASFParser;
-        return;
-    }
-    pASFParser->getTrackMetaData =  (android::sp<android::MetaData> (*)(size_t, uint32_t, ASFExtractorImpl *))dlsym(pASFHandle, "getTrackMetaData");
-    if((errstr = dlerror()) != NULL){
-        ALOGE("dlsym(), err: %s", errstr);
-        dlclose(pASFHandle);
-        delete pASFParser;
-        return;
-    }
-    pASFParser->getMetaData =       (android::sp<android::MetaData> (*)(ASFExtractorImpl *))dlsym(pASFHandle, "getMetaData");
-    if((errstr = dlerror()) != NULL){
-        ALOGE("dlsym(), err: %s", errstr);
-        dlclose(pASFHandle);
-        delete pASFParser;
-        return;
-    }
-
-
-    mHandle = (*pASFParser->ASFExtractor)(source);
-}
-
-ASFExtractor::~ASFExtractor() {
-    ALOGD("Dummy ASFExtractor destructor");
-    if(!pASFParser) {
-        return;
-    }
-
-    (pASFParser->destructorASFExtractor)(mHandle);
-
-    //DL lib is unloaded only when ref count drops to 0
-    dlclose(pASFHandle);
-
-    delete pASFParser;
-    pASFParser = NULL;
-}
-
-size_t ASFExtractor::countTracks() {
-    ALOGV("Dummy ASFExtractor::countTracks()");
-    if(!pASFParser) {
-        return 0;
-    }
-
-    return (*pASFParser->countTracks)(mHandle);
-}
-
-sp<MediaSource> ASFExtractor::getTrack(size_t index) {
-    ALOGV("Dummy ASFExtractor::getTrack()");
-    if(!pASFParser) {
-        return NULL;
-    }
-
-    return (*pASFParser->getTrack)(index, mHandle);
-}
-
-sp<MetaData> ASFExtractor::getTrackMetaData(
-        size_t index, uint32_t flags) {
-    if(!pASFParser) {
-        return NULL;
-    }
-
-    return (*pASFParser->getTrackMetaData)(index, flags, mHandle);
-}
-
-sp<MetaData> ASFExtractor::getMetaData() {
-    ALOGV("Dummy ASFExtractor::getMetaData()");
-    if(!pASFParser) {
-        return NULL;
-    }
-
-    return (*pASFParser->getMetaData)(mHandle);
-}
-
-bool SniffASF(const sp<DataSource> &source,
-              String8 *mimeType,
-              float *confidence,
-              sp<AMessage> *meta)
-{
-    const char *errstr;
-
-    static bool (*pSniffASF)(
-        const sp<DataSource> &source,
-        String8 *mimeType,
-        float *confidence,
-        sp<AMessage> *meta);
-
-    dlerror();
-
-    pASFHandle = dlopen("/system/lib/libittiam_asfextractor.so", RTLD_LAZY);
-    if((errstr = dlerror()) != NULL) {
-        ALOGE("dlopen() err: %s", errstr);
-        return false;
-    }
-
-    pSniffASF =(bool (*)(const android::sp<android::DataSource>&, android::String8*, float*, android::sp<android::AMessage>*)) dlsym(pASFHandle, "SniffASF");
-    if((errstr = dlerror()) != NULL) {
-        ALOGE("Error dlsym(pSniffASF), err: %s", errstr);
-        return false;
-    }
-    bool asf = (*pSniffASF)(source, mimeType, confidence, meta);
-    if (!asf) {
-        //DL lib is unloaded only when ref count drops to 0
-        dlclose(pASFHandle);
-    }
-    return asf;
-}
-
-bool isASFParserAvailable()
-{
-    FILE *pF;
-
-    ALOGE ("isASFParserAvailable \n");
-    pF = fopen("/system/lib/libittiam_asfextractor.so", "r");
-    if(!pF) {
-        ALOGW("ASF parser is not available");
-        return false;
-    }
-    fclose(pF);
-
-    return true;
-}
-
-}  // namespace android
diff --git a/./frameworks/av/media/libstagefright/AVIExtractor.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/AVIExtractor.cpp
index 752bc48..5a6211e 100644
--- a/./frameworks/av/media/libstagefright/AVIExtractor.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/AVIExtractor.cpp
@@ -16,13 +16,6 @@
 
 //#define LOG_NDEBUG 0
 #define LOG_TAG "AVIExtractor"
-
-#ifdef OMAP_ENHANCEMENT
-#define BITMAPINFO_HDR_SIZE 40
-#define HDR_LENGTH 4
-#define WMV_CFG_PREFIX_LEN 15
-#define VC1_MAX_PREFIX_LEN 100
-#endif
 #include <utils/Log.h>
 
 #include "include/avc_utils.h"
@@ -191,44 +184,13 @@ status_t AVIExtractor::AVISource::read(
 
         MediaBuffer *out;
         CHECK_EQ(mBufferGroup->acquire_buffer(&out), (status_t)OK);
-#ifdef OMAP_ENHANCEMENT
-        const Track &track = mExtractor->mTracks.itemAt(mTrackIndex);
-        ssize_t startprefexLength=0;
-        /*For VC1 encodedstreams, Decoder expects that the first frame have
-         config header followed by 4byte data prefex  0x0000010d followed by
-         data.  All other frames should have the 4byte data prefex
-         0x0000010d followed by data*/
-        if (track.mKind == Track::VIDEO &&  mExtractor->mIsVC1) {
-            void *edata = out->data();
-            if (mSampleIndex==1) {
-                uint32_t type;
-                const void *configdata;
-                size_t ConfingLen;
-                uint32_t hdr_offset;
-
-                track.mMeta->findData(kKeyHdr, &type, &configdata, &ConfingLen);
-                hdr_offset = BITMAPINFO_HDR_SIZE+WMV_CFG_PREFIX_LEN-HDR_LENGTH+1;
-                memcpy(edata,(char *)configdata+hdr_offset,ConfingLen-hdr_offset);
-                startprefexLength = ConfingLen-hdr_offset;
-                edata = (char*)edata + startprefexLength;
-            }
-            /*data prefex 0x00 00 01 0d*/
-            memcpy(edata, "\x00\x00\x01\x0d", 4);
-            startprefexLength+=4;
-        }
-        ssize_t n = mExtractor->mDataSource->readAt(offset,
-                               (char*)( out->data())+startprefexLength, size);
-#else
+
         ssize_t n = mExtractor->mDataSource->readAt(offset, out->data(), size);
-#endif
 
         if (n < (ssize_t)size) {
             return n < 0 ? (status_t)n : (status_t)ERROR_MALFORMED;
         }
 
-#ifdef OMAP_ENHANCEMENT
-        size = size+startprefexLength;
-#endif
         out->set_range(0, size);
 
         out->meta_data()->setInt64(kKeyTime, timeUs);
@@ -405,9 +367,6 @@ status_t AVIExtractor::MP3Splitter::read(MediaBuffer **out) {
 
 AVIExtractor::AVIExtractor(const sp<DataSource> &dataSource)
     : mDataSource(dataSource) {
-#ifdef OMAP_ENHANCEMENT
-    mIsVC1 = 0;
-#endif
     mInitCheck = parseHeaders();
 
     if (mInitCheck != OK) {
@@ -622,23 +581,6 @@ static const char *GetMIMETypeForHandler(uint32_t handler) {
         case FOURCC('v', 's', 's', 'h'):
             return MEDIA_MIMETYPE_VIDEO_AVC;
 
-#ifdef OMAP_ENHANCEMENT
-
-        case FOURCC('D','2','6','3'):
-        case FOURCC('H','2','6','3'):
-        case FOURCC('L','2','6','3'):
-        case FOURCC('M','2','6','3'):
-        case FOURCC('S','2','6','3'):
-        case FOURCC('T','2','6','3'):
-        case FOURCC('U','2','6','3'):
-        case FOURCC('X','2','6','3'):
-             return MEDIA_MIMETYPE_VIDEO_H263;
-
-        case FOURCC('W','M','V','3'):
-        case FOURCC('W','M','V','9'):
-        case FOURCC('W','V','C','1'):
-            return MEDIA_MIMETYPE_VIDEO_WMV;
-#endif
         default:
             return NULL;
     }
@@ -670,10 +612,7 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
 
     uint32_t rate = U32LE_AT(&data[20]);
     uint32_t scale = U32LE_AT(&data[24]);
-#ifdef OMAP_ENHANCEMENT
-    //Calculating fps and rounding to the closest integer value
-    uint32_t fps=(scale * 1.0 / rate) + 0.5;
-#endif
+
     uint32_t sampleSize = U32LE_AT(&data[44]);
 
     const char *mime = NULL;
@@ -711,13 +650,6 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
 
     mTracks.push();
     Track *track = &mTracks.editItemAt(mTracks.size() - 1);
-#ifdef OMAP_ENHANCEMENT
-    if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_WMV)){
-        if(FOURCC('W','V','C','1')==handler){
-            mIsVC1= true;
-        }
-    }
-#endif
 
     track->mMeta = meta;
     track->mRate = rate;
@@ -730,9 +662,7 @@ status_t AVIExtractor::parseStreamHeader(off64_t offset, size_t size) {
     track->mMaxSampleSize = 0;
     track->mAvgChunkSize = 1.0;
     track->mFirstChunkSize = 0;
-#ifdef OMAP_ENHANCEMENT
-    track->mMeta->setInt32(kKeyVideoFPS,fps);
-#endif
+
     return OK;
 }
 
@@ -770,33 +700,6 @@ status_t AVIExtractor::parseStreamFormat(off64_t offset, size_t size) {
 
         track->mMeta->setInt32(kKeyWidth, width);
         track->mMeta->setInt32(kKeyHeight, height);
-
-#ifdef OMAP_ENHANCEMENT
-        const char *tmp;
-        CHECK(track->mMeta->findCString(kKeyMIMEType, &tmp));
-        AString mime = tmp;
-
-        if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_WMV)) {
-        /*Incase of WMV/VC1, the codec specific header is placed at the end
-        of StreamFormatHeader, i.e immediately after BitmapInfoHeader
-        We need to compare the size of StreamFormatHeader against the
-        BitmapInfoHeade size. If the StreamFormatHeader size is greater then
-         it implies that  config header is inserted at the end */
-        if (size > BITMAPINFO_HDR_SIZE) {
-
-            /*codec config header should be start with start code consisiting
-            15bytes of zeros followed by the BitmapInfo header(excluding the
-            length field) followed by configheader*/
-            uint8_t *edata = new uint8_t[WMV_CFG_PREFIX_LEN+size-HDR_LENGTH];
-            memset(edata,0x0,WMV_CFG_PREFIX_LEN);
-            memcpy(edata+WMV_CFG_PREFIX_LEN,data+HDR_LENGTH,
-                                       size-HDR_LENGTH);
-            track->mMeta->setData(kKeyHdr,kTypeHdr,edata,
-                                       WMV_CFG_PREFIX_LEN+size-HDR_LENGTH);
-            delete(edata);
-        }
-    }
-#endif
     } else {
         uint32_t format = U16LE_AT(data);
 
@@ -1034,18 +937,6 @@ status_t AVIExtractor::parseIndex(off64_t offset, size_t size) {
                 err = addH264CodecSpecificData(i);
             }
 
-#ifdef OMAP_ENHANCEMENT
-            else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_WMV)) {
-
-            /*Max sample size is increased considering VC1 encoded Stream into account.
-            As VC1 decoder expects data to be prefexed with start code(for all frames)
-            and configheader  (incase of first frame)*/
-                if (mIsVC1) {
-                    track->mMaxSampleSize+=VC1_MAX_PREFIX_LEN;
-                    track->mMeta->setInt32(kKeyMaxInputSize, track->mMaxSampleSize);
-                }
-            }
-#endif
             if (err != OK) {
                 return err;
             }
diff --git a/./frameworks/av/media/libstagefright/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/Android.mk
index d94465f..8ad1cb9 100644
--- a/./frameworks/av/media/libstagefright/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/Android.mk
@@ -53,28 +53,16 @@ LOCAL_SRC_FILES:=                         \
         WVMExtractor.cpp                  \
         XINGSeeker.cpp                    \
         avc_utils.cpp                     \
-        APE.cpp                           \
-
-ifeq ($(OMAP_ENHANCEMENT), true)
-LOCAL_SRC_FILES += ASFExtractor.cpp
-LOCAL_SRC_FILES +=  AVIExtractor.cpp
-LOCAL_SRC_FILES += TimeInterpolator.cpp
-endif
 
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
         $(TOP)/frameworks/native/include/media/hardware \
+        $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/external/expat/lib \
         $(TOP)/external/flac/include \
         $(TOP)/external/tremolo \
         $(TOP)/external/openssl/include \
 
-ifdef OMAP_ENHANCEMENT
-LOCAL_C_INCLUDES += $(DOMX_PATH)/omx_core/inc
-else
-LOCAL_C_INCLUDES += $(TOP)/frameworks/native/include/media/openmax
-endif
-
 LOCAL_SHARED_LIBRARIES := \
         libbinder \
         libcamera_client \
diff --git a/./frameworks/av/media/libstagefright/AudioPlayer.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/AudioPlayer.cpp
index 3abe4fa..4208019 100644
--- a/./frameworks/av/media/libstagefright/AudioPlayer.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/AudioPlayer.cpp
@@ -29,9 +29,6 @@
 #include <media/stagefright/MetaData.h>
 
 #include "include/AwesomePlayer.h"
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-#include "include/TimeInterpolator.h"
-#endif
 
 namespace android {
 
@@ -58,12 +55,7 @@ AudioPlayer::AudioPlayer(
       mAudioSink(audioSink),
       mAllowDeepBuffering(allowDeepBuffering),
       mObserver(observer),
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-      mPinnedTimeUs(-1ll),
-      mRealTimeInterpolator(new TimeInterpolator) {
-#else
       mPinnedTimeUs(-1ll) {
-#endif
 }
 
 AudioPlayer::~AudioPlayer() {
@@ -195,11 +187,6 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
         mAudioTrack->start();
     }
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    ALOGI("mLatencyUs = %lld", mLatencyUs);
-    mRealTimeInterpolator->set_latency(mLatencyUs);
-#endif
-
     mStarted = true;
     mPinnedTimeUs = -1ll;
 
@@ -216,9 +203,6 @@ void AudioPlayer::pause(bool playPendingSamples) {
             mAudioTrack->stop();
         }
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-        mRealTimeInterpolator->stop();
-#endif
         mNumFramesPlayed = 0;
         mNumFramesPlayedSysTimeUs = ALooper::GetNowUs();
     } else {
@@ -229,19 +213,12 @@ void AudioPlayer::pause(bool playPendingSamples) {
         }
 
         mPinnedTimeUs = ALooper::GetNowUs();
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-        mRealTimeInterpolator->pause();
-#endif
     }
 }
 
 void AudioPlayer::resume() {
     CHECK(mStarted);
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    mRealTimeInterpolator->resume();
-#endif
-
     if (mAudioSink.get() != NULL) {
         mAudioSink->start();
     } else {
@@ -297,9 +274,6 @@ void AudioPlayer::reset() {
     mReachedEOS = false;
     mFinalStatus = OK;
     mStarted = false;
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    mRealTimeInterpolator->reset();
-#endif
 }
 
 // static
@@ -383,13 +357,6 @@ size_t AudioPlayer::fillBuffer(void *data, size_t size) {
     bool postEOS = false;
     int64_t postEOSDelayUs = 0;
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    mRealTimeInterpolator->post_buffer(
-        TimeInterpolator::bytes_to_usecs(size, mFrameSize, mSampleRate)
-        );
-    mPositionTimeRealUs = mRealTimeInterpolator->get_stream_usecs();
-#endif
-
     size_t size_done = 0;
     size_t size_remaining = size;
     while (size_remaining > 0) {
@@ -490,11 +457,9 @@ size_t AudioPlayer::fillBuffer(void *data, size_t size) {
             CHECK(mInputBuffer->meta_data()->findInt64(
                         kKeyTime, &mPositionTimeMediaUs));
 
-#if ! (defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR))
             mPositionTimeRealUs =
                 ((mNumFramesPlayed + size_done / mFrameSize) * 1000000)
                     / mSampleRate;
-#endif
 
             ALOGV("buffer->size() = %d, "
                  "mPositionTimeMediaUs=%.2f mPositionTimeRealUs=%.2f",
@@ -550,11 +515,7 @@ size_t AudioPlayer::fillBuffer(void *data, size_t size) {
 
 int64_t AudioPlayer::getRealTimeUs() {
     Mutex::Autolock autoLock(mLock);
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    return mRealTimeInterpolator->get_stream_usecs();
-#else
     return getRealTimeUsLocked();
-#endif
 }
 
 int64_t AudioPlayer::getRealTimeUsLocked() const {
@@ -596,25 +557,11 @@ int64_t AudioPlayer::getMediaTimeUs() {
     return mPositionTimeMediaUs + realTimeOffset;
 }
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-int64_t AudioPlayer::latency() const
-{
-    return mLatencyUs;
-}
-#endif
-
 bool AudioPlayer::getMediaTimeMapping(
         int64_t *realtime_us, int64_t *mediatime_us) {
     Mutex::Autolock autoLock(mLock);
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    /* AwesomePlayer wants to make sure that the read pointer in
-     * the codec is close to what the buffer "read pointer" is.
-     */
-    *realtime_us = mRealTimeInterpolator->read_pointer();
-#else
     *realtime_us = mPositionTimeRealUs;
-#endif
     *mediatime_us = mPositionTimeMediaUs;
 
     return mPositionTimeRealUs != -1 && mPositionTimeMediaUs != -1;
@@ -627,9 +574,6 @@ status_t AudioPlayer::seekTo(int64_t time_us) {
     mPositionTimeRealUs = mPositionTimeMediaUs = -1;
     mReachedEOS = false;
     mSeekTimeUs = time_us;
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    mRealTimeInterpolator->seek(time_us);
-#endif
 
     // Flush resets the number of played frames
     mNumFramesPlayed = 0;
diff --git a/./frameworks/av/media/libstagefright/AwesomePlayer.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/AwesomePlayer.cpp
index b19c0ce..0f346d8 100644
--- a/./frameworks/av/media/libstagefright/AwesomePlayer.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/AwesomePlayer.cpp
@@ -32,10 +32,6 @@
 #include "include/MPEG2TSExtractor.h"
 #include "include/WVMExtractor.h"
 
-#ifdef OMAP_ENHANCEMENT
-#include "include/ASFExtractor.h"
-#endif
-
 #include <binder/IPCThreadState.h>
 #include <binder/IServiceManager.h>
 #include <media/IMediaPlayerService.h>
@@ -69,37 +65,6 @@ static int64_t kHighWaterMarkUs = 5000000ll;  // 5secs
 static const size_t kLowWaterMarkBytes = 40000;
 static const size_t kHighWaterMarkBytes = 200000;
 
-/*
-    To print the FPS, type this command on the console before starting playback:
-    setprop debug.video.showfps 1
-    To disable the prints, type:
-    setprop debug.video.showfps 0
-
-*/
-
-#ifdef OMAP_ENHANCEMENT
-
-static int mDebugFps = 0;
-static void debugShowFPS()
-{
-    static int mFrameCount = 0;
-    static int mLastFrameCount = 0;
-    static nsecs_t mLastFpsTime = 0;
-    static float mFps = 0;
-    mFrameCount++;
-    if (!(mFrameCount & 0x1F)) {
-        nsecs_t now = systemTime();
-        nsecs_t diff = now - mLastFpsTime;
-        mFps = ((mFrameCount - mLastFrameCount) * float(s2ns(1))) / diff;
-        mLastFpsTime = now;
-        mLastFrameCount = mFrameCount;
-        ALOGD("%d Frames, %f FPS", mFrameCount, mFps);
-    }
-    // XXX: mFPS has the value we want
-}
-
-#endif
-
 struct AwesomeEvent : public TimedEventQueue::Event {
     AwesomeEvent(
             AwesomePlayer *player,
@@ -157,12 +122,6 @@ struct AwesomeNativeWindowRenderer : public AwesomeRenderer {
             int32_t rotationDegrees)
         : mNativeWindow(nativeWindow) {
         applyRotation(rotationDegrees);
-#ifdef OMAP_ENHANCEMENT
-    char value[PROPERTY_VALUE_MAX];
-    property_get("debug.video.showfps", value, "0");
-    mDebugFps = atoi(value);
-    ALOGD_IF(mDebugFps, "showfps enabled");
-#endif
     }
 
     virtual void render(MediaBuffer *buffer) {
@@ -180,11 +139,6 @@ struct AwesomeNativeWindowRenderer : public AwesomeRenderer {
 
         sp<MetaData> metaData = buffer->meta_data();
         metaData->setInt32(kKeyRendered, 1);
-#ifdef OMAP_ENHANCEMENT
-        if (mDebugFps != 0) {
-          debugShowFPS();
-        }
-#endif
     }
 
 protected:
@@ -239,13 +193,7 @@ AwesomePlayer::AwesomePlayer()
       mVideoBuffer(NULL),
       mDecryptHandle(NULL),
       mLastVideoTimeUs(-1),
-#ifdef OMAP_ENHANCEMENT
-      mTextDriver(NULL),
-      mExtractor(NULL),
-      mExtractorType(NULL) {
-#else
       mTextDriver(NULL) {
-#endif
     CHECK_EQ(mClient.connect(), (status_t)OK);
 
     DataSource::RegisterDefaultSniffers();
@@ -275,9 +223,6 @@ AwesomePlayer::~AwesomePlayer() {
     reset();
 
     mClient.disconnect();
-#ifdef OMAP_ENHANCEMENT
-    mExtractor.clear();
-#endif
 }
 
 void AwesomePlayer::cancelPlayerEvents(bool keepNotifications) {
@@ -395,17 +340,6 @@ status_t AwesomePlayer::setDataSource_l(
         checkDrmStatus(dataSource);
     }
 
-#ifdef OMAP_ENHANCEMENT
-    sp<MetaData> fileMetadata = extractor->getMetaData();
-    bool isAvailable = fileMetadata->findCString(kKeyMIMEType, &mExtractorType);
-    if(isAvailable) {
-        ALOGV("%s:: ExtractorType %s", __FUNCTION__,  mExtractorType);
-    } else {
-        ALOGV("%s:: ExtractorType not available", __FUNCTION__);
-    }
-    mExtractor = extractor;
-#endif
-
     return setDataSource_l(extractor);
 }
 
@@ -479,12 +413,6 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
                 mDisplayWidth = displayWidth;
                 mDisplayHeight = displayHeight;
             }
-#ifdef OMAP_ENHANCEMENT
-            else {
-                meta->findInt32(kKeyWidth, &mDisplayWidth);
-                meta->findInt32(kKeyHeight, &mDisplayHeight);
-            }
-#endif
 
             {
                 Mutex::Autolock autoLock(mStatsLock);
@@ -716,11 +644,7 @@ void AwesomePlayer::onVideoLagUpdate() {
     }
     mVideoLagEventPending = false;
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    int64_t audioTimeUs = mAudioPlayer->getRealTimeUs();
-#else
     int64_t audioTimeUs = mAudioPlayer->getMediaTimeUs();
-#endif
     int64_t videoLateByUs = audioTimeUs - mVideoTimeUs;
 
     if (!(mFlags & VIDEO_AT_EOS) && videoLateByUs > 300000ll) {
@@ -1283,15 +1207,7 @@ void AwesomePlayer::shutdownVideoDecoder_l() {
         usleep(1000);
     }
     IPCThreadState::self()->flushCommands();
-
-#ifdef OMAP_ENHANCEMENT
-    if (mDebugFps != 0) {
-        ALOGD("video decoder shutdown completed");
-    }
-#else
     ALOGV("video decoder shutdown completed");
-#endif
-
 }
 
 status_t AwesomePlayer::setNativeWindow_l(const sp<ANativeWindow> &native) {
@@ -1369,11 +1285,7 @@ status_t AwesomePlayer::getPosition(int64_t *positionUs) {
         Mutex::Autolock autoLock(mMiscStateLock);
         *positionUs = mVideoTimeUs;
     } else if (mAudioPlayer != NULL) {
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-        *positionUs = mAudioPlayer->getRealTimeUs();
-#else
         *positionUs = mAudioPlayer->getMediaTimeUs();
-#endif
     } else {
         *positionUs = 0;
     }
@@ -1475,17 +1387,6 @@ status_t AwesomePlayer::initAudioDecoder() {
 
     if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
         mAudioSource = mAudioTrack;
-#ifdef OMAP_ENHANCEMENT
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_WMA)) {
-        const char *componentName  = "OMX.ITTIAM.WMA.decode";
-        mAudioSource = OMXCodec::Create(
-        mClient.interface(), mAudioTrack->getFormat(),
-        false,
-        mAudioTrack, componentName);
-        if (mAudioSource == NULL) {
-            ALOGE("Failed to create OMX component for WMA codec");
-        }
-#endif
     } else {
         mAudioSource = OMXCodec::Create(
                 mClient.interface(), mAudioTrack->getFormat(),
@@ -1583,23 +1484,6 @@ status_t AwesomePlayer::initVideoDecoder(uint32_t flags) {
         flags |= OMXCodec::kEnableGrallocUsageProtected;
     }
 #endif
-
-#ifdef OMAP_ENHANCEMENT
-    sp<MetaData> fileMetadata = mExtractor->getMetaData();
-    bool isAvailable = fileMetadata->findCString(kKeyMIMEType, &mExtractorType);
-    bool have_delta_table = true;
-    if (!strcasecmp("video/mp4", mExtractorType)) {
-        struct MediaSourceWithHaveDeltaTable *msdt =
-                static_cast<MediaSourceWithHaveDeltaTable*>(mVideoTrack.get());
-        have_delta_table = msdt->haveDeltaTable();
-    }
-    if ((!have_delta_table) || isAvailable &&
-        (!strcasecmp(MEDIA_MIMETYPE_CONTAINER_ASF, mExtractorType)
-        || !strcasecmp(MEDIA_MIMETYPE_CONTAINER_AVI, mExtractorType))) {
-            flags |= OMXCodec::kEnableTimeStampInDecodeOrder;
-    }
-#endif
-
     ALOGV("initVideoDecoder flags=0x%x", flags);
     mVideoSource = OMXCodec::Create(
             mClient.interface(), mVideoTrack->getFormat(),
@@ -1857,18 +1741,7 @@ void AwesomePlayer::onVideoEvent() {
     if (wasSeeking == NO_SEEK) {
         // Let's display the first frame after seeking right away.
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-        int64_t nowUs = ts->getRealTimeUs();
-
-        if (ts == (TimeSource*)&mSystemTimeSource) {
-            /* At end of audio stream, clock switches back to system clock.
-             * This keeps the timeline from having a big jump.
-             */
-            nowUs -= mTimeSourceDeltaUs;
-        }
-#else
         int64_t nowUs = ts->getRealTimeUs() - mTimeSourceDeltaUs;
-#endif
 
         int64_t latenessUs = nowUs - timeUs;
 
@@ -1878,15 +1751,8 @@ void AwesomePlayer::onVideoEvent() {
                 && mAudioPlayer != NULL
                 && mAudioPlayer->getMediaTimeMapping(
                     &realTimeUs, &mediaTimeUs)) {
-#ifdef OMAP_ENHANCEMENT
-            if (mDebugFps != 0) {
-                ALOGD("we're much too late (%.2f secs), video skipping ahead",
-                      latenessUs / 1E6);
-            }
-#else
             ALOGI("we're much too late (%.2f secs), video skipping ahead",
                  latenessUs / 1E6);
-#endif
 
             mVideoBuffer->release();
             mVideoBuffer = NULL;
@@ -1894,11 +1760,7 @@ void AwesomePlayer::onVideoEvent() {
             mSeeking = SEEK_VIDEO_ONLY;
             mSeekTimeUs = mediaTimeUs;
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-            postVideoEvent_l(0);
-#else
             postVideoEvent_l();
-#endif
             return;
         }
 
@@ -1910,17 +1772,9 @@ void AwesomePlayer::onVideoEvent() {
             if (!(mFlags & SLOW_DECODER_HACK)
                     || mSinceLastDropped > FRAME_DROP_FREQ)
             {
-#ifdef OMAP_ENHANCEMENT
-                if (mDebugFps != 0) {
-                    ALOGV("we're late by %lld us (%.2f secs) dropping "
-                        "one after %d frames",
-                        latenessUs, latenessUs / 1E6, mSinceLastDropped);
-                }
-#else
                 ALOGV("we're late by %lld us (%.2f secs) dropping "
                      "one after %d frames",
                      latenessUs, latenessUs / 1E6, mSinceLastDropped);
-#endif
 
                 mSinceLastDropped = 0;
                 mVideoBuffer->release();
@@ -1931,26 +1785,14 @@ void AwesomePlayer::onVideoEvent() {
                     ++mStats.mNumVideoFramesDropped;
                 }
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-                postVideoEvent_l(0);
-#else
                 postVideoEvent_l();
-#endif
                 return;
             }
         }
 
         if (latenessUs < -10000) {
             // We're more than 10ms early.
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-            if (-latenessUs > 100000) {
-                postVideoEvent_l(10000);
-            } else {
-                postVideoEvent_l(latenessUs * -1);
-            }
-#else
             postVideoEvent_l(10000);
-#endif
             return;
         }
     }
@@ -1975,11 +1817,7 @@ void AwesomePlayer::onVideoEvent() {
         return;
     }
 
-#if defined(OMAP_ENHANCEMENT) && defined(OMAP_TIME_INTERPOLATOR)
-    postVideoEvent_l(0);
-#else
     postVideoEvent_l();
-#endif
 }
 
 void AwesomePlayer::postVideoEvent_l(int64_t delayUs) {
@@ -2314,17 +2152,6 @@ status_t AwesomePlayer::finishSetDataSource_l() {
         checkDrmStatus(dataSource);
     }
 
-#ifdef OMAP_ENHANCEMENT
-    sp<MetaData> fileMetadata = extractor->getMetaData();
-    bool isAvailable = fileMetadata->findCString(kKeyMIMEType, &mExtractorType);
-    if(isAvailable) {
-        ALOGD("%s:: ExtractorType %s", __FUNCTION__,  mExtractorType);
-    } else {
-        ALOGE("%s:: ExtractorType not available", __FUNCTION__);
-    }
-    mExtractor = extractor;
-#endif
-
     status_t err = setDataSource_l(extractor);
 
     if (err != OK) {
diff --git a/./frameworks/av/media/libstagefright/CameraSource.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/CameraSource.cpp
index 2e0a424..3ddad93 100755
--- a/./frameworks/av/media/libstagefright/CameraSource.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/CameraSource.cpp
@@ -31,14 +31,6 @@
 #include <utils/String8.h>
 #include <cutils/properties.h>
 
-#ifdef OMAP_ENHANCEMENT
-#include <OMX_TI_IVCommon.h>
-#endif
-
-#ifdef OMAP_ENHANCEMENT_S3D
-#include <ui/S3DFormat.h>
-#endif
-
 namespace android {
 
 static const int64_t CAMERA_SOURCE_TIMEOUT_NS = 3000000000LL;
@@ -555,18 +547,6 @@ status_t CameraSource::initWithCameraAccess(
     mMeta->setInt32(kKeyStride,      mVideoSize.width);
     mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
     mMeta->setInt32(kKeyFrameRate,   mVideoFrameRate);
-
-#ifdef OMAP_ENHANCEMENT_S3D
-    const char * s3dLayout = params.get("s3d-prv-frame-layout");
-    if (s3dLayout != NULL) {
-        if (!strcmp("ss-full", s3dLayout) || !strcmp("ss-subsampled", s3dLayout)) {
-            mMeta->setInt32(kKeyS3DLayout, eSideBySide);
-        } else if (!strcmp("tb-full", s3dLayout) || !strcmp("tb-subsampled", s3dLayout)) {
-            mMeta->setInt32(kKeyS3DLayout, eTopBottom);
-        }
-    }
-#endif
-
     return OK;
 }
 
diff --git a/./frameworks/av/media/libstagefright/DataSource.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/DataSource.cpp
index b3948d7..c75f100 100644
--- a/./frameworks/av/media/libstagefright/DataSource.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/DataSource.cpp
@@ -33,11 +33,6 @@
 #include "include/AACExtractor.h"
 #include "include/WVMExtractor.h"
 
-#ifdef OMAP_ENHANCEMENT
-#include "include/ASFExtractor.h"
-#include "include/AVIExtractor.h"
-#endif
-
 #include "matroska/MatroskaExtractor.h"
 
 #include <media/stagefright/foundation/AMessage.h>
@@ -126,13 +121,6 @@ void DataSource::RegisterDefaultSniffers() {
     RegisterSniffer(SniffMPEG2PS);
     RegisterSniffer(SniffWVM);
 
-#ifdef OMAP_ENHANCEMENT
-    if(isASFParserAvailable()) {
-        RegisterSniffer(SniffASF);
-    }
-    RegisterSniffer(SniffAVI);
-#endif
-
     char value[PROPERTY_VALUE_MAX];
     if (property_get("drm.service.enabled", value, NULL)
             && (!strcmp(value, "1") || !strcasecmp(value, "true"))) {
diff --git a/./frameworks/av/media/libstagefright/MPEG4Extractor.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/MPEG4Extractor.cpp
index 99d02c6..a572541 100644
--- a/./frameworks/av/media/libstagefright/MPEG4Extractor.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/MPEG4Extractor.cpp
@@ -41,22 +41,8 @@
 #include <utils/String8.h>
 
 namespace android {
-#ifdef OMAP_ENHANCEMENT
-#define MP4_MPEG2VisualSimple  0x60
-#define MP4_MPEG2VisualMain    0x61
-#define MP4_MPEG2VisualSNR     0x62
-#define MP4_MPEG2VisualSpatial 0x63
-#define MP4_MPEG2VisualHigh    0x64
-#define MP4_MPEG2Visual422     0x65
-#define IS_MP4_MPEG2(x) (x < MP4_MPEG2VisualSimple) ? false : \
-                     (x > MP4_MPEG2Visual422)    ? false : true
-#endif
 
-#ifdef OMAP_ENHANCEMENT
-class MPEG4Source : public MediaSourceWithHaveDeltaTable {
-#else
 class MPEG4Source : public MediaSource {
-#endif
 public:
     // Caller retains ownership of both "dataSource" and "sampleTable".
     MPEG4Source(const sp<MetaData> &format,
@@ -101,13 +87,6 @@ private:
 
     MPEG4Source(const MPEG4Source &);
     MPEG4Source &operator=(const MPEG4Source &);
-
-#ifdef OMAP_ENHANCEMENT
-public:
-    bool haveDeltaTable() const {
-        return mSampleTable == NULL ? false : mSampleTable->haveDeltaTable();
-    }
-#endif
 };
 
 // This custom data source wraps an existing one and satisfies requests
@@ -266,10 +245,6 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('s', 'a', 'w', 'b'):
             return MEDIA_MIMETYPE_AUDIO_AMR_WB;
 
-#ifdef OMAP_ENHANCEMENT
-        case FOURCC('.', 'm', 'p', '3'):
-            return MEDIA_MIMETYPE_AUDIO_MPEG;
-#endif
         case FOURCC('m', 'p', '4', 'v'):
             return MEDIA_MIMETYPE_VIDEO_MPEG4;
 
@@ -278,11 +253,6 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('H', '2', '6', '3'):
             return MEDIA_MIMETYPE_VIDEO_H263;
 
-#ifdef OMAP_ENHANCEMENT
-        case FOURCC('M', 'P', 'G', '2'):
-        case FOURCC('m', 'p', 'g', '2'):
-            return MEDIA_MIMETYPE_VIDEO_MPEG2;
-#endif
         case FOURCC('a', 'v', 'c', '1'):
             return MEDIA_MIMETYPE_VIDEO_AVC;
 
@@ -406,31 +376,6 @@ status_t MPEG4Extractor::readMetaData() {
         if (mHasVideo) {
             mFileMetaData->setCString(
                     kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_MPEG4);
-#ifdef OMAP_ENHANCEMENT
-            Track *tempTrack = mFirstTrack;
-            int count = 0;
-            const char *mime;
-            while (tempTrack) {
-                CHECK(tempTrack->meta->findCString(kKeyMIMEType, &mime));
-                if (!strncasecmp("video/", mime, 6)) {
-                    size_t totalframes;
-                    int64_t duration;
-                    int32_t dur32, fps;
-                    fps = 0;
-                    totalframes = tempTrack->sampleTable->countSamples();
-                    tempTrack->meta->findInt64(kKeyDuration, &duration);
-                    dur32 = (int32_t) (duration / 1000000);
-                    if (dur32 <=0) {
-                        //dur32 will be zero for clips < 1 second.
-                        dur32 = 1;
-                    }
-                    fps = totalframes/dur32;
-                    ALOGV("totalframes %d duration %lld dur32 %d fps %d",totalframes,duration,dur32,fps);
-                    tempTrack->meta->setInt32(kKeyVideoFPS,fps);
-                }
-                tempTrack= tempTrack->next;
-            }
-#endif
         } else {
             mFileMetaData->setCString(kKeyMIMEType, "audio/mp4");
         }
@@ -676,17 +621,11 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             // The smallest valid chunk is 16 bytes long in this case.
             return ERROR_MALFORMED;
         }
-#ifdef OMAP_ENHANCEMENT
-    } else if ((chunk_size < 8) && (chunk_size != 0)) {
-        // The smallest valid chunk is 8 bytes long.
-        return ERROR_MALFORMED;
-    }
-#else
-    } else if (chunk_size < 8){
+    } else if (chunk_size < 8) {
         // The smallest valid chunk is 8 bytes long.
         return ERROR_MALFORMED;
     }
-#endif
+
     char chunk[5];
     MakeFourCCString(chunk_type, chunk);
     ALOGV("chunk: %s @ %lld", chunk, *offset);
@@ -731,27 +670,7 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         return OK;
     }
-#ifdef OMAP_ENHANCEMENT
-    {
-        union {
-            uint32_t chunk;
-            uint8_t t[4];
-        } chnk;
-        chnk.chunk=chunk_type;
-        ALOGV("Chunk: %c%c%c%c\n", chnk.t[3],chnk.t[2],chnk.t[1],chnk.t[0]);
-    }
-    // If the size of the atom is zero, then this is an empty atom that
-    //  needs to be skipped; the way to skip it is by making its size 4,
-    //  so the next time the instruction *offset += chunk_size happen
-    //  the atom be skipped and it doesn't cause the parser enter in
-    //  aninfinite loop.
-    //  (*offset would be pointing to the same place again and again if
-    //  chunk_size is zero)
-
-    if (!chunk_size) {
-        chunk_size=4;
-    }
-#endif
+
     switch(chunk_type) {
         case FOURCC('m', 'o', 'o', 'v'):
         case FOURCC('t', 'r', 'a', 'k'):
@@ -784,9 +703,6 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             }
 
             bool isTrack = false;
-#ifdef OMAP_ENHANCEMENT
-            Track *backupTrack = mLastTrack;
-#endif
             if (chunk_type == FOURCC('t', 'r', 'a', 'k')) {
                 isTrack = true;
 
@@ -841,16 +757,7 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 status_t err = verifyTrack(mLastTrack);
 
                 if (err != OK) {
-#ifdef OMAP_ENHANCEMENT
-                    //Patch to skip broken/empty track
-                    isTrack = false;
-                    mLastTrack = backupTrack;
-                    mLastTrack->next = NULL;
-                    err = OK;
-                    ALOGE("Found corrupted track descriptor");
-#else
                     return err;
-#endif
                 }
             } else if (chunk_type == FOURCC('m', 'o', 'o', 'v')) {
                 mInitCheck = OK;
@@ -1013,9 +920,6 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('m', 'p', '4', 'a'):
         case FOURCC('s', 'a', 'm', 'r'):
         case FOURCC('s', 'a', 'w', 'b'):
-#ifdef OMAP_ENHANCEMENT
-        case FOURCC('.', 'm', 'p', '3'):
-#endif
         {
             uint8_t buffer[8 + 20];
             if (chunk_data_size < (ssize_t)sizeof(buffer)) {
@@ -1057,14 +961,6 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
             off64_t stop_offset = *offset + chunk_size;
             *offset = data_offset + sizeof(buffer);
-#ifdef OMAP_ENHANCEMENT
-            if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_WB,
-                    FourCC2MIME(chunk_type)) ||
-                    !strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_NB,
-                    FourCC2MIME(chunk_type))) {
-                *offset = stop_offset;
-            }
-#endif
             while (*offset < stop_offset) {
                 status_t err = parseChunk(offset, depth + 1);
                 if (err != OK) {
@@ -1082,10 +978,6 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('s', '2', '6', '3'):
         case FOURCC('H', '2', '6', '3'):
         case FOURCC('h', '2', '6', '3'):
-#ifdef OMAP_ENHANCEMENT
-        case FOURCC('M', 'P', 'G', '2'):
-        case FOURCC('m', 'p', 'g', '2'):
-#endif
         case FOURCC('a', 'v', 'c', '1'):
         {
             mHasVideo = true;
@@ -1307,22 +1199,6 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             mLastTrack->meta->setData(
                     kKeyESDS, kTypeESDS, &buffer[4], chunk_data_size - 4);
 
-#ifdef OMAP_ENHANCEMENT
-            // For MP4V video tracks, check and update mime type, based on MPEG2/MPEG4 bitstream
-            const char *mime;
-            CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));
-            if (!strcmp(mime,MEDIA_MIMETYPE_VIDEO_MPEG4)) {
-                ESDS esds(&buffer[4], chunk_data_size - 4);
-                uint8_t objectTypeIndication;
-                if (OK == esds.getObjectTypeIndication(&objectTypeIndication)) {
-                    if (IS_MP4_MPEG2(objectTypeIndication)) {
-                        ALOGV("Mpeg2 Clip. Setting MIME type to MPEG2");
-                        mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_MPEG2);
-                    }
-                }
-            }
-#endif
-
             if (mPath.size() >= 2
                     && mPath[mPath.size() - 2] == FOURCC('m', 'p', '4', 'a')) {
                 // Information from the ESDS must be relied on for proper
@@ -1921,13 +1797,8 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         // The media subtype is MP3 audio
         // Our software MP3 audio decoder may not be able to handle
         // packetized MP3 audio; for now, lets just return ERROR_UNSUPPORTED
-#ifdef OMAP_ENHANCEMENT
-        mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
-        return OK;
-#else
         ALOGE("MP3 track in MP4/3GPP file is not supported");
         return ERROR_UNSUPPORTED;
-#endif
     }
 
     const uint8_t *csd;
@@ -2139,9 +2010,7 @@ status_t MPEG4Source::read(
 
     CHECK(mStarted);
 
-#ifndef OMAP_ENHANCEMENT
     *out = NULL;
-#endif
 
     int64_t targetSampleTimeUs = -1;
 
@@ -2231,12 +2100,7 @@ status_t MPEG4Source::read(
     uint32_t cts;
     bool isSyncSample;
     bool newBuffer = false;
-
-#ifdef OMAP_ENHANCEMENT
-    if (mBuffer == NULL || (*out && !mWantsNALFragments)) {
-#else
     if (mBuffer == NULL) {
-#endif
         newBuffer = true;
 
         status_t err =
@@ -2247,15 +2111,7 @@ status_t MPEG4Source::read(
             return err;
         }
 
-#ifdef OMAP_ENHANCEMENT
-        if (NULL == *out || mWantsNALFragments) {
-            err = mGroup->acquire_buffer(&mBuffer);
-        } else {
-            mBuffer = *out;
-        }
-#else
         err = mGroup->acquire_buffer(&mBuffer);
-#endif
 
         if (err != OK) {
             CHECK(mBuffer == NULL);
diff --git a/./frameworks/av/media/libstagefright/MediaDefs.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/MediaDefs.cpp
index 9dcf277..2740d6b 100644
--- a/./frameworks/av/media/libstagefright/MediaDefs.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/MediaDefs.cpp
@@ -41,14 +41,6 @@ const char *MEDIA_MIMETYPE_AUDIO_RAW = "audio/raw";
 const char *MEDIA_MIMETYPE_AUDIO_FLAC = "audio/flac";
 const char *MEDIA_MIMETYPE_AUDIO_AAC_ADTS = "audio/aac-adts";
 
-#ifdef OMAP_ENHANCEMENT
-const char *MEDIA_MIMETYPE_CONTAINER_ASF = "video/asf";
-const char *MEDIA_MIMETYPE_VIDEO_WMV  = "video/wmv9";
-const char *MEDIA_MIMETYPE_AUDIO_WMA = "audio/wma";
-const char *MEDIA_MIMETYPE_AUDIO_WMAPRO = "audio/wmapro";
-const char *MEDIA_MIMETYPE_AUDIO_WMALSL = "audio/wmalsl";
-#endif
-
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG4 = "video/mp4";
 const char *MEDIA_MIMETYPE_CONTAINER_WAV = "audio/wav";
 const char *MEDIA_MIMETYPE_CONTAINER_OGG = "application/ogg";
diff --git a/./frameworks/av/media/libstagefright/MediaExtractor.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/MediaExtractor.cpp
index 0eae445..9ab6611 100644
--- a/./frameworks/av/media/libstagefright/MediaExtractor.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/MediaExtractor.cpp
@@ -30,11 +30,6 @@
 #include "include/FLACExtractor.h"
 #include "include/AACExtractor.h"
 
-#ifdef OMAP_ENHANCEMENT
-#include "include/ASFExtractor.h"
-#include "include/AVIExtractor.h"
-#endif
-
 #include "matroska/MatroskaExtractor.h"
 
 #include <media/stagefright/foundation/AMessage.h>
@@ -123,18 +118,6 @@ sp<MediaExtractor> MediaExtractor::Create(
         ret = new MPEG2PSExtractor(source);
     }
 
-#ifdef OMAP_ENHANCEMENT
-    else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_AVI)) {
-        ret = new AVIExtractor(source);
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_ASF)) {
-        if(isASFParserAvailable())  {
-            return new ASFExtractor(source);
-        } else {
-            return NULL;
-        }
-    }
-#endif
-
     if (ret != NULL) {
        if (isDrm) {
            ret->setDrmFlag(true);
diff --git a/./frameworks/av/media/libstagefright/NuCachedSource2.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/NuCachedSource2.cpp
index d9f959f..f1075b1 100644
--- a/./frameworks/av/media/libstagefright/NuCachedSource2.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/NuCachedSource2.cpp
@@ -188,10 +188,6 @@ NuCachedSource2::NuCachedSource2(
       mCacheOffset(0),
       mFinalStatus(OK),
       mLastAccessPos(0),
-#ifdef OMAP_ENHANCEMENT
-      mMinAccessPos(0),
-      mMaxAccessPos(0),
-#endif
       mFetching(true),
       mLastFetchTimeUs(-1),
       mNumRetriesLeft(kMaxNumRetries),
@@ -366,14 +362,6 @@ void NuCachedSource2::onFetch() {
 
         mLastFetchTimeUs = ALooper::GetNowUs();
 
-#ifdef OMAP_ENHANCEMENT
-        if (mMinAccessPos - mCacheOffset > kGrayArea) {
-            size_t maxBytes = mMinAccessPos - mCacheOffset - kGrayArea;
-            size_t actualBytes = mCache->releaseFromStart(maxBytes);
-            mCacheOffset += actualBytes;
-        }
-#endif
-
         if (mFetching && mCache->totalSize() >= mHighwaterThresholdBytes) {
             ALOGI("Cache full, done prefetching for now");
             mFetching = false;
@@ -436,38 +424,18 @@ void NuCachedSource2::onRead(const sp<AMessage> &msg) {
 
 void NuCachedSource2::restartPrefetcherIfNecessary_l(
         bool ignoreLowWaterThreshold, bool force) {
-#ifndef OMAP_ENHANCEMENT
     static const size_t kGrayArea = 1024 * 1024;
-#endif
-
-#ifdef OMAP_ENHANCEMENT
-    if (mMinAccessPos - mCacheOffset > kGrayArea) {
-        size_t maxBytes = mMinAccessPos - mCacheOffset - kGrayArea;
-        size_t actualBytes = mCache->releaseFromStart(maxBytes);
-        mCacheOffset += actualBytes;
-    } else if (mCache->totalSize() >= mHighwaterThresholdBytes
-               && mCacheOffset + mCache->totalSize() - mMaxAccessPos < mLowwaterThresholdBytes) {
-        size_t maxBytes = mCache->totalSize() - mHighwaterThresholdBytes;
-        size_t actualBytes = mCache->releaseFromStart(maxBytes);
-        mCacheOffset += actualBytes;
-    }
-#endif
 
     if (mFetching || (mFinalStatus != OK && mNumRetriesLeft == 0)) {
         return;
     }
 
     if (!ignoreLowWaterThreshold && !force
-#ifdef OMAP_ENHANCEMENT
-            && mCacheOffset + mCache->totalSize() - mMaxAccessPos
-#else
             && mCacheOffset + mCache->totalSize() - mLastAccessPos
-#endif
                 >= mLowwaterThresholdBytes) {
         return;
     }
 
-#ifndef OMAP_ENHANCEMENT
     size_t maxBytes = mLastAccessPos - mCacheOffset;
 
     if (!force) {
@@ -480,7 +448,6 @@ void NuCachedSource2::restartPrefetcherIfNecessary_l(
 
     size_t actualBytes = mCache->releaseFromStart(maxBytes);
     mCacheOffset += actualBytes;
-#endif
 
     ALOGI("restarting prefetcher, totalSize = %d", mCache->totalSize());
     mFetching = true;
@@ -500,17 +467,7 @@ ssize_t NuCachedSource2::readAt(off64_t offset, void *data, size_t size) {
         size_t delta = offset - mCacheOffset;
         mCache->copy(delta, data, size);
 
-#ifdef OMAP_ENHANCEMENT
-        if(offset < mLastAccessPos) {
-            mMinAccessPos = offset;
-        }
-        if(offset + size > mMaxAccessPos) {
-            mMaxAccessPos = offset + size;
-        }
-        mLastAccessPos = offset;
-#else
         mLastAccessPos = offset + size;
-#endif
 
         return size;
     }
@@ -534,10 +491,6 @@ ssize_t NuCachedSource2::readAt(off64_t offset, void *data, size_t size) {
 
     if (result > 0) {
         mLastAccessPos = offset + result;
-#ifdef OMAP_ENHANCEMENT
-        mMinAccessPos = offset + result;
-        mMaxAccessPos = offset + result;
-#endif
     }
 
     return (ssize_t)result;
@@ -562,15 +515,9 @@ size_t NuCachedSource2::approxDataRemaining_l(status_t *finalStatus) const {
     }
 
     off64_t lastBytePosCached = mCacheOffset + mCache->totalSize();
-#ifdef OMAP_ENHANCEMENT
-    if (mMaxAccessPos < lastBytePosCached) {
-        return lastBytePosCached - mMaxAccessPos;
-    }
-#else
     if (mLastAccessPos < lastBytePosCached) {
         return lastBytePosCached - mLastAccessPos;
     }
-#endif
     return 0;
 }
 
@@ -583,10 +530,6 @@ ssize_t NuCachedSource2::readInternal(off64_t offset, void *data, size_t size) {
 
     if (!mFetching) {
         mLastAccessPos = offset;
-#ifdef OMAP_ENHANCEMENT
-        mMinAccessPos = offset;
-        mMaxAccessPos = offset;
-#endif
         restartPrefetcherIfNecessary_l(
                 false, // ignoreLowWaterThreshold
                 true); // force
@@ -636,10 +579,6 @@ ssize_t NuCachedSource2::readInternal(off64_t offset, void *data, size_t size) {
 
 status_t NuCachedSource2::seekInternal_l(off64_t offset) {
     mLastAccessPos = offset;
-#ifdef OMAP_ENHANCEMENT
-    mMinAccessPos = offset;
-    mMaxAccessPos = offset;
-#endif
 
     if (offset >= mCacheOffset
             && offset <= (off64_t)(mCacheOffset + mCache->totalSize())) {
diff --git a/./frameworks/av/media/libstagefright/OMXCodec.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/OMXCodec.cpp
index bd0a190..fde7ebf 100755
--- a/./frameworks/av/media/libstagefright/OMXCodec.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/OMXCodec.cpp
@@ -43,17 +43,6 @@
 #include <OMX_Component.h>
 
 #include "include/avc_utils.h"
-#ifdef OMAP_ENHANCEMENT
-#include <OMX_TI_Video.h>
-#include <OMX_TI_Index.h>
-#include <OMX_TI_IVCommon.h>
-#include <ctype.h>
-#endif
-
-#ifdef OMAP_ENHANCEMENT_S3D
-#include <OMX_TI_Common.h>
-#include <ui/S3DFormat.h>
-#endif
 
 namespace android {
 
@@ -68,12 +57,6 @@ const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
 // component in question is buggy or not.
 const static uint32_t kMaxColorFormatSupported = 1000;
 
-#ifdef OMAP_ENHANCEMENT_S3D
-// OMX TI specific extra data types
-const static uint32_t OMX_TI_SEIinfo2010Frame1 = 0x7F000015;
-const static uint32_t OMX_TI_SEIinfo2010Frame2 = 0x7F000016;
-#endif
-
 #define FACTORY_CREATE_ENCODER(name) \
 static sp<MediaSource> Make##name(const sp<MediaSource> &source, const sp<MetaData> &meta) { \
     return new name(source, meta); \
@@ -268,17 +251,6 @@ uint32_t OMXCodec::getComponentQuirks(
         quirks |= kOutputBuffersAreUnreadable;
     }
 
-#ifdef OMAP_ENHANCEMENT
-    if (list->codecHasQuirk(
-                index, "needs-flush-before-disable")) {
-        quirks |= kNeedsFlushBeforeDisable;
-    }
-    if (list->codecHasQuirk(
-                index, "requires-flush-complete-emulation")) {
-        quirks |= kRequiresFlushCompleteEmulation;
-    }
-#endif
-
     return quirks;
 }
 
@@ -522,49 +494,6 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             CHECK(meta->findData(kKeyVorbisBooks, &type, &data, &size));
             addCodecSpecificData(data, size);
         }
-#ifdef OMAP_ENHANCEMENT
-        else if (meta->findData(kKeyHdr, &type, &data, &size)) {
-            CODEC_LOGV("Codec specific information of size %d", size);
-            addCodecSpecificData(data, size);
-        }
-
-        if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mMIME)) {
-            //Set the profile (RCV or VC1)
-            meta->findData(kKeyHdr, &type, &data, &size);
-            const uint8_t *ptr = (const uint8_t *)data;
-
-            OMX_U32 width = (((OMX_U32)ptr[18] << 24) | ((OMX_U32)ptr[17] << 16) | ((OMX_U32)ptr[16] << 8) | (OMX_U32)ptr[15]);
-            OMX_U32 height  = (((OMX_U32)ptr[22] << 24) | ((OMX_U32)ptr[21] << 16) | ((OMX_U32)ptr[20] << 8) | (OMX_U32)ptr[19]);
-
-            CODEC_LOGV("Height and width = %u %u\n", height, width);
-
-        }
-
-        if(mFlags & kEnableTimeStampInDecodeOrder) {
-            /* For WMV, AVI clips no CTTS structure available to support b-frames.
-             * Hecne request codec to order frames as per decode order  */
-
-            OMX_INDEXTYPE index;
-            status_t err = mOMX->getExtensionIndex(
-                        mNode,
-                        (OMX_STRING) "OMX_TI_IndexParamTimeStampInDecodeOrder",
-                        &index);
-
-            CODEC_LOGV("for %s clip, got OMX_TI_IndexParamTimeStampInDecodeOrder \
-                index as 0x%x err 0x%x",mMIME, index, err);
-
-            if (err == OK) {
-                OMX_TI_PARAM_TIMESTAMP_IN_DECODE_ORDER params;
-                InitOMXParams(&params);
-                params.bEnabled = OMX_TRUE;
-                err = mOMX->setParameter(
-                                mNode, index, &params, sizeof(params));
-                CODEC_LOGV("OMX_SetParameter() status for  \
-                    OMX_TI_PARAM_TIMESTAMP_IN_DECODE_ORDER: 0x%08x", err);
-            }
-        }
-
-#endif
     }
 
     int32_t bitRate = 0;
@@ -622,14 +551,6 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             bool success = meta->findInt32(kKeyWidth, &width);
             success = success && meta->findInt32(kKeyHeight, &height);
             CHECK(success);
-#ifdef OMAP_ENHANCEMENT
-            if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")) {
-                /* save video FPS */
-                if (!(meta->findInt32(kKeyVideoFPS, &mVideoFPS))) {
-                    mVideoFPS = 30; //default value in case of FPS data not found
-                }
-            }
-#endif
             status_t err = setVideoOutputFormat(
                     mMIME, width, height);
 
@@ -641,16 +562,7 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
 
     int32_t maxInputSize;
     if (meta->findInt32(kKeyMaxInputSize, &maxInputSize)) {
-#ifdef OMAP_ENHANCEMENT
-        if(!strcmp("OMX.TI.DUCATI1.VIDEO.DECODER", mComponentName)) {
-            mInputMinBufferSize = maxInputSize;
-            ALOGE("set buffer size variable to : %d",maxInputSize);
-        } else {
-#endif
         setMinBufferSize(kPortIndexInput, (OMX_U32)maxInputSize);
-#ifdef OMAP_ENHANCEMENT
-        }
-#endif
     }
 
     initOutputFormat(meta);
@@ -882,12 +794,6 @@ void OMXCodec::setVideoInputFormat(
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
         compressionFormat = OMX_VIDEO_CodingH263;
-#ifdef OMAP_ENHANCEMENT
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)) {
-        compressionFormat = OMX_VIDEO_CodingWMV;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
-        compressionFormat = OMX_VIDEO_CodingMPEG2;
-#endif
     } else {
         ALOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
@@ -1114,13 +1020,6 @@ status_t OMXCodec::setupH263EncoderParameters(const sp<MetaData>& meta) {
     }
     h263type.nBFrames = 0;
 
-#ifdef OMAP_ENAHNCEMENT
-    //When flag kOnlySubmitOneInputBufferAtOneTime is enabled, B frames must not be used.
-    if (mFlags & kOnlySubmitOneInputBufferAtOneTime) {
-        h263type.nBFrames = 0;
-    }
-#endif
-
     // Check profile and level parameters
     CodecProfileLevel defaultProfileLevel, profileLevel;
     defaultProfileLevel.mProfile = h263type.eProfile;
@@ -1178,13 +1077,6 @@ status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
     mpeg4type.nHeaderExtension = 0;
     mpeg4type.bReversibleVLC = OMX_FALSE;
 
-#ifdef OMAP_ENHANCEMENT
-    //When flag kOnlySubmitOneInputBufferAtOneTime is enabled, B frames must not be used.
-    if (mFlags & kOnlySubmitOneInputBufferAtOneTime) {
-        mpeg4type.nBFrames = 0;
-    }
-#endif
-
     // Check profile and level parameters
     CodecProfileLevel defaultProfileLevel, profileLevel;
     defaultProfileLevel.mProfile = mpeg4type.eProfile;
@@ -1232,12 +1124,7 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
     h264type.eLevel = static_cast<OMX_VIDEO_AVCLEVELTYPE>(profileLevel.mLevel);
 
     // XXX
-#ifdef OMAP_ENHANCEMENT
-    if ((strncmp(mComponentName, "OMX.TI.DUCATI1", 14) != 0)
-            && (h264type.eProfile != OMX_VIDEO_AVCProfileBaseline)) {
-#else
     if (h264type.eProfile != OMX_VIDEO_AVCProfileBaseline) {
-#endif
         ALOGW("Use baseline profile instead of %d for AVC recording",
             h264type.eProfile);
         h264type.eProfile = OMX_VIDEO_AVCProfileBaseline;
@@ -1262,13 +1149,6 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
         h264type.nCabacInitIdc = 0;
     }
 
-#ifdef OMAP_ENHANCEMENT
-    //When flag kOnlySubmitOneInputBufferAtOneTime is enabled, B frames must not be used.
-    if (mFlags & kOnlySubmitOneInputBufferAtOneTime) {
-        h264type.nBFrames = 0;
-    }
-#endif
-
     if (h264type.nBFrames != 0) {
         h264type.nAllowedPictureTypes |= OMX_VIDEO_PictureTypeB;
     }
@@ -1287,62 +1167,9 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
 
     CHECK_EQ(setupBitRate(bitRate), (status_t)OK);
 
-#ifdef OMAP_ENHANCEMENT_S3D
-    int32_t s3dLayout;
-    if (meta->findInt32(kKeyS3DLayout, &s3dLayout)) {
-        setupAVCEncoderS3DParameters(s3dLayout);
-    }
-#endif
-
     return OK;
 }
 
-#ifdef OMAP_ENHANCEMENT_S3D
-void OMXCodec::setupAVCEncoderS3DParameters(int32_t s3dLayout) {
-
-    if ((s3dLayout != eSideBySide) && (s3dLayout != eTopBottom)) {
-        CODEC_LOGE("Invalid s3d layout");
-        return;
-    }
-
-    OMX_TI_VIDEO_PARAM_FRAMEDATACONTENTTYPE fdc;
-    OMX_TI_VIDEO_PARAM_AVCENC_FRAMEPACKINGINFO2010 fpi;
-
-    InitOMXParams(&fdc);
-    fdc.nPortIndex = kPortIndexInput;
-    fdc.eContentType = OMX_TI_Video_AVC_2010_StereoFramePackingType;
-
-    InitOMXParams(&fpi);
-    fpi.nPortIndex = kPortIndexInput;
-    fpi.nFrame0PositionX = 0;
-    fpi.nFrame0PositionY = 0;
-    fpi.nFrame1PositionX = 0;
-    fpi.nFrame1PositionY = 0;
-
-    if (s3dLayout == eSideBySide) {
-        fpi.eFramePackingType = OMX_TI_Video_FRAMEPACK_SIDE_BY_SIDE;
-    } else {
-        fpi.eFramePackingType = OMX_TI_Video_FRAMEPACK_TOP_BOTTOM;
-    }
-
-    status_t err = mOMX->setParameter(
-            mNode,
-            (OMX_INDEXTYPE)OMX_TI_IndexParamVideoFrameDataContentSettings,
-            &fdc, sizeof(fdc));
-
-    if (err == OK) {
-        err = mOMX->setParameter(
-                mNode,
-                (OMX_INDEXTYPE)OMX_TI_IndexParamStereoFramePacking2010Settings,
-                &fpi, sizeof(fpi));
-    }
-
-    if (err) {
-        CODEC_LOGE("could not configure S3D encoding parameters (0x%x)", err);
-    }
-}
-#endif
-
 status_t OMXCodec::setVideoOutputFormat(
         const char *mime, OMX_U32 width, OMX_U32 height) {
     CODEC_LOGV("setVideoOutputFormat width=%ld, height=%ld", width, height);
@@ -1358,10 +1185,6 @@ status_t OMXCodec::setVideoOutputFormat(
         compressionFormat = OMX_VIDEO_CodingVPX;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG2;
-#ifdef OMAP_ENHANCEMENT
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV , mime)) {
-        compressionFormat = OMX_VIDEO_CodingWMV;
-#endif
     } else {
         ALOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
@@ -1454,9 +1277,6 @@ status_t OMXCodec::setVideoOutputFormat(
 
     video_def->nFrameWidth = width;
     video_def->nFrameHeight = height;
-#ifdef OMAP_ENHANCEMENT
-    video_def->xFramerate = mVideoFPS << 16;
-#endif
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
@@ -1495,9 +1315,6 @@ OMXCodec::OMXCodec(
       mSkipCutBuffer(NULL),
       mLeftOverBuffer(NULL),
       mPaused(false),
-#ifdef OMAP_ENHANCEMENT
-      mInputMinBufferSize(0),
-#endif
       mNativeWindow(
               (!strncmp(componentName, "OMX.google.", 11)
               || !strcmp(componentName, "OMX.Nvidia.mpeg2v.decode"))
@@ -1543,18 +1360,6 @@ void OMXCodec::setComponentRole(
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
-#ifdef OMAP_ENHANCEMENT
-        { MEDIA_MIMETYPE_VIDEO_WMV,
-            "video_decoder.wmv", "" },
-        { MEDIA_MIMETYPE_AUDIO_WMA,
-            "audio_decoder.wma", "" },
-        { MEDIA_MIMETYPE_AUDIO_WMAPRO,
-            "audio_decoder.wmapro", "" },
-        { MEDIA_MIMETYPE_AUDIO_WMALSL,
-            "audio_decoder.wmalsl", "" },
-        { MEDIA_MIMETYPE_VIDEO_MPEG2,
-            "video_decoder.mpeg2", NULL },
-#endif
         { MEDIA_MIMETYPE_VIDEO_VPX,
             "video_decoder.vpx", "video_encoder.vpx" },
         { MEDIA_MIMETYPE_AUDIO_RAW,
@@ -1705,14 +1510,6 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         return err;
     }
 
-#ifdef OMAP_ENHANCEMENT
-    if( (!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")) &&
-        (portIndex == kPortIndexInput) &&
-        (def.nBufferSize < mInputMinBufferSize)) {
-        ALOGI("!! Change the I/P buffer size to %d !!", mInputMinBufferSize);
-        def.nBufferSize = mInputMinBufferSize;
-    }
-#endif
     CODEC_LOGV("allocating %lu buffers of size %lu on %s port",
             def.nBufferCountActual, def.nBufferSize,
             portIndex == kPortIndexInput ? "input" : "output");
@@ -2250,64 +2047,10 @@ int64_t OMXCodec::getDecodingTimeUs() {
     return timeUs;
 }
 
-#ifdef OMAP_ENHANCEMENT_S3D
-void OMXCodec::handle_extradata(void *data)
-{
-    if (mNativeWindow == NULL || data == NULL) {
-        return;
-    }
-
-    OMX_TI_PLATFORMPRIVATE *pPrivate = (OMX_TI_PLATFORMPRIVATE *)data;
-    if (pPrivate->pMetaDataBuffer == NULL) {
-        return;
-    }
-
-    OMX_OTHER_EXTRADATATYPE *pExtraData;
-    OMX_U8 *pData = (OMX_U8 *)pPrivate->pMetaDataBuffer;
-    unsigned int offset = 0;
-    do {
-        pExtraData = ( OMX_OTHER_EXTRADATATYPE *)(pData+offset);
-        offset += pExtraData->nSize;
-        if (offset > pPrivate->nMetaDataSize) {
-            break;
-        }
-        uint32_t layout = 0;
-        switch((int)pExtraData->eType) {
-            case OMX_TI_SEIinfo2010Frame1:
-            case OMX_TI_SEIinfo2010Frame2:
-                OMX_TI_FRAMEPACKINGDECINFO *pFramePacking;
-                pFramePacking = (OMX_TI_FRAMEPACKINGDECINFO *)pExtraData->data;
-                if (pFramePacking->nFramePackingArrangementType == OMX_TI_Video_FRAMEPACK_SIDE_BY_SIDE) {
-                    layout = eSideBySide << 16;
-                } else if (pFramePacking->nFramePackingArrangementType == OMX_TI_Video_FRAMEPACK_TOP_BOTTOM) {
-                    layout = eTopBottom << 16;
-                }
-
-                if (pFramePacking->nContentInterpretationType) {
-                    layout |= eLeftViewFirst << 24;
-                } else {
-                    layout |= eRightViewFirst << 24;
-                }
-
-                if (layout) {
-                    native_window_set_buffers_layout(mNativeWindow.get(), layout);
-                }
-                break;
-        }
-    } while((offset + sizeof(OMX_OTHER_EXTRADATATYPE) - 1) <= pPrivate->nMetaDataSize &&
-             pExtraData && pExtraData->eType != 0);
-}
-#endif
-
 void OMXCodec::on_message(const omx_message &msg) {
     if (mState == ERROR) {
-#ifdef OMAP_ENHANCEMENT
-        /* Dropping buffers return from client will cause problem in freeing so process them */
-        ALOGW("Dropping OMX message - we're in ERROR state. msg.type: %d",msg.type);
-#else
         ALOGW("Dropping OMX message - we're in ERROR state.");
         return;
-#endif
     }
 
     switch (msg.type) {
@@ -2462,15 +2205,6 @@ void OMXCodec::on_message(const omx_message &msg) {
                     isCodecSpecific = true;
                 }
 
-#ifdef OMAP_ENHANCEMENT_S3D
-                if ((msg.u.extended_buffer_data.flags & OMX_TI_BUFFERFLAG_DETACHEDEXTRADATA) &&
-                    !(mFlags & kEnableGrallocUsageProtected) &&
-                    !(msg.u.extended_buffer_data.flags & OMX_BUFFERFLAG_EOS) &&
-                    !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER") &&
-                    mOMXLivesLocally) {
-                    handle_extradata(msg.u.extended_buffer_data.platform_private);
-                }
-#endif
                 if (isGraphicBuffer || mQuirks & kOutputBuffersAreUnreadable) {
                     buffer->meta_data()->setInt32(kKeyIsUnreadable, true);
                 }
@@ -2622,13 +2356,8 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
         case OMX_EventError:
         {
             CODEC_LOGE("ERROR(0x%08lx, %ld)", data1, data2);
-#ifdef OMAP_ENHANCEMENT
-            if (!isIntermediateState(mState)) {
-                setState(ERROR);
-            }
-#else
+
             setState(ERROR);
-#endif
             break;
         }
 
@@ -2647,9 +2376,6 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
                 onPortSettingsChanged(data1);
             } else if (data1 == kPortIndexOutput &&
                         (data2 == OMX_IndexConfigCommonOutputCrop ||
-#ifdef OMAP_ENHANCEMENT
-                         data2 == OMX_TI_IndexConfigStreamInterlaceFormats ||
-#endif
                          data2 == OMX_IndexConfigCommonScale)) {
 
                 sp<MetaData> oldOutputFormat = mOutputFormat;
@@ -3270,13 +2996,6 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     for (;;) {
         MediaBuffer *srcBuffer;
-#ifdef OMAP_ENHANCEMENT
-        MediaBuffer *tmpBuffer = NULL;
-        if (!mIsEncoder && !(mFlags & kUseSecureInputBuffers)) {
-            srcBuffer = new MediaBuffer(info->mData, info->mSize);
-            tmpBuffer = srcBuffer;
-        }
-#endif
         if (mSeekTimeUs >= 0) {
             if (mLeftOverBuffer) {
                 mLeftOverBuffer->release();
@@ -3374,23 +3093,10 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
                 info->mMediaBuffer = srcBuffer;
             } else {
                 CHECK(srcBuffer->data() != NULL) ;
-
-#ifndef OMAP_ENHANCEMENT
-            memcpy((uint8_t *)info->mData + offset,
-                 (const uint8_t *)srcBuffer->data()
-                    + srcBuffer->range_offset(),
-                    srcBuffer->range_length());
-#else
-            if (tmpBuffer != srcBuffer) {
                 memcpy((uint8_t *)info->mData + offset,
-                     (const uint8_t *)srcBuffer->data()
-                    + srcBuffer->range_offset(),
-                     srcBuffer->range_length());
-                if (tmpBuffer) {
-                    tmpBuffer->release();
-                }
-            }
-#endif
+                        (const uint8_t *)srcBuffer->data()
+                            + srcBuffer->range_offset(),
+                        srcBuffer->range_length());
             }
         }
 
@@ -3898,11 +3604,7 @@ void OMXCodec::addCodecSpecificData(const void *data, size_t size) {
 
     specific->mSize = size;
     memcpy(specific->mData, data, size);
-#ifdef OMAP_ENHANCEMENT
-    if (!size) {
-        return;
-    }
-#endif
+
     mCodecSpecificData.push(specific);
 }
 
@@ -4725,13 +4427,6 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
             } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingAVC) {
                 mOutputFormat->setCString(
                         kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
-#ifdef OMAP_ENHANCEMENT
-            } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingWMV) {
-                mOutputFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_WMV);
-            } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingMPEG2) {
-                mOutputFormat->setCString(
-                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_MPEG2);
-#endif
             } else {
                 CHECK(!"Unknown compression format.");
             }
@@ -4779,58 +4474,8 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                             video_def->nFrameHeight - 1);
                 }
 
-#ifdef OMAP_ENHANCEMENT
-                // Get Scaling Values and intialise mOutputFormat.
-                OMX_CONFIG_SCALEFACTORTYPE scale;
-                InitOMXParams(&scale);
-                scale.nPortIndex = kPortIndexOutput;
-                if (OK == mOMX->getConfig(
-                        mNode,OMX_IndexConfigCommonScale,
-                        &scale, sizeof(scale))) {
-                    int32_t left, top, right, bottom;
-                    CHECK(mOutputFormat->findRect(kKeyCropRect,
-                            &left, &top,
-                            &right, &bottom));
-
-                    // The scale is in 16.16 format.
-                    // scale 1.0 = 0x010000. When there is no
-                    // need to change the display, skip it.
-                    ALOGV("Get OMX_IndexConfigScale: 0x%lx/0x%lx",
-                            scale.xWidth, scale.xHeight);
-
-                    if (scale.xWidth != 0x010000) {
-                        mOutputFormat->setInt32(kKeyDisplayWidth,
-                                ((right - left +  1) * scale.xWidth)  >> 16);
-                        mOutputPortSettingsHaveChanged = true;
-                    }
-
-                    if (scale.xHeight != 0x010000) {
-                        mOutputFormat->setInt32(kKeyDisplayHeight,
-                                ((bottom  - top + 1) * scale.xHeight) >> 16);
-                        mOutputPortSettingsHaveChanged = true;
-                    }
-                }
-
-                OMX_TI_STREAMINTERLACEFORMAT buff_layout;
-                InitOMXParams(&buff_layout);
-                buff_layout.nPortIndex = kPortIndexOutput;
-                uint32_t layout = OMX_InterlaceFrameProgressive;
-                if (OK == mOMX->getConfig(
-                        mNode,
-                        static_cast<OMX_INDEXTYPE>(OMX_TI_IndexConfigStreamInterlaceFormats),
-                        &buff_layout, sizeof(buff_layout))) {
-                    layout = buff_layout.bInterlaceFormat ?
-                             buff_layout.nInterlaceFormats & OMX_InterlaceFmtMask :
-                             layout;
-                }
-                mOutputFormat->setInt32(kKeyBufferLayout, layout);
-#endif
-
                 if (mNativeWindow != NULL) {
                      initNativeWindowCrop();
-#ifdef OMAP_ENHANCEMENT
-                     native_window_set_buffers_layout(mNativeWindow.get(), layout);
-#endif
                 }
             }
             break;
@@ -5034,168 +4679,4 @@ status_t getOMXChannelMapping(size_t numChannels, OMX_AUDIO_CHANNELTYPE map[]) {
     return OK;
 }
 
-#ifdef OMAP_ENHANCEMENT
-
-// Attempt to parse an int64 literal optionally surrounded by whitespace,
-// returns true on success, false otherwise.
-static bool safe_strtoi64(const char *s, int64_t *val) {
-    char *end;
-
-    // It is lame, but according to man page, we have to set errno to 0
-    // before calling strtoll().
-    errno = 0;
-    *val = strtoll(s, &end, 10);
-
-    if (end == s || errno == ERANGE) {
-        return false;
-    }
-
-    // Skip trailing whitespace
-    while (isspace(*end)) {
-        ++end;
-    }
-
-    // For a successful return, the string must contain nothing but a valid
-    // int64 literal optionally surrounded by whitespace.
-
-    return *end == '\0';
-}
-
-// Return true if the value is in [0, 0x007FFFFFFF]
-static bool safe_strtoi32(const char *s, int32_t *val) {
-    int64_t temp;
-    if (safe_strtoi64(s, &temp)) {
-        if (temp >= 0 && temp <= 0x007FFFFFFF) {
-            *val = static_cast<int32_t>(temp);
-            return true;
-        }
-    }
-    return false;
-}
-
-status_t OMXCodec::setParameter(const String8 &key, const String8 &value){
-
-    if (key == "video-param-insert-i-frame") {
-        ALOGV("setParamInsertVideoIFrame");
-        OMX_CONFIG_INTRAREFRESHVOPTYPE voptype;
-        InitOMXParams(&voptype);
-        voptype.nPortIndex = 1;
-
-        status_t err = mOMX->getConfig(
-                mNode, OMX_IndexConfigVideoIntraVOPRefresh, &voptype, sizeof(voptype));
-        if (err != OK) {
-            return BAD_VALUE;
-        }
-
-        voptype.IntraRefreshVOP = OMX_TRUE;
-        err = mOMX->setConfig(
-                mNode, OMX_IndexConfigVideoIntraVOPRefresh, &voptype, sizeof(voptype));
-        if (err != OK) {
-            return BAD_VALUE;
-        }
-
-        return OK;
-    }
-    else if (key == "video-param-nalsize-bytes") {
-        int32_t bytes;
-        if (safe_strtoi32(value.string(), &bytes)) {
-            ALOGV("setParamMaxNalSize:: bytes: %d", bytes);
-            OMX_VIDEO_CONFIG_SLICECODINGTYPE slicetype;
-            InitOMXParams(&slicetype);
-            slicetype.nPortIndex = 1;
-
-            status_t err = mOMX->getConfig(
-                    mNode, (OMX_INDEXTYPE)OMX_TI_IndexConfigSliceSettings, &slicetype, sizeof(slicetype));
-            if (err != OK) {
-                return BAD_VALUE;
-            }
-
-            slicetype.eSliceMode = OMX_VIDEO_SLICEMODE_AVCByteSlice;
-            slicetype.nSlicesize = bytes;
-
-            err = mOMX->setConfig(
-                    mNode, (OMX_INDEXTYPE)OMX_TI_IndexConfigSliceSettings, &slicetype, sizeof(slicetype));
-            if (err != OK) {
-                return BAD_VALUE;
-            }
-            return OK;
-        }
-    }
-    else if (key == "video-param-nalsize-macroblocks") {
-        int32_t mb;
-        if (safe_strtoi32(value.string(), &mb)) {
-            ALOGV("setParamMaxNalSize:: MB: %d", mb);
-            OMX_VIDEO_CONFIG_SLICECODINGTYPE slicetype;
-            InitOMXParams(&slicetype);
-            slicetype.nPortIndex = 1;
-
-            status_t err = mOMX->getConfig(
-                    mNode, (OMX_INDEXTYPE)OMX_TI_IndexConfigSliceSettings, &slicetype, sizeof(slicetype));
-            if (err != OK) {
-                return BAD_VALUE;
-            }
-
-            slicetype.eSliceMode = OMX_VIDEO_SLICEMODE_AVCMBSlice;
-            slicetype.nSlicesize = mb;
-
-            err = mOMX->setConfig(
-                    mNode, (OMX_INDEXTYPE)OMX_TI_IndexConfigSliceSettings, &slicetype, sizeof(slicetype));
-            if (err != OK) {
-                return BAD_VALUE;
-            }
-            return OK;
-        }
-    }
-    else if (key == "video-config-encoding-bitrate") {
-        int32_t bitRate;
-        if (safe_strtoi32(value.string(), &bitRate)) {
-
-            ALOGV("setConfigVideoBitRate: %d", bitRate);
-            OMX_VIDEO_CONFIG_BITRATETYPE bitrateType;
-            InitOMXParams(&bitrateType);
-            bitrateType.nPortIndex = 1;
-
-            status_t err = mOMX->getConfig(
-                    mNode, OMX_IndexConfigVideoBitrate,
-                    &bitrateType, sizeof(bitrateType));
-            if (err != OK) {
-                return BAD_VALUE;
-            }
-
-            bitrateType.nEncodeBitrate = bitRate;
-            err = mOMX->setConfig(mNode, OMX_IndexConfigVideoBitrate, &bitrateType, sizeof(bitrateType));
-            if (err != OK) {
-                return BAD_VALUE;
-            }
-            return OK;
-        }
-    }
-    else if (key == "video-config-encoding-framerate") {
-        int32_t frameRate;
-        if (safe_strtoi32(value.string(), &frameRate)) {
-
-            ALOGV("setConfigVideoFrameRate: %d", frameRate);
-            OMX_CONFIG_FRAMERATETYPE framerateType;
-            InitOMXParams(&framerateType);
-            framerateType.nPortIndex = 0;
-
-            status_t err = mOMX->getConfig(
-                    mNode, OMX_IndexConfigVideoFramerate,
-                    &framerateType, sizeof(framerateType));
-            if (err != OK) {
-                return BAD_VALUE;
-            }
-
-            framerateType.xEncodeFramerate = frameRate << 16;
-            err = mOMX->setConfig(mNode, OMX_IndexConfigVideoFramerate, &framerateType, sizeof(framerateType));
-            if (err != OK) {
-                return BAD_VALUE;
-            }
-            return OK;
-        }
-    }
-    return BAD_VALUE;
-}
-#endif
-
 }  // namespace android
diff --git a/./frameworks/av/media/libstagefright/SampleTable.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/SampleTable.cpp
index c77abc9..d9858d7 100644
--- a/./frameworks/av/media/libstagefright/SampleTable.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/SampleTable.cpp
@@ -58,11 +58,6 @@ private:
     size_t mCurrentEntrySampleIndex;
 
     DISALLOW_EVIL_CONSTRUCTORS(CompositionDeltaLookup);
-
-#ifdef OMAP_ENHANCEMENT
-public:
-    bool haveEntries() const { return (mNumDeltaEntries > 0); };
-#endif
 };
 
 SampleTable::CompositionDeltaLookup::CompositionDeltaLookup()
@@ -832,11 +827,5 @@ uint32_t SampleTable::getCompositionTimeOffset(uint32_t sampleIndex) {
     return mCompositionDeltaLookup->getCompositionTimeOffset(sampleIndex);
 }
 
-#ifdef OMAP_ENHANCEMENT
-bool SampleTable::haveDeltaTable() const {
-    return mCompositionDeltaLookup == NULL ? false : mCompositionDeltaLookup->haveEntries();
-}
-#endif
-
 }  // namespace android
 
diff --git a/./frameworks/av/media/libstagefright/StagefrightMediaScanner.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/StagefrightMediaScanner.cpp
index 2d5297e..b7cf96e 100644
--- a/./frameworks/av/media/libstagefright/StagefrightMediaScanner.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/StagefrightMediaScanner.cpp
@@ -43,9 +43,6 @@ static bool FileHasAcceptableExtension(const char *extension) {
         ".wav", ".amr", ".midi", ".xmf", ".rtttl", ".rtx", ".ota",
         ".mkv", ".mka", ".webm", ".ts", ".fl", ".flac", ".mxmf",
         ".avi", ".mpeg", ".mpg"
-#ifdef OMAP_ENHANCEMENT
-        , ".wmv", ".asf",
-#endif
     };
     static const size_t kNumValidExtensions =
         sizeof(kValidExtensions) / sizeof(kValidExtensions[0]);
diff --git a/./frameworks/av/media/libstagefright/StagefrightMetadataRetriever.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/StagefrightMetadataRetriever.cpp
index 798f1b1..7951496 100644
--- a/./frameworks/av/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -252,49 +252,6 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
             (OMX_COLOR_FORMATTYPE)srcFormat, OMX_COLOR_Format16bitRGB565);
 
     if (converter.isValid()) {
-
-#ifdef OMAP_ENHANCEMENT
-    int32_t buff_layout;
-    CHECK(meta->findInt32(kKeyBufferLayout, &buff_layout));
-
-    if ((OMX_TI_INTERLACETYPE)buff_layout != OMX_InterlaceFrameProgressive) {
-        if (((OMX_TI_INTERLACETYPE)buff_layout != OMX_InterlaceInterleaveFrameTopFieldFirst) &&
-            ((OMX_TI_INTERLACETYPE)buff_layout != OMX_InterlaceInterleaveFrameBottomFieldFirst)) {
-            /* incase of top/bottom fields separated, the crop
-            * values are communicated for field, not the entire frame
-            */
-            if (frame->mData) {
-                delete frame->mData;
-            }
-            frame->mWidth = crop_right - crop_left + 1;
-            frame->mHeight = (crop_bottom - crop_top + 1) * 2; //two fields
-            frame->mDisplayWidth = frame->mWidth;
-            frame->mDisplayHeight = frame->mHeight;
-            frame->mSize = frame->mWidth * frame->mHeight * 2;
-            frame->mData = new uint8_t[frame->mSize];
-            frame->mRotationAngle = rotationAngle;
-        }
-
-        err = converter.convertInterlacedBuffer(
-            (const uint8_t *)buffer->data() + buffer->range_offset(),
-            width, height,
-            crop_left, crop_top, crop_right, crop_bottom,
-            (OMX_TI_INTERLACETYPE)buff_layout,
-            frame->mData,
-            frame->mWidth,
-            frame->mHeight,
-            0, 0, frame->mWidth - 1, frame->mHeight - 1);
-    } else {
-        err = converter.convert(
-            (const uint8_t *)buffer->data() + buffer->range_offset(),
-            width, height,
-            crop_left, crop_top, crop_right, crop_bottom,
-            frame->mData,
-            frame->mWidth,
-            frame->mHeight,
-            0, 0, frame->mWidth - 1, frame->mHeight - 1);
-    }
-#else
         err = converter.convert(
                 (const uint8_t *)buffer->data() + buffer->range_offset(),
                 width, height,
@@ -303,7 +260,6 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
                 frame->mWidth,
                 frame->mHeight,
                 0, 0, frame->mWidth - 1, frame->mHeight - 1);
-#endif
     } else {
         ALOGE("Unable to instantiate color conversion from format 0x%08x to "
               "RGB565",
@@ -389,38 +345,6 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
         memcpy(mAlbumArt->mData, data, dataSize);
     }
 
-#ifdef OMAP_ENHANCEMENT
-    const char *filemime;
-    CHECK(fileMeta->findCString(kKeyMIMEType, &filemime));
-    ALOGV("file mime type:%s", filemime);
-    VideoFrame *frame = NULL;
-    bool useHWCodec = 0;
-
-    /* For all the formats except Mpeg2TS/Mpeg2PS, we try with Software decoder
-    first. Currently there is no support for seek in Mpeg2TSExtracto or
-    Mpeg2PSExtractor. Incase of Mpeg2TS  if software decoder fails to decode,
-    the extractor is providing the next available frame instead of seeking back
-    to I-frame. So, incase of Mpeg2TS/Mpeg2PS clips we use hardware decoder
-    for thumbnail generation */
-
-    if ((!strcasecmp(filemime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS))
-        || (!strcasecmp(filemime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS))) {
-            useHWCodec = 1;
-    }
-    if (!useHWCodec) {
-        ALOGV("Trying with s/w codec(NonMpeg2TS/PS clip)");
-        frame =  extractVideoFrameWithCodecFlags(
-           &mClient, trackMeta, source, OMXCodec::kPreferSoftwareCodecs,
-           timeUs, option);
-    }
-    if (frame == NULL) {
-       ALOGV("Software decoder failed to extract thumbnail, "
-           "trying hardware decoder.");
-
-       frame = extractVideoFrameWithCodecFlags(&mClient, trackMeta, source, 0,
-                     timeUs, option);
-    }
-#else
     VideoFrame *frame =
         extractVideoFrameWithCodecFlags(
                 &mClient, trackMeta, source, OMXCodec::kPreferSoftwareCodecs,
@@ -433,7 +357,6 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
         frame = extractVideoFrameWithCodecFlags(&mClient, trackMeta, source, 0,
                         timeUs, option);
     }
-#endif
 
     return frame;
 }
diff --git a/./frameworks/av/media/libstagefright/TimeInterpolator.cpp b/./frameworks/av/media/libstagefright/TimeInterpolator.cpp
deleted file mode 100644
index 391f7ca..0000000
--- a/./frameworks/av/media/libstagefright/TimeInterpolator.cpp
+++ /dev/null
@@ -1,585 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-//#define LOG_NDEBUG 0
-#define LOG_TAG "TimeInterpolator"
-
-#include "include/TimeInterpolator.h"
-
-#include <utils/Log.h>
-#include <time.h>
-
-/* The audio latency is typically 2x the buffer size set in the
- * AudioHAL.  The value here is only used as a default value in case
- * AudioPlayer::latency() returns 0 or a degenerate value.  A similar
- * value is defined in AwesomePlayer.cpp.  They should match, but they
- * do not need to match.
- *
- * For Android, the typical HAL is 4 x 20ms.
- */
-/* 160 ms */
-#define DEFAULT_AUDIO_LATENCY (20000 * 4 * 2)
-
-namespace android
-{
-
-/** Implements and audio clock interpolator with elastic time.
- *
- * If you have a FIFO sink (or source) and the average throughput
- * is expected to be a constant (e.g. audio playback), this can be
- * used to turn the buffer writes into a monotonic clock source.
- * It is intended to be used in an audio callback.  post_buffer()
- * should be called at the BEGINNING of the callback.
- *
- * The system monotonic clock is used as the clock source for this
- * class.  The time differences given by this clock are scaled
- * based on a time factor.  This time factor should be nearly 1.0,
- * but is used to "speed up" or "slow down" our clock based on the
- * how the data in the FIFO is flowing.
- *
- * Intended use:
- *
- *     TimeInterpolator ti;
- *     ti.set_latency(2 * FIFO_SIZE);
- *
- *     ti.seek(position);
- *
- *     for each time data is written to (or read from) FIFO:
- *         ti.post_buffer(time_in_usecs)
- *
- *     ti.pause()
- *     ti.resume() // or reset(to_position_in_usecs)
- *
- *     for each time data is written to FIFO:
- *         ti.post_buffer(time_in_usecs)
- *
- * Note that time_in_usecs should be directly proportional to the
- * size of the write (or read).
- *
- * At any time, ti.get_stream_usecs() may be used to query the
- * streams position.  If the stream is rolling, it will be a
- * monotonic clock source.
- *
- * The stability criteria for this mechanism has not been formally
- * determined.  However, the following criteria have been
- * empirically determined:
- *
- *     - The latency value set is greater than or equal to the
- *       size of the fifos between AudioPlayer and the actual
- *       device output.
- *
- *     - All calls to post_buffer() will be less than half of
- *       the latency value.  (This includes "aggregated" calls
- *       to post_buffer().
- *
- *     - In any time-span roughly equal to the latency value,
- *       all calls to post_buffer() sum up to be about the same
- *       value (within about 5%).
- *
- *     - The latency value is the actual latency from the time
- *       the data is written to the buffer to the time that it
- *       comes out the speaker.
- *
- * The following error conditions are handled:
- *
- *     - OVERFLOW: More than 2x of the latency being posted in
- *       a short period of time.  In this case, the time will
- *       be abruptly updated.
- *
- *     - UNDERFLOW: The time reported by TimeInterpolator catches
- *       up to the read pointer for the audio data.  In this case,
- *       time will stop.
- *
- * This device was inspired by the paper "Using a DLL to Filter
- * Time" (F. Adriaensen, 2005).[1]
- *
- * [1]  http://kokkinizita.linuxaudio.org/papers/usingdll.pdf
- */
-
-void TimeInterpolator::set_latency(int64_t lat_usecs) {
-    if (lat_usecs > 0) {
-        m_latency = lat_usecs;
-    } else {
-        m_latency = DEFAULT_AUDIO_LATENCY;
-    }
-}
-
-TimeInterpolator::TimeInterpolator()
-{
-    /* This value should not be reset on seek() */
-    m_state = STOPPED;
-    m_latency = DEFAULT_AUDIO_LATENCY;
-    seek(0);
-}
-
-TimeInterpolator::~TimeInterpolator()
-{
-}
-
-/* TimeInterpolator State
- *
- * These are the states (modes) for this class:
- *
- *     STOPPED - Audio is not moving, the clock is frozen, and the
- *              fifos are flushed.  This is also the initial state.
- *
- *     ROLLING - The buffer pipelines have all reached steady-state
- *              and we are using a feedback loop to control how
- *              time progresses.
- *
- *     PAUSED - Audio is not moving, the clock is frozen, and
- *              the fifos are maintaining state.  When we
- *              leave this state, we will usually go to ROLLING.
- *
- *
- * Here is the state transition chart:
- *
- * +------------------------------------------------------+
- * |                                                      |
- * |              STOPPED (Initial state)                 |<------+
- * |                                                      |       |
- * +------------------------------------------------------+       |
- *   A                                  |                         |
- *   |                             post_buffer()                  |
- *   |                                  |                         |
- *  stop()                              |                         |
- *   or                                 |                         |
- *  seek()                              |                         |
- *   |                                  V                         |
- * +--------+                      +---------+                    |
- * |        |<----pause()----------|         |                    |
- * | PAUSED |                      | ROLLING |--err_underrun()----|
- * |        |---post_buffer()----->|         |   or stop()
- * +--------+                      +---------+
- *                                  | A
- *      +-----------err_overrun()---+ |
- *      |                             |
- *     / \                            |
- *    /   \                           |
- *  Nth time?--yes---(advance time)---+
- *    \   /
- *     \ /
- *      *
- *      |
- *      no
- *      |
- *   (tweak params)
- *      |
- *      V
- *  (to ROLLING)
- *
- */
-void TimeInterpolator::set_state(state_t s, input_t i)
-{
-    static const char* state_strings[] = {
-        "STOPPED", "ROLLING", "PAUSED",
-    };
-    static const char* input_strings[] = {
-        "STOP", "SEEK", "PAUSE", "POST_BUFFER", "ERR_UNDERRUN",
-        "ERR_OVERRUN",
-    };
-
-    ALOGV("TimeInterpolator state %s -> %s (input: %s)", state_strings[m_state],
-         state_strings[s], input_strings[i]);
-
-    if (m_state == s) {
-        ALOGV("TimeInterpolator calling set_state() should actually change a state.");
-        return;
-    }
-
-    /* this block is just for error-checking */
-    switch (m_state) {
-    case STOPPED:
-        if (s == ROLLING && i != POST_BUFFER) {
-            ALOGE("TimeInterpolator state should only change for POST_BUFFER");
-        }
-        if (s != ROLLING) {
-            ALOGE("TimeInterpolator this state should not be reachable.");
-        }
-        break;
-    case ROLLING:
-        if (s == PAUSED && i != PAUSE) {
-            ALOGE("TimeInterpolator state should only change for PAUSE");
-        }
-        if (s == STOPPED && i != STOP && i != ERR_UNDERRUN) {
-            ALOGE("TimeInterpolator state should only change for STOP or ERR_UNDERRUN");
-        }
-        if (s != PAUSED && s != STOPPED) {
-            ALOGE("TimeInterpolator this state should not be reachable.");
-        }
-        break;
-    case PAUSED:
-        if (s == ROLLING && i != POST_BUFFER) {
-            ALOGE("TimeInterpolator state should only change for POST_BUFFER");
-        }
-        if (s == STOPPED && i != STOP && i != SEEK) {
-            ALOGE("TimeInterpolator state should only change for STOP or SEEK");
-        }
-        if (s != ROLLING && s != STOPPED) {
-            ALOGE("TimeInterpolator this state shoulud not be reachable");
-        }
-        break;
-    };
-    m_state = s;
-}
-
-void TimeInterpolator::reset()
-{
-    stop();
-    seek(0);
-}
-
-void TimeInterpolator::stop()
-{
-    pause(true);
-}
-
-void TimeInterpolator::seek(int64_t media_time)
-{
-    Mutex::Autolock mlock(m_mutex);
-    ALOGV("TimeInterpolator::seek(media_time=%lld)", media_time);
-
-    if (m_state == STOPPED || m_state == PAUSED) {
-        m_pos0 = media_time;
-        m_read = media_time;
-        m_queued = 0;
-        m_t0 = get_system_usecs();
-        m_Tf = 0;
-        m_last = media_time;
-        m_now_last = 0;
-    } else {
-        ALOGE_IF(m_state != ROLLING, "TimeInterpolator logic error: "
-                "state is not rolling in seek()");
-        m_read = media_time;
-        m_pos0 = m_read - m_latency;
-        m_queued = 0;
-        m_t0 = get_system_usecs();
-        m_Tf = 1.0;
-        m_last = m_pos0;
-        m_now_last = 0;
-    }
-}
-
-void TimeInterpolator::pause(bool flushing_fifo)
-{
-    int64_t seek_to = -1;
-
-    m_mutex.lock();
-    ALOGV("%s()", __func__);
-    if (flushing_fifo) {
-        set_state(STOPPED, STOP);
-        seek_to = m_read + m_queued;
-    } else if (m_state == ROLLING) {
-        set_state(PAUSED, PAUSE);
-        m_read += m_queued;
-        m_pos0 = m_last;
-        m_t0 = get_system_usecs();
-        m_queued = 0;
-    }
-    m_mutex.unlock();
-    if (seek_to >= 0) seek(seek_to);
-}
-
-/* Should only be called when in PAUSED state */
-void TimeInterpolator::resume()
-{
-    Mutex::Autolock mlock(m_mutex);
-    if (m_state != PAUSED) {
-        ALOGE("Error: calling %s() when not in PAUSED state",
-             __func__);
-    }
-    m_t0 = get_system_usecs();
-    m_Tf = 1.0;
-}
-
-/* static function */
-int64_t TimeInterpolator::get_system_usecs()
-{
-    struct timespec tv;
-    clock_gettime(CLOCK_MONOTONIC, &tv);
-    return ((int64_t)tv.tv_sec * 1000000L + tv.tv_nsec / 1000);
-}
-
-/* t = m_pos0 + (now - m_t0) * m_Tf
- */
-int64_t TimeInterpolator::get_stream_usecs()
-{
-    int64_t now;
-    double dt;
-    int64_t t_media;
-
-    m_mutex.lock();
-    now = get_system_usecs();
-
-    if (m_state == PAUSED) {
-        t_media = m_pos0;
-        goto end;
-    }
-
-    dt = m_Tf * double(now - m_t0);
-    if (dt < 0.0) dt = 0.0;
-    t_media = m_pos0 + int64_t(dt);
-    if (t_media < m_last) {
-        ALOGW("time is rewinding: %lld Tf=%g t0=%lld pos0=%lld dt=%g "
-             "now=%lld last=%lld now_last=%lld",
-             t_media - m_last, m_Tf, m_t0, m_pos0, dt,
-             now, m_last, m_now_last);
-    }
-    if (t_media >= read_pointer()) {
-        if (m_state == ROLLING) {
-            t_media = read_pointer();
-            ALOGE("UNDERRUN in %s", __func__);
-            err_underrun();
-        }
-    }
-
-    m_last = t_media;
-    m_now_last = now;
-
-end:
-    /* t_media += m_latency; */
-    m_mutex.unlock();
-    ALOGV("%s == %lld (t0=%lld, pos0=%lld, Tf=%g, read=%lld, queued=%lld "
-         "latency=%lld now=%lld, ",
-         __func__, t_media, m_t0, m_pos0, m_Tf, m_read, m_queued,
-         m_latency, now);
-    return t_media;
-}
-
-/* This is the TimeInterpolator algorithm.
- *
- * Let:
- *
- *     read := the read position of the audio data.
- *     t0  := the point that we measure time from in the
- *            current cycle (epoch).
- *     t1  := the next point that we will measure time from.
- *     pos0 := the media time corresponding to t0.
- *     pos1 := the media time corresponding to t1.
- *     pos1_desired := the ideal media time corresponding to
- *            t1, based on the current value of read.
- *     e   := the error between t1 and t1_desired.
- *     Tf  := the time factor (usecs per usec)
- *     latency := the size of all the FIFO's between here and
- *            the hardware.
- *
- * The formula we use to give timestamps is as follows:
- *
- *     t = pos0 + Tf * (now - t0)
- *
- * Where Tf is something close to 1.0 and now is the current time.
- *
- * When ROLLING, we want to update our formula parameters every
- * time data is pushed into the buffer (post_buffer() is called).
- * We start by evaluating t1 to the current system time:
- *
- *     t1 = get_system_usecs();
- *
- * ...this will become our next t0.
- *
- * We calculate pos1 based on the current system time.  That way
- * we stay monotonic:
- *
- *     pos1 = pos0 + Tf * (t1 - t0)
- *
- * However, in an ideal world, pos1 would have come out to be:
- *
- *     pos1_desired = read - latency
- *
- * Since we're being asked for more audio data, then we have a
- * pretty good indication of time time when the data pointed to by
- * `read` will be played:
- *
- *     t_read = t1 + latency
- *
- * So, since pos1 is going to be our new pos0... we want to pick a
- * Tf so that our time-lines intersect.  That is:
- *
- *     read = pos1 + Tf * (t_read - t1)
- *
- * Solving for Tf, we get:
- *
- *     (read - pos1) = Tf * (t_read - t1)
- *
- *     Tf = (read - pos1) / (t_read - t1)
- *
- * We know from the above formula that t_read - t1 = latency:
- *
- *     Tf = (read - pos1) / latency
- *
- * We also know that read = pos1_desired + latency:
- *
- *     Tf = (pos1_desired + latency - pos1) / latency
- *
- * So, we define an error value, e:
- *
- *     e := pos1 - pos1_desired
- *
- * And the formula reduces to:
- *
- *     Tf = 1.0 - (e / latency)
- *
- * Then we complete by advancing our time basis.
- *
- *     t0 = t1
- *     pos0 = pos1
- *
- * IMPLEMENTATION DETAILS:
- *
- * The time when post_buffer() is called is a good indication of
- * the timing of the PREVIOUS call to post_buffer().  We do not
- * have any good indication of the timings of the data posted by
- * frame_usecs, except to estimate when they will begin playing.
- * Therefore, the value of frame_usecs is stored in the member
- * variable m_queued and (typically) rendered on the next call to
- * post_buffer().
- *
- * If post_buffer() is called twice in quick succession, then the
- * data is aggregated instead of updating the epoch.
- */
-void TimeInterpolator::post_buffer(int64_t frame_usecs)
-{
-    int64_t dt;                     /* The actual time since t0 */
-    double e = 0;                   /* error value for our pos0 estimation */
-    int64_t t1;                     /* now.  the next value of t0 */
-    int64_t pos1;                   /* the next value of pos0 */
-    int64_t pos1_desired;           /* the ideal next value of pos0 */
-    bool aggregate_buffers = false; /* see below */
-    bool set_Tf_to_unity = false;   /* In some state changes, m_Tf needs to be set to 1.0 */
-    int64_t posted_this_time;       /* value of m_queued saved for debugging */
-    Mutex::Autolock mlock(m_mutex);
-
-    /* Special logic for startup sequence/states */
-    if (m_state != ROLLING) {
-        if (m_state == PAUSED) {
-            set_state(ROLLING, POST_BUFFER);
-            set_Tf_to_unity = true;
-        }
-
-        if (m_state == STOPPED) {
-            /* Setting the initial_offset to half the latency
-             * was found (by trial-and-error) to stabilize the
-             * TimeInterpolator within about 2-4 video frames.
-             */
-            int64_t initial_offset = m_latency / 2;
-            if (m_queued != 0) {
-                ALOGW("TimeInterpolator state is PAUSED, but m_queued is "
-                     "not 0 (actually %lld)", frame_usecs);
-            }
-            m_t0 = get_system_usecs();
-            set_state(ROLLING, POST_BUFFER);
-            m_read += frame_usecs;
-            if (initial_offset < 40000) {
-                initial_offset = 40000;
-            }
-            m_pos0 = m_read - initial_offset;
-            m_queued = 0;
-            m_Tf = 1.0;
-            goto end;
-        }
-    }
-
-    t1 = get_system_usecs();
-    dt = t1 - m_t0;
-
-    if ((m_state == ROLLING) && (dt < (frame_usecs/4))) {
-        /* See below for explanation */
-        aggregate_buffers = true;
-    }
-
-    /* Main fillBuffer() logic */
-    if (!aggregate_buffers) {
-        /* this is the main algorithm */
-
-        m_read += m_queued;
-        pos1 = m_pos0 + m_Tf * dt;
-        pos1_desired = m_read - m_latency;
-        e = pos1 - pos1_desired;
-
-        if ((pos1 < m_last) && (m_last > 0)) {
-            /* This is ignored at the start of playback */
-            ALOGW("this cycle will cause a rewind pos1=%lld m_last=%lld pos-last=%lld",
-                 pos1, m_last, (pos1-m_last));
-        }
-        if (set_Tf_to_unity) {
-            e = pos1 - (m_read - m_latency);
-            ALOGV("%s set_Tf_to_unity e=%g (resetting to 0)", __func__, e);
-            e = 0;
-            m_Tf = 1.0;
-        } else {
-            m_Tf = 1.0 - (e / m_latency);
-        }
-
-        m_pos0 = pos1;
-        m_t0 = t1;
-        posted_this_time = m_queued;
-        m_queued = frame_usecs;
-
-        if (m_Tf >= 2.0) {
-            m_Tf = 2.0;
-            err_overrun();
-        } else if (m_Tf < .5) {
-            m_Tf = .5;
-        }
-
-        if (m_pos0 >= m_read) {
-            ALOGE("UNDERRUN in %s", __func__);
-            err_underrun();
-        }
-
-        ALOGV("TimeInterpolator updated: t0=%lld dt=%lld, Tf=%g pos0=%lld "
-             "read0=%lld m_queued=%lld posted_this=%lld latency=%lld e=%g "
-             "m_read-m_pos0=%lld t0_prev=%lld\n",
-             m_t0, dt, m_Tf, m_pos0,
-             m_read, m_queued, posted_this_time, m_latency, e,
-             (m_read-m_pos0), (m_t0 - dt));
-    } else {
-        /* If aggregate_buffers == true, then this call is very
-         * close in time to the previous call.  Therefore we will
-         * combine the data with the previous call(s) and treat
-         * them as if they are one.
-         */
-        m_queued += frame_usecs;
-    }
-
-end:
-    return;
-}
-
-/* mutex must already be locked */
-void TimeInterpolator::err_underrun()
-{
-    ALOGE("TimeInterpolator UNDERRUN detected");
-    m_Tf = 0.0;
-    m_read += m_queued;
-    m_pos0 = m_read;
-    m_queued = 0;
-    set_state(STOPPED, ERR_UNDERRUN);
-}
-
-/* mutex must already be locked */
-void TimeInterpolator::err_overrun()
-{
-    ALOGE("TimeInterpolator OVERRUN detected");
-    int64_t now = get_system_usecs();
-    if (m_state == ROLLING) {
-        /* abruptly advance time */
-        m_pos0 = m_read - m_latency;
-        m_t0 = get_system_usecs();
-    }
-}
-
-} /* namespace android */
diff --git a/./frameworks/av/media/libstagefright/colorconversion/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/colorconversion/Android.mk
index 221a7c4..59a64ba 100644
--- a/./frameworks/av/media/libstagefright/colorconversion/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/colorconversion/Android.mk
@@ -11,12 +11,4 @@ LOCAL_C_INCLUDES := \
 
 LOCAL_MODULE:= libstagefright_color_conversion
 
-ifeq ($(OMAP_ENHANCEMENT), true)
-ifeq ($(ENHANCED_DOMX), true)
-LOCAL_C_INCLUDES += $(TOP)/hardware/ti/domx/omx_core/inc
-else
-LOCAL_C_INCLUDES += $(TOP)/hardware/ti/omap4xxx/domx/omx_core/inc
-endif
-endif
-
 include $(BUILD_STATIC_LIBRARY)
diff --git a/./frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
index 65e12e1..597167f 100644
--- a/./frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -132,53 +132,6 @@ status_t ColorConverter::convert(
     return err;
 }
 
-#ifdef OMAP_ENHANCEMENT
-status_t ColorConverter::convertInterlacedBuffer(
-        const void *srcBits,
-        size_t srcWidth, size_t srcHeight,
-        size_t srcCropLeft, size_t srcCropTop,
-        size_t srcCropRight, size_t srcCropBottom,
-        OMX_TI_INTERLACETYPE buff_layout,
-        void *dstBits,
-        size_t dstWidth, size_t dstHeight,
-        size_t dstCropLeft, size_t dstCropTop,
-        size_t dstCropRight, size_t dstCropBottom) {
-    if (mDstFormat != OMX_COLOR_Format16bitRGB565) {
-        return ERROR_UNSUPPORTED;
-    }
-    if (buff_layout != OMX_InterlaceFrameTopFieldFirst &&
-        buff_layout != OMX_InterlaceFrameBottomFieldFirst) {
-        return ERROR_UNSUPPORTED;
-    }
-
-    BitmapParams src(
-            const_cast<void *>(srcBits),
-            srcWidth, srcHeight,
-            srcCropLeft, srcCropTop, srcCropRight, srcCropBottom);
-
-    BitmapParams dst(
-            dstBits,
-            dstWidth, dstHeight,
-            dstCropLeft, dstCropTop, dstCropRight, dstCropBottom);
-
-    status_t err;
-
-    switch (mSrcFormat) {
-        case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
-            err = convertTIYUV420PackedSemiPlanarInterlaced(src, dst);
-            break;
-
-        default:
-        {
-            CHECK(!"Should not be here. Unknown color conversion.");
-            break;
-        }
-    }
-
-    return err;
-}
-#endif
-
 status_t ColorConverter::convertCbYCrY(
         const BitmapParams &src, const BitmapParams &dst) {
     // XXX Untested
@@ -553,76 +506,6 @@ status_t ColorConverter::convertTIYUV420PackedSemiPlanar(
     return OK;
 }
 
-#ifdef OMAP_ENHANCEMENT
-status_t ColorConverter::convertTIYUV420PackedSemiPlanarInterlaced(
-        const BitmapParams &src, const BitmapParams &dst) {
-    uint8_t *kAdjustedClip = initClip();
-
-    if (!((dst.mWidth & 3) == 0
-            && (src.mCropLeft & 1) == 0
-            && src.cropWidth() == dst.cropWidth())) {
-        return ERROR_UNSUPPORTED;
-    }
-
-    uint32_t *dst_ptr = (uint32_t *)dst.mBits
-        + (dst.mCropTop * dst.mWidth + dst.mCropLeft) / 2;
-
-    const uint8_t *src_y = (const uint8_t *)src.mBits;
-
-    const uint8_t *src_u =
-        (const uint8_t *)src_y + src.mWidth * (src.mHeight - src.mCropTop / 2);
-    /* Duplicate the top field while color conversion */
-    for (size_t y = 0; y < src.cropHeight(); ++y) {
-            for (size_t x = 0; x < src.cropWidth(); x += 2) {
-                signed y1 = (signed)src_y[x] - 16;
-                signed y2 = (signed)src_y[x + 1] - 16;
-
-                signed u = (signed)src_u[x & ~1] - 128;
-                signed v = (signed)src_u[(x & ~1) + 1] - 128;
-
-                signed u_b = u * 517;
-                signed u_g = -u * 100;
-                signed v_g = -v * 208;
-                signed v_r = v * 409;
-
-                signed tmp1 = y1 * 298;
-                signed b1 = (tmp1 + u_b) / 256;
-                signed g1 = (tmp1 + v_g + u_g) / 256;
-                signed r1 = (tmp1 + v_r) / 256;
-
-                signed tmp2 = y2 * 298;
-                signed b2 = (tmp2 + u_b) / 256;
-                signed g2 = (tmp2 + v_g + u_g) / 256;
-                signed r2 = (tmp2 + v_r) / 256;
-
-                uint32_t rgb1 =
-                    ((kAdjustedClip[r1] >> 3) << 11)
-                    | ((kAdjustedClip[g1] >> 2) << 5)
-                    | (kAdjustedClip[b1] >> 3);
-
-                uint32_t rgb2 =
-                    ((kAdjustedClip[r2] >> 3) << 11)
-                    | ((kAdjustedClip[g2] >> 2) << 5)
-                    | (kAdjustedClip[b2] >> 3);
-
-                dst_ptr[x / 2] = (rgb2 << 16) | rgb1;
-
-                dst_ptr[dst.mWidth/2 + x / 2] = (rgb2 << 16) | rgb1;
-            }
-
-        src_y += src.mWidth;
-
-        if(y&1){
-           src_u += src.mWidth;
-        }
-
-        dst_ptr += dst.mWidth/2 *2;
-    }
-
-    return OK;
-}
-#endif
-
 uint8_t *ColorConverter::initClip() {
     static const signed kClipMin = -278;
     static const signed kClipMax = 535;
diff --git a/./frameworks/av/media/libstagefright/httplive/LiveSession.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/httplive/LiveSession.cpp
index d23dfba..0cddd2e 100644
--- a/./frameworks/av/media/libstagefright/httplive/LiveSession.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/httplive/LiveSession.cpp
@@ -508,13 +508,7 @@ rinse_repeat:
 
     if (mLastPlaylistFetchTimeUs < 0
             || (ssize_t)bandwidthIndex != mPrevBandwidthIndex
-#ifdef OMAP_ENHANCEMENT
-            || (!mPlaylist->isComplete()
-               && (mPlaylist->meta() != NULL)
-               && timeToRefreshPlaylist(nowUs))) {
-#else
             || (!mPlaylist->isComplete() && timeToRefreshPlaylist(nowUs))) {
-#endif
         AString url;
         if (mBandwidthItems.size() > 0) {
             url = mBandwidthItems.editItemAt(bandwidthIndex).mURI;
diff --git a/./frameworks/av/media/libstagefright/id3/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/id3/Android.mk
index f0ae403..ff35d4a 100644
--- a/./frameworks/av/media/libstagefright/id3/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/id3/Android.mk
@@ -4,11 +4,6 @@ include $(CLEAR_VARS)
 LOCAL_SRC_FILES := \
 	ID3.cpp
 
-ifeq ($(OMAP_ENHANCEMENT),true)
-LOCAL_C_INCLUDES:= \
-    $(TOP)/frameworks/native/include/media/openmax
-endif
-
 LOCAL_MODULE := libstagefright_id3
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/./frameworks/av/media/libstagefright/include/AACExtractor.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/AACExtractor.h
index 9f776cb..e98ca82 100644
--- a/./frameworks/av/media/libstagefright/include/AACExtractor.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/AACExtractor.h
@@ -21,9 +21,6 @@
 #include <media/stagefright/MediaExtractor.h>
 
 #include <utils/Vector.h>
-#ifdef OMAP_ENHANCEMENT
-#include "include/APE.h"
-#endif
 
 namespace android {
 
@@ -46,10 +43,6 @@ protected:
 private:
     sp<DataSource> mDataSource;
     sp<MetaData> mMeta;
-#ifdef OMAP_ENHANCEMENT
-    APE ape;
-    sp<MetaData> mApeMeta;
-#endif
     status_t mInitCheck;
 
     Vector<uint64_t> mOffsetVector;
diff --git a/./frameworks/av/media/libstagefright/include/APE.h b/./frameworks/av/media/libstagefright/include/APE.h
deleted file mode 100644
index d450a62..0000000
--- a/./frameworks/av/media/libstagefright/include/APE.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) Texas Instruments - http://www.ti.com/
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef APE_TAG_H_
-
-#define APE_TAG_H_
-
-#include <utils/RefBase.h>
-#include <media/stagefright/DataSource.h>
-#include <media/stagefright/MetaData.h>
-
-namespace android {
-
-class APE{
-public:
-    APE();
-    ~APE();
-    bool isAPE(uint8_t *apeTag) const;
-    bool parceAPE(const sp<DataSource> &source, off64_t offset,
-            size_t* headerSize, sp<MetaData> &meta);
-
-private:
-    uint32_t itemNumber;
-    uint32_t itemFlags;
-    size_t lenValue;
-};
-
-} //namespace android
-
-#endif //APE_TAG_H_
diff --git a/./frameworks/av/media/libstagefright/include/ASFExtractor.h b/./frameworks/av/media/libstagefright/include/ASFExtractor.h
deleted file mode 100644
index 0501964..0000000
--- a/./frameworks/av/media/libstagefright/include/ASFExtractor.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- *****************************************************************************
- *
- *                                Android
- *                  ITTIAM SYSTEMS PVT LTD, BANGALORE
- *                           COPYRIGHT(C) 2010-20
- *
- *  This program  is  proprietary to  Ittiam  Systems  Private  Limited  and
- *  is protected under Indian  Copyright Law as an unpublished work. Its use
- *  and  disclosure  is  limited by  the terms  and  conditions of a license
- *  agreement. It may not be copied or otherwise  reproduced or disclosed to
- *  persons outside the licensee's organization except in accordance with the
- *  terms  and  conditions   of  such  an  agreement.  All  copies  and
- *  reproductions shall be the property of Ittiam Systems Private Limited and
- *  must bear this notice in its entirety.
- *
- *****************************************************************************
- */
-/**
- *****************************************************************************
- *
- *  @file     ASFExtractor.h
- *
- *  @brief    This file contains definition of ASFExtractor class
- *
- *****************************************************************************
- */
-
-#ifndef ITTIAM_ASF_EXTRACTOR_H_
-
-#define ITTIAM_ASF_EXTRACTOR_H_
-
-#include <media/stagefright/MediaExtractor.h>
-#include <utils/Vector.h>
-
-namespace android {
-
-struct AMessage;
-class String8;
-class ASFExtractorImpl;
-
-typedef struct ASF_WRAPER
-{
-    ASFExtractorImpl* (*ASFExtractor)(
-        const sp<DataSource> &source);
-
-    void (*destructorASFExtractor)(ASFExtractorImpl *mHandle);
-
-    size_t (*countTracks)(ASFExtractorImpl *mHandle);
-
-    sp<MediaSource> (*getTrack)(
-        size_t index, ASFExtractorImpl *mHandle);
-
-    sp<MetaData> (*getTrackMetaData)(
-        size_t index,
-        uint32_t flags,
-        ASFExtractorImpl *mHandle);
-
-    sp<MetaData> (*getMetaData)(ASFExtractorImpl *mHandle);
-
-}ASF_WRAPER;
-
-class ASFExtractor : public MediaExtractor {
-public:
-    // Extractor assumes ownership of "source".
-    ASFExtractor(const sp<DataSource> &source);
-
-    virtual size_t countTracks();
-    virtual sp<MediaSource> getTrack(size_t index);
-    virtual sp<MetaData> getTrackMetaData(size_t index, uint32_t flags);
-
-    virtual sp<MetaData> getMetaData();
-
-protected:
-    virtual ~ASFExtractor();
-
-private:
-    ASF_WRAPER *pASFParser;
-    ASFExtractorImpl *mHandle;
-};
-
-bool SniffASF(const sp<DataSource> &source,
-              String8 *mimeType,
-              float *confidence,
-              sp<AMessage> *meta);
-
-bool isASFParserAvailable();
-
-}  // namespace android
-
-#endif  // ITTIAM_ASF_EXTRACTOR_H_
-
diff --git a/./frameworks/av/media/libstagefright/include/AVIExtractor.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/AVIExtractor.h
index ffd65ba..ff5dcb5 100644
--- a/./frameworks/av/media/libstagefright/include/AVIExtractor.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/AVIExtractor.h
@@ -81,9 +81,6 @@ private:
     status_t mInitCheck;
     Vector<Track> mTracks;
 
-#ifdef OMAP_ENHANCEMENT
-    bool mIsVC1;
-#endif
     off64_t mMovieOffset;
     bool mFoundIndex;
     bool mOffsetsAreAbsolute;
diff --git a/./frameworks/av/media/libstagefright/include/AwesomePlayer.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/AwesomePlayer.h
index baf86d2..68380a8 100644
--- a/./frameworks/av/media/libstagefright/include/AwesomePlayer.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/AwesomePlayer.h
@@ -340,10 +340,6 @@ private:
 
     AwesomePlayer(const AwesomePlayer &);
     AwesomePlayer &operator=(const AwesomePlayer &);
-
-#ifdef OMAP_ENHANCEMENT
-    const char* mExtractorType;
-#endif
 };
 
 }  // namespace android
diff --git a/./frameworks/av/media/libstagefright/include/NuCachedSource2.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/NuCachedSource2.h
index 3647839..5db4b4b 100644
--- a/./frameworks/av/media/libstagefright/include/NuCachedSource2.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/NuCachedSource2.h
@@ -72,25 +72,14 @@ private:
 
     enum {
         kPageSize                       = 65536,
-#ifdef OMAP_ENHANCEMENT
-        kDefaultHighWaterThreshold      = 20 * 1024 * 1024,
-        kDefaultLowWaterThreshold       = 7 * 1024 * 1024,
-#else
         kDefaultHighWaterThreshold      = 20 * 1024 * 1024,
         kDefaultLowWaterThreshold       = 4 * 1024 * 1024,
-#endif
 
         // Read data after a 15 sec timeout whether we're actively
         // fetching or not.
         kDefaultKeepAliveIntervalUs     = 15000000,
     };
 
-#ifdef OMAP_ENHANCEMENT
-    enum {
-        kGrayArea = 2 * 1024 * 1024,
-    };
-#endif
-
     enum {
         kWhatFetchMore  = 'fetc',
         kWhatRead       = 'read',
@@ -112,10 +101,6 @@ private:
     off64_t mCacheOffset;
     status_t mFinalStatus;
     off64_t mLastAccessPos;
-#ifdef OMAP_ENHANCEMENT
-    off64_t mMinAccessPos;
-    off64_t mMaxAccessPos;
-#endif
     sp<AMessage> mAsyncResult;
     bool mFetching;
     int64_t mLastFetchTimeUs;
diff --git a/./frameworks/av/media/libstagefright/include/SampleTable.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/SampleTable.h
index 46f3d9e..847dff7 100644
--- a/./frameworks/av/media/libstagefright/include/SampleTable.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/include/SampleTable.h
@@ -146,12 +146,6 @@ private:
 
     SampleTable(const SampleTable &);
     SampleTable &operator=(const SampleTable &);
-
-#ifdef OMAP_ENHANCEMENT
-public:
-    bool haveDeltaTable() const;
-#endif
-
 };
 
 }  // namespace android
diff --git a/./frameworks/av/media/libstagefright/include/TimeInterpolator.h b/./frameworks/av/media/libstagefright/include/TimeInterpolator.h
deleted file mode 100644
index 1c02bef..0000000
--- a/./frameworks/av/media/libstagefright/include/TimeInterpolator.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef TIME_INTERPOLATOR_H_
-#define TIME_INTERPOLATOR_H_
-
-#include <utils/threads.h>
-#include <utils/RefBase.h>
-#include <stdint.h>
-
-namespace android
-{
-
-class TimeInterpolator : public virtual RefBase
-{
-public:
-    TimeInterpolator();
-    ~TimeInterpolator();
-
-    static int64_t get_system_usecs();
-    static inline int64_t bytes_to_usecs(int64_t bytes, int64_t frame_size,
-                                         int64_t sample_rate);
-    int64_t get_stream_usecs();
-    void post_buffer(int64_t frame_usecs);
-    void reset();
-    void seek(int64_t media_time = 0);
-    void pause(bool flushing_fifo = false);
-    void stop();
-    void resume();
-    int64_t usecs_queued() {
-        return m_queued;
-    }
-    int64_t read_pointer() {
-        return m_read + m_queued;
-    }
-    void set_latency(int64_t lat_usecs);
-
-    /* See docs on set_state() for state progression */
-    typedef enum {
-        STOPPED = 0,
-        ROLLING,
-        PAUSED,
-    } state_t;
-
-    /* These are the inputs (reasons) for doing a state change */
-    typedef enum {
-        STOP = 0,
-        SEEK,
-        PAUSE,
-        POST_BUFFER,
-        ERR_UNDERRUN,
-        ERR_OVERRUN,
-    } input_t;
-
-private:
-    /* All time variables are in microseconds (usecs). */
-    state_t m_state;         /* the current state of this class */
-    Mutex m_mutex;           /* The global class mutex */
-    double m_Tf;             /* time scaling factor */
-    int64_t m_t0;            /* time measured from here (epoch) */
-    int64_t m_pos0;          /* media position at t0 */
-    int64_t m_read;          /* read pointer of media at t0 */
-    int64_t m_queued;        /* amount of media queued for next callback */
-    int64_t m_latency;       /* typ. 1x or 2x the size of the FIFO */
-
-    /* These two are for error checking
-     */
-    int64_t m_last;   /* the last timestamp reported to anyone */
-    int64_t m_now_last;
-
-private:
-    void set_state(state_t s, input_t i); /* mutex must already be locked */
-    void err_underrun();       /* mutex must already be locked */
-    void err_overrun();        /* mutex must already be locked */
-}; // class TimeInterpolator
-
-inline int64_t TimeInterpolator::bytes_to_usecs(int64_t bytes,
-                                                int64_t frame_size,
-                                                int64_t sample_rate)
-{
-    return (bytes / frame_size) * 1000000 / sample_rate;
-}
-
-
-} /* namespace android */
-
-#endif // TIME_INTERPOLATOR_H_
diff --git a/./frameworks/av/media/libstagefright/matroska/MatroskaExtractor.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/matroska/MatroskaExtractor.cpp
index 38a73e1..8c63df9 100644
--- a/./frameworks/av/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -464,24 +464,10 @@ status_t MatroskaSource::readBlock() {
 
     int64_t timeUs = mBlockIter.blockTimeUs();
 
-#ifdef OMAP_ENHANCEMENT
-    int frameCount = block->GetFrameCount();
-    for (int i = 0; i < frameCount ; ++i) {
-#else
     for (int i = 0; i < block->GetFrameCount(); ++i) {
-#endif
         const mkvparser::Block::Frame &frame = block->GetFrame(i);
 
         MediaBuffer *mbuf = new MediaBuffer(frame.len);
-#ifdef OMAP_ENHANCEMENT
-        /*
-         * according the notes for specification such blocks are invalid,
-         * but some decoders make audio starting from negative values
-         */
-        if (mIsAudio) {
-            timeUs = timeUs < 0 ? 0 : timeUs;
-        }
-#endif
         mbuf->meta_data()->setInt64(kKeyTime, timeUs);
         mbuf->meta_data()->setInt32(kKeyIsSyncFrame, block->IsKey());
 
@@ -498,28 +484,6 @@ status_t MatroskaSource::readBlock() {
 
     mBlockIter.advance();
 
-#ifdef OMAP_ENHANCEMENT
-    if (!mBlockIter.eos() && frameCount > 1) {
-        // For files with lacing enabled, we need to amend they kKeyTime of
-        // each frame so that their kKeyTime are advanced accordingly (instead
-        // of being set to the same value). To do this, we need to find out
-        // the duration of the block using the start time of the next block.
-        int64_t duration = mBlockIter.blockTimeUs() - timeUs;
-        int64_t durationPerFrame = duration / frameCount;
-        int64_t durationRemainder = duration % frameCount;
-
-        // We split duration to each of the frame, distributing the remainder (if any)
-        // to the later frames. The later frames are processed first due to the
-        // use of the iterator for the doubly linked list
-        List<MediaBuffer *>::iterator it = mPendingFrames.end();
-        for (int i = frameCount - 1; i >= 0; --i) {
-            --it;
-            int64_t frameRemainder = durationRemainder >= frameCount - i ? 1 : 0;
-            int64_t frameTimeUs = timeUs + durationPerFrame * i + frameRemainder;
-            (*it)->meta_data()->setInt64(kKeyTime, frameTimeUs);
-        }
-    }
-#endif
     return OK;
 }
 
diff --git a/./frameworks/av/media/libstagefright/mpeg2ts/ATSParser.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/mpeg2ts/ATSParser.cpp
index 8fa1012..5f3e300 100644
--- a/./frameworks/av/media/libstagefright/mpeg2ts/ATSParser.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/mpeg2ts/ATSParser.cpp
@@ -619,14 +619,7 @@ status_t ATSParser::Stream::parsePES(ABitReader *br) {
             && stream_id != 0xff  // program_stream_directory
             && stream_id != 0xf2  // DSMCC
             && stream_id != 0xf8) {  // H.222.1 type E
-#ifdef OMAP_ENHANCEMENT
-        if (br->getBits(2) != 2) {
-            ALOGE("[%s] Wrong magic number", __func__);
-            return ERROR_MALFORMED;
-        }
-#else
         CHECK_EQ(br->getBits(2), 2u);
-#endif
 
         MY_LOGV("PES_scrambling_control = %u", br->getBits(2));
         MY_LOGV("PES_priority = %u", br->getBits(1));
@@ -655,58 +648,21 @@ status_t ATSParser::Stream::parsePES(ABitReader *br) {
         unsigned PES_header_data_length = br->getBits(8);
         ALOGV("PES_header_data_length = %u", PES_header_data_length);
 
-#ifdef OMAP_ENHANCEMENT
-        int optional_bytes_remaining = PES_header_data_length;
-        unsigned key_field = 0;
-#else
         unsigned optional_bytes_remaining = PES_header_data_length;
-#endif
 
         uint64_t PTS = 0, DTS = 0;
 
         if (PTS_DTS_flags == 2 || PTS_DTS_flags == 3) {
             CHECK_GE(optional_bytes_remaining, 5u);
 
-#ifdef OMAP_ENHANCEMENT
-            unsigned flagsDTS = br->getBits(4);
-            if (flagsDTS != PTS_DTS_flags) {
-                ALOGE("[%s] PTS_DTS_flags = 0x%X, but should be 0x%X", __func__, flagsDTS, PTS_DTS_flags);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(4), PTS_DTS_flags);
-#endif
 
             PTS = ((uint64_t)br->getBits(3)) << 30;
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGE("[%s] 1. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
             PTS |= ((uint64_t)br->getBits(15)) << 15;
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGE("[%s] 2. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
             PTS |= br->getBits(15);
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGE("[%s] 3. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
 
             ALOGV("PTS = %llu", PTS);
             // ALOGI("PTS = %.2f secs", PTS / 90000.0f);
@@ -716,46 +672,14 @@ status_t ATSParser::Stream::parsePES(ABitReader *br) {
             if (PTS_DTS_flags == 3) {
                 CHECK_GE(optional_bytes_remaining, 5u);
 
-#ifdef OMAP_ENHANCEMENT
-                key_field = br->getBits(4);
-                if (key_field != 1u) {
-                    ALOGE("[%s] 4. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                    return ERROR_MALFORMED;
-                }
-#else
                 CHECK_EQ(br->getBits(4), 1u);
-#endif
 
                 DTS = ((uint64_t)br->getBits(3)) << 30;
-#ifdef OMAP_ENHANCEMENT
-                key_field = br->getBits(1);
-                if (key_field != 1u) {
-                    ALOGE("[%s] 5. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                    return ERROR_MALFORMED;
-                }
-#else
                 CHECK_EQ(br->getBits(1), 1u);
-#endif
                 DTS |= ((uint64_t)br->getBits(15)) << 15;
-#ifdef OMAP_ENHANCEMENT
-                key_field = br->getBits(1);
-                if (key_field != 1u) {
-                    ALOGE("[%s] 6. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                    return ERROR_MALFORMED;
-                }
-#else
                 CHECK_EQ(br->getBits(1), 1u);
-#endif
                 DTS |= br->getBits(15);
-#ifdef OMAP_ENHANCEMENT
-                key_field = br->getBits(1);
-                if (key_field != 1u) {
-                    ALOGE("[%s] 7. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                    return ERROR_MALFORMED;
-                }
-#else
                 CHECK_EQ(br->getBits(1), 1u);
-#endif
 
                 ALOGV("DTS = %llu", DTS);
 
@@ -764,60 +688,21 @@ status_t ATSParser::Stream::parsePES(ABitReader *br) {
         }
 
         if (ESCR_flag) {
-#ifdef OMAP_ENHANCEMENT
-            if (optional_bytes_remaining < 6u) {
-                ALOGV("[%s] optional_bytes_remaining = 0x%X, but should be >= 0x%X", __func__, key_field, 6u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_GE(optional_bytes_remaining, 6u);
-#endif
 
             br->getBits(2);
 
             uint64_t ESCR = ((uint64_t)br->getBits(3)) << 30;
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGE("[%s] 8. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
             ESCR |= ((uint64_t)br->getBits(15)) << 15;
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGE("[%s] 9. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
             ESCR |= br->getBits(15);
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGE("[%s] 10. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
 
             ALOGV("ESCR = %llu", ESCR);
             MY_LOGV("ESCR_extension = %u", br->getBits(9));
 
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGE("[%s] 11. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
 
             optional_bytes_remaining -= 6;
         }
@@ -825,37 +710,14 @@ status_t ATSParser::Stream::parsePES(ABitReader *br) {
         if (ES_rate_flag) {
             CHECK_GE(optional_bytes_remaining, 3u);
 
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGV("[%s] 12. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
             MY_LOGV("ES_rate = %u", br->getBits(22));
-#ifdef OMAP_ENHANCEMENT
-            key_field = br->getBits(1);
-            if (key_field != 1u) {
-                ALOGE("[%s] 13. key_field = 0x%X, but should be 0x%X", __func__, key_field, 1u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(br->getBits(1), 1u);
-#endif
 
             optional_bytes_remaining -= 3;
         }
 
-#ifdef OMAP_ENHANCEMENT
-        if (optional_bytes_remaining > 0) {
-            MY_LOGV("br->skipBits = %d", optional_bytes_remaining);
-            br->skipBits(optional_bytes_remaining * 8);
-        }
-#else
         br->skipBits(optional_bytes_remaining * 8);
-#endif
 
         // ES data follows.
 
@@ -885,14 +747,7 @@ status_t ATSParser::Stream::parsePES(ABitReader *br) {
                     br->data(), br->numBitsLeft() / 8);
 
             size_t payloadSizeBits = br->numBitsLeft();
-#ifdef OMAP_ENHANCEMENT
-            if (payloadSizeBits % 8 != 0u) {
-                ALOGV("[%s] 14. payloadSizeBits % 8 = 0x%X, but should be 0x%X", __func__, key_field, 0u);
-                return ERROR_MALFORMED;
-            }
-#else
             CHECK_EQ(payloadSizeBits % 8, 0u);
-#endif
 
             ALOGV("There's %d bytes of payload.", payloadSizeBits / 8);
         }
@@ -1149,9 +1004,6 @@ status_t ATSParser::parsePID(
         if (mPrograms.editItemAt(i)->parsePID(
                     PID, payload_unit_start_indicator, br, &err)) {
             if (err != OK) {
-#ifdef OMAP_ENHANCEMENT
-                ALOGE("[%s] parsing failed with error code 0x%.8X", __func__, err);
-#endif
                 return err;
             }
 
@@ -1170,13 +1022,7 @@ status_t ATSParser::parsePID(
 void ATSParser::parseAdaptationField(ABitReader *br) {
     unsigned adaptation_field_length = br->getBits(8);
     if (adaptation_field_length > 0) {
-#ifdef OMAP_ENHANCEMENT
-        ALOGV("adaptation_field_length = %u", adaptation_field_length);
-        size_t nBitsSkip = br->numBitsLeft() < adaptation_field_length * 8 ? br->numBitsLeft() : adaptation_field_length * 8;
-        br->skipBits(nBitsSkip);  // XXX
-#else
         br->skipBits(adaptation_field_length * 8);  // XXX
-#endif
     }
 }
 
@@ -1186,16 +1032,7 @@ status_t ATSParser::parseTS(ABitReader *br) {
     unsigned sync_byte = br->getBits(8);
     CHECK_EQ(sync_byte, 0x47u);
 
-#ifdef OMAP_ENHANCEMENT
-    unsigned nTransportError = br->getBits(1);
-    ALOGV("transport_error_indicator = %u", nTransportError);
-    if (nTransportError != 0) {
-        ALOGE("Detected malformed transport stream");
-        return ERROR_MALFORMED;
-    }
-#else
     MY_LOGV("transport_error_indicator = %u", br->getBits(1));
-#endif
 
     unsigned payload_unit_start_indicator = br->getBits(1);
     ALOGV("payload_unit_start_indicator = %u", payload_unit_start_indicator);
diff --git a/./frameworks/av/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp
index 8ec0407..e1589b4 100644
--- a/./frameworks/av/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp
@@ -107,14 +107,7 @@ status_t MPEG2TSSource::read(
         }
 
         status_t err = mExtractor->feedMore();
-#ifdef OMAP_ENHANCEMENT
-        if (err == ERROR_MALFORMED) {
-            ALOGE("[%s] Skiping malformed packet", __func__);
-            continue;
-        } else if (err != OK) {
-#else
         if (err != OK) {
-#endif
             mImpl->signalEOS(err);
         }
     }
@@ -174,22 +167,7 @@ void MPEG2TSExtractor::init() {
     bool haveVideo = false;
     int numPacketsParsed = 0;
 
-#ifdef OMAP_ENHANCEMENT
-    status_t err = OK;
-
-    while (err == OK) {
-        err = feedMore();
-        if (err == ERROR_MALFORMED) {
-            ALOGE("[%s] Detected malformed packet", __func__);
-            err = OK;
-            continue;
-        } else if (err != OK) {
-            ALOGE("[%s] Fatal error");
-            break;
-        }
-#else
     while (feedMore() == OK) {
-#endif
         ATSParser::SourceType type;
         if (haveAudio && haveVideo) {
             break;
@@ -216,11 +194,7 @@ void MPEG2TSExtractor::init() {
             }
         }
 
-#ifdef OMAP_ENHANCEMENT
-        if (++numPacketsParsed > 20000) {
-#else
         if (++numPacketsParsed > 10000) {
-#endif
             break;
         }
     }
diff --git a/./frameworks/av/media/libstagefright/timedtext/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/timedtext/Android.mk
index 7072968..f099bbd 100644
--- a/./frameworks/av/media/libstagefright/timedtext/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/media/libstagefright/timedtext/Android.mk
@@ -12,8 +12,7 @@ LOCAL_SRC_FILES:=                 \
 LOCAL_CFLAGS += -Wno-multichar
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
-        $(TOP)/frameworks/av/media/libstagefright \
-        $(TOP)/frameworks/native/include/media/openmax \
+        $(TOP)/frameworks/av/media/libstagefright
 
 LOCAL_MODULE:= libstagefright_timedtext
 
diff --git a/./frameworks/av/services/audioflinger/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/Android.mk
index 2758c65..8473fab 100644
--- a/./frameworks/av/services/audioflinger/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/Android.mk
@@ -78,12 +78,6 @@ LOCAL_STATIC_LIBRARIES := \
     libcpustats \
     libmedia_helper
 
-ifeq ($(OMAP_ENHANCEMENT), true)
-    LOCAL_SRC_FILES += AudioResamplerSpeex.cpp.arm
-    LOCAL_C_INCLUDES += external/speex/include
-    LOCAL_SHARED_LIBRARIES += libspeexresampler
-endif
-
 LOCAL_MODULE:= libaudioflinger
 
 LOCAL_SRC_FILES += FastMixer.cpp FastMixerState.cpp
diff --git a/./frameworks/av/services/audioflinger/AudioFlinger.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioFlinger.cpp
index 91f9386..aab9984 100644
--- a/./frameworks/av/services/audioflinger/AudioFlinger.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioFlinger.cpp
@@ -1517,9 +1517,6 @@ AudioFlinger::PlaybackThread::PlaybackThread(const sp<AudioFlinger>& audioFlinge
         // but it would be safer to explicitly pass initial masterMute as parameter
         mMasterMute(audioFlinger->masterMute_l()),
         // mStreamTypes[] initialized in constructor body
-#ifdef OMAP_ENHANCEMENT
-        mFmInplay(false),
-#endif
         mOutput(output),
         // Assumes constructor is called by AudioFlinger with it's mLock held,
         // but it would be safer to explicitly pass initial masterVolume as parameter
@@ -1752,11 +1749,7 @@ sp<AudioFlinger::PlaybackThread::Track> AudioFlinger::PlaybackThread::createTrac
         }
     } else {
         // Resampler implementation limits input sampling rate to 2 x output sampling rate.
-#ifdef OMAP_ENHANCEMENT
-        if (AudioResampler::checkRate(mSampleRate, sampleRate)) {
-#else
         if (sampleRate > mSampleRate*2) {
-#endif
             ALOGE("Sample rate out of range: %d mSampleRate %d", sampleRate, mSampleRate);
             lStatus = BAD_VALUE;
             goto Exit;
@@ -2080,14 +2073,6 @@ status_t AudioFlinger::PlaybackThread::getRenderPosition(uint32_t *halFrames, ui
     return mOutput->stream->get_render_position(mOutput->stream, dspFrames);
 }
 
-#ifdef OMAP_ENHANCEMENT
-status_t AudioFlinger::PlaybackThread::setFMRxActive(bool state)
-{
-    ALOGI("AudioFlinger::PlaybackThread::setFMRxActive,state =%x",state);
-    mFmInplay = state;
-    return NO_ERROR;
-}
-#endif
 uint32_t AudioFlinger::PlaybackThread::hasAudioSession(int sessionId)
 {
     Mutex::Autolock _l(mLock);
@@ -2564,11 +2549,7 @@ if (mType == MIXER) {
             // put audio hardware into standby after short delay
             if (CC_UNLIKELY((!mActiveTracks.size() && systemTime() > standbyTime) ||
                         mSuspended > 0)) {
-#ifdef OMAP_ENHANCEMENT
-                if (!mStandby && !mFmInplay) {
-#else
                 if (!mStandby) {
-#endif
 
                     threadLoop_standby();
 
@@ -3527,19 +3508,10 @@ bool AudioFlinger::MixerThread::checkForNewParameters_l()
                     int name = getTrackName_l((audio_channel_mask_t)mTracks[i]->mChannelMask);
                     if (name < 0) break;
                     mTracks[i]->mName = name;
-#ifdef OMAP_ENHANCEMENT
-                    if (AudioResampler::checkRate(sampleRate(),
-                            mTracks[i]->mCblk->sampleRate)) {
-                        mTracks[i]->mCblk->sampleRate =
-                            AudioResampler::checkRate(sampleRate(),
-                                mTracks[i]->mCblk->sampleRate);
-                    }
-#else
                     // limit track sample rate to 2 x new output sample rate
                     if (mTracks[i]->mCblk->sampleRate > 2 * sampleRate()) {
                         mTracks[i]->mCblk->sampleRate = 2 * sampleRate();
                     }
-#endif
                 }
                 sendConfigEvent_l(AudioSystem::OUTPUT_CONFIG_CHANGED);
             }
@@ -6562,12 +6534,7 @@ bool AudioFlinger::RecordThread::checkForNewParameters_l()
                 if (status == BAD_VALUE &&
                     reqFormat == mInput->stream->common.get_format(&mInput->stream->common) &&
                     reqFormat == AUDIO_FORMAT_PCM_16_BIT &&
-#ifdef OMAP_ENHANCEMENT
-                    !AudioResampler::checkRate(reqSamplingRate,
-                        (int)mInput->stream->common.get_sample_rate(&mInput->stream->common)) &&
-#else
                     ((int)mInput->stream->common.get_sample_rate(&mInput->stream->common) <= (2 * reqSamplingRate)) &&
-#endif
                     popcount(mInput->stream->common.get_channels(&mInput->stream->common)) <= FCC_2 &&
                     (reqChannelCount <= FCC_2)) {
                     status = NO_ERROR;
@@ -7043,11 +7010,7 @@ audio_io_handle_t AudioFlinger::openInput(audio_module_handle_t module,
     // or stereo to mono conversions on 16 bit PCM inputs.
     if (status == BAD_VALUE &&
         reqFormat == config.format && config.format == AUDIO_FORMAT_PCM_16_BIT &&
-#ifdef OMAP_ENHANCEMENT
-        !AudioResampler::checkRate(reqSamplingRate, config.sample_rate) &&
-#else
         (config.sample_rate <= 2 * reqSamplingRate) &&
-#endif
         (popcount(config.channel_mask) <= FCC_2) && (popcount(reqChannels) <= FCC_2)) {
         ALOGV("openInput() reopening with proposed sampling rate and channels");
         inStream = NULL;
@@ -7135,21 +7098,6 @@ status_t AudioFlinger::setStreamOutput(audio_stream_type_t stream, audio_io_hand
     return NO_ERROR;
 }
 
-#ifdef OMAP_ENHANCEMENT
-status_t AudioFlinger::setFMRxActive(bool state)
-{
-    ALOGI("setFMRxActive() ");
-    // check calling permissions
-    if (!settingsAllowed()) {
-        return PERMISSION_DENIED;
-    }
-
-    for (uint32_t i = 0; i < mPlaybackThreads.size(); i++)
-        mPlaybackThreads.valueAt(i)->setFMRxActive(state);
-
-    return NO_ERROR;
-}
-#endif
 
 int AudioFlinger::newAudioSessionId()
 {
diff --git a/./frameworks/av/services/audioflinger/AudioFlinger.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioFlinger.h
index 4ede0ba..cfd718f 100644
--- a/./frameworks/av/services/audioflinger/AudioFlinger.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioFlinger.h
@@ -136,9 +136,7 @@ public:
 
     virtual     status_t    setMicMute(bool state);
     virtual     bool        getMicMute() const;
-#ifdef OMAP_ENHANCEMENT
-    virtual     status_t    setFMRxActive(bool state);
-#endif
+
     virtual     status_t    setParameters(audio_io_handle_t ioHandle, const String8& keyValuePairs);
     virtual     String8     getParameters(audio_io_handle_t ioHandle, const String8& keys) const;
 
@@ -981,9 +979,6 @@ public:
 
                     float       streamVolume(audio_stream_type_t stream) const;
 
-#ifdef OMAP_ENHANCEMENT
-        virtual     status_t   setFMRxActive(bool state);
-#endif
                     sp<Track>   createTrack_l(
                                     const sp<AudioFlinger::Client>& client,
                                     audio_stream_type_t streamType,
@@ -1035,9 +1030,6 @@ public:
         bool                            mMasterMute;
                     void        setMasterMute_l(bool muted) { mMasterMute = muted; }
     protected:
-#ifdef OMAP_ENHANCEMENT
-        bool                            mFmInplay;
-#endif
         SortedVector< wp<Track> >       mActiveTracks;  // FIXME check if this could be sp<>
 
         // Allocate a track name for a given channel mask.
diff --git a/./frameworks/av/services/audioflinger/AudioPolicyService.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioPolicyService.cpp
index dd08d43..0d13970 100644
--- a/./frameworks/av/services/audioflinger/AudioPolicyService.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioPolicyService.cpp
@@ -1500,17 +1500,6 @@ static void aps_set_parameters(void *service, audio_io_handle_t io_handle,
     audioPolicyService->setParameters(io_handle, kv_pairs, delay_ms);
 }
 
-#ifdef OMAP_ENHANCEMENT
-static int aps_set_FMRxActive(void *service, bool state)
-{
-    sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
-    if (af == NULL)
-        return PERMISSION_DENIED;
-
-    return af->setFMRxActive(state);
-}
-#endif
-
 static int aps_set_stream_volume(void *service, audio_stream_type_t stream,
                                      float volume, audio_io_handle_t output,
                                      int delay_ms)
@@ -1565,9 +1554,6 @@ namespace {
         load_hw_module        : aps_load_hw_module,
         open_output_on_module : aps_open_output_on_module,
         open_input_on_module  : aps_open_input_on_module,
-#ifdef OMAP_ENHANCEMENT
-        set_FMRxActive        : aps_set_FMRxActive,
-#endif
     };
 }; // namespace <unnamed>
 
diff --git a/./frameworks/av/services/audioflinger/AudioResampler.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioResampler.cpp
index 6fea51a..fbb54cf 100644
--- a/./frameworks/av/services/audioflinger/AudioResampler.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioResampler.cpp
@@ -28,11 +28,6 @@
 #include "AudioResamplerCubic.h"
 #endif
 
-#ifdef OMAP_ENHANCEMENT
-#include "AudioResamplerSpeex.h"
-#include <utils/threads.h>
-#endif
-
 #ifdef __arm__
 #include <machine/cpu-features.h>
 #endif
@@ -98,11 +93,7 @@ AudioResampler* AudioResampler::create(int bitDepth, int inChannelCount,
     }
 
     if (quality == DEFAULT)
-#ifdef OMAP_ENHANCEMENT
-        quality = SPEEX_QUALITY;
-#else
         quality = LOW_QUALITY;
-#endif
 
     switch (quality) {
     default:
@@ -120,12 +111,6 @@ AudioResampler* AudioResampler::create(int bitDepth, int inChannelCount,
         resampler = new AudioResamplerSinc(bitDepth, inChannelCount, sampleRate);
         break;
 #endif
-#ifdef OMAP_ENHANCEMENT
-    case SPEEX_QUALITY:
-        ALOGV("Create Speex Resampler");
-        resampler = new AudioResamplerSpeex(bitDepth, inChannelCount, sampleRate);
-        break;
-#endif
     }
 
     // initialize resampler
@@ -133,32 +118,6 @@ AudioResampler* AudioResampler::create(int bitDepth, int inChannelCount,
     return resampler;
 }
 
-#ifdef OMAP_ENHANCEMENT
-int32_t AudioResampler::checkRate(int32_t outRate, int32_t inRate) {
-    static AudioResampler *resampler = NULL;
-
-    if (!resampler) {
-        static android::Mutex lock;
-        android::AutoMutex _l(lock);
-        if (!resampler) {
-            resampler = create(16, 2, 44100);
-            ALOGD("static resampler for checkRate() allocated\n");
-        }
-    }
-
-    return resampler->checkCRate(outRate, inRate);
-}
-
-int32_t AudioResampler::checkCRate(int32_t outRate, int32_t inRate) const {
-    if (inRate > 2*outRate) {
-        ALOGD("Unsupported conversion from %d to %d. Maximum input rate is %d.\n",
-             inRate, outRate, 2*outRate);
-        return 2*outRate;
-    }
-    return 0;
-}
-#endif
-
 AudioResampler::AudioResampler(int bitDepth, int inChannelCount,
         int32_t sampleRate) :
     mBitDepth(bitDepth), mChannelCount(inChannelCount),
diff --git a/./frameworks/av/services/audioflinger/AudioResampler.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioResampler.h
index a73b515..1610e00 100644
--- a/./frameworks/av/services/audioflinger/AudioResampler.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/audioflinger/AudioResampler.h
@@ -38,20 +38,12 @@ public:
         DEFAULT=0,
         LOW_QUALITY=1,
         MED_QUALITY=2,
-        HIGH_QUALITY=3,
-#ifdef OMAP_ENHANCEMENT
-        SPEEX_QUALITY=4,
-#endif
+        HIGH_QUALITY=3
     };
 
     static AudioResampler* create(int bitDepth, int inChannelCount,
             int32_t sampleRate, int quality=DEFAULT);
 
-#ifdef OMAP_ENHANCEMENT
-    static int32_t checkRate(int32_t outRate, int32_t inRate);
-    virtual int32_t checkCRate(int32_t outRate, int32_t inRate) const;
-#endif
-
     virtual ~AudioResampler();
 
     virtual void init() = 0;
diff --git a/./frameworks/av/services/audioflinger/AudioResamplerSpeex.cpp b/./frameworks/av/services/audioflinger/AudioResamplerSpeex.cpp
deleted file mode 100644
index da75616..0000000
--- a/./frameworks/av/services/audioflinger/AudioResamplerSpeex.cpp
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Copyright (C) 2012 Texas Instruments
- *
- * Contact: Jyri Sarha <jsarha@ti.com>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "AudioSpeexSRC"
-//#define LOG_NDEBUG 0
-
-#include <stdint.h>
-#include <string.h>
-#include <sys/types.h>
-#include <cutils/log.h>
-
-#include "AudioResamplerSpeex.h"
-
-#define TMPBUFFSIZE 4096
-
-namespace android {
-
-AudioResamplerSpeex::AudioResamplerSpeex(int bitDepth, int inChannelCount, int32_t sampleRate,
-                                         int speexQuality) :
-        AudioResampler(bitDepth, inChannelCount, sampleRate),
-        mSpeexResamplerState(NULL), mQuality(speexQuality),
-        mRateNum(0), mRateDen(0) {
-}
-
-void AudioResamplerSpeex::init() {
-    int err;
-    ALOGD("AudioResamplerSpeex::init() mChannelCount=%u, mInSampleRate=%u, "
-         "mSampleRate=%u, mQuality=%u", mChannelCount, mInSampleRate,
-         mSampleRate, mQuality);
-
-    mSpeexResamplerState = speex_resampler_init(mChannelCount,
-                                                mInSampleRate,
-                                                mSampleRate,
-                                                mQuality,
-                                                &err);
-    if (err != 0) {
-        ALOGE("speex_resampler_init() failed: %s",
-             speex_resampler_strerror(err));
-        return;
-    }
-    speex_resampler_get_ratio(mSpeexResamplerState, &mRateNum, &mRateDen);
-}
-
-AudioResamplerSpeex::~AudioResamplerSpeex() {
-    ALOGD("AudioResamplerSpeex::~AudioResamplerSpeex()");
-
-    if (mSpeexResamplerState) {
-        speex_resampler_destroy(mSpeexResamplerState);
-        mSpeexResamplerState = NULL;
-    }
-}
-
-void AudioResamplerSpeex::setSampleRate(int32_t inSampleRate) {
-    /* It appears AudioFlinger calls this method between each resample()
-       call. So, it is good to filter unnecessary processing if there
-       is no change.
-    */
-    if (inSampleRate == mInSampleRate) {
-        return;
-    }
-
-    ALOGD("AudioResamplerSpeex::setSampleRate() mChannelCount=%u, "
-         "mInSampleRate=%u->%u, mSampleRate=%u, mQuality=%u",
-         mChannelCount, mInSampleRate, inSampleRate, mSampleRate, mQuality);
-
-    mInSampleRate = inSampleRate;
-    int  err = speex_resampler_set_rate(mSpeexResamplerState,
-                                        mInSampleRate,
-                                        mSampleRate);
-    if (err != 0) {
-        ALOGE("speex_resampler_set_rate() failed: %s",
-             speex_resampler_strerror(err));
-        return;
-    }
-
-    speex_resampler_get_ratio(mSpeexResamplerState, &mRateNum, &mRateDen);
-}
-
-void AudioResamplerSpeex::reset() {
-    ALOGD("AudioResamplerSpeex::reset()");
-
-    AudioResampler::reset();
-
-    int err = speex_resampler_reset_mem(mSpeexResamplerState);
-
-    if (err != 0) {
-        ALOGE("speex_resampler_reset_mem() failed: %s",
-             speex_resampler_strerror(err));
-    }
-}
-
-void AudioResamplerSpeex::resample(int32_t* out, size_t outFrameCount,
-        AudioBufferProvider* provider) {
-
-    switch (mChannelCount) {
-    case 1:
-        resampleMono16(out, outFrameCount, provider);
-        break;
-    case 2:
-        resampleStereo16(out, outFrameCount, provider);
-        break;
-    default:
-        ALOGE("Unsupported number of channels %d", mChannelCount);
-        break;
-    }
-}
-
-void AudioResamplerSpeex::resampleStereo16(int32_t* out, size_t outFrameCount,
-        AudioBufferProvider* provider) {
-
-    size_t outFrameIndex = 0;
-    size_t inFrameCount = (outFrameCount*mRateNum) / mRateDen;
-
-    while(outFrameIndex < outFrameCount) {
-        if (mInputIndex >= mBuffer.frameCount) {
-            /* mBuffer.raw is undefined if mBuffer.frameCount == 0 */
-            if (mBuffer.frameCount && (mBuffer.raw != NULL)) {
-                provider->releaseBuffer(&mBuffer);
-            }
-            mInputIndex = 0;
-        }
-        if (mBuffer.frameCount == 0) {
-            mBuffer.frameCount = inFrameCount;
-            provider->getNextBuffer(&mBuffer);
-            if (mBuffer.raw == NULL)
-                return;
-        }
-        int16_t *in = &mBuffer.i16[mChannelCount*mInputIndex];
-        uint32_t inCount = (mBuffer.frameCount - mInputIndex);
-        int16_t outBuffer[TMPBUFFSIZE];
-        uint32_t outCount = sizeof(outBuffer)/(sizeof(int16_t)*mChannelCount);
-        outCount = outCount < (outFrameCount-outFrameIndex) ?
-            outCount : (outFrameCount-outFrameIndex);
-
-        (void)speex_resampler_process_interleaved_int(mSpeexResamplerState,
-                                                      in,
-                                                      &inCount,
-                                                      outBuffer,
-                                                          &outCount);
-        mInputIndex += inCount;
-
-        for(uint i=0; i < outCount; i++) {
-            out[2*(outFrameIndex+i)] += (int32_t)mVolume[0] * outBuffer[2*i];
-            out[2*(outFrameIndex+i)+1] += (int32_t)mVolume[1] * outBuffer[2*i+1];
-        }
-
-        outFrameIndex += outCount;
-    }
-}
-
-void AudioResamplerSpeex::resampleMono16(int32_t* out, size_t outFrameCount,
-        AudioBufferProvider* provider) {
-
-    size_t outFrameIndex = 0;
-    size_t inFrameCount = (outFrameCount*mRateNum) / mRateDen;
-
-    while(outFrameIndex < outFrameCount) {
-        if (mInputIndex >= mBuffer.frameCount) {
-            /* mBuffer.raw is undefined if mBuffer.frameCount == 0 */
-            if (mBuffer.frameCount && (mBuffer.raw != NULL)) {
-                provider->releaseBuffer(&mBuffer);
-            }
-            mInputIndex = 0;
-        }
-        if (mBuffer.frameCount == 0) {
-            mBuffer.frameCount = inFrameCount;
-            provider->getNextBuffer(&mBuffer);
-            if (mBuffer.raw == NULL)
-                return;
-        }
-        int16_t *in = &mBuffer.i16[mInputIndex];
-        uint32_t inCount = (mBuffer.frameCount - mInputIndex);
-        int16_t outBuffer[TMPBUFFSIZE];
-        uint32_t outCount = sizeof(outBuffer)/(sizeof(int16_t));
-        outCount = outCount < (outFrameCount-outFrameIndex) ?
-            outCount : (outFrameCount-outFrameIndex);
-
-        (void)speex_resampler_process_int(mSpeexResamplerState,
-                                          0,
-                                          in,
-                                          &inCount,
-                                          outBuffer,
-                                          &outCount);
-        mInputIndex += inCount;
-
-        for(uint i=0; i < outCount; i++) {
-            out[2*(outFrameIndex+i)] += (int32_t)mVolume[0] * outBuffer[i];
-            out[2*(outFrameIndex+i)+1] += (int32_t)mVolume[1] * outBuffer[i];
-        }
-
-        outFrameIndex += outCount;
-    }
-}
-
-}
-; // namespace android
diff --git a/./frameworks/av/services/audioflinger/AudioResamplerSpeex.h b/./frameworks/av/services/audioflinger/AudioResamplerSpeex.h
deleted file mode 100644
index f93e51a..0000000
--- a/./frameworks/av/services/audioflinger/AudioResamplerSpeex.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2012 Texas Instruments
- *
- * Contact: Jyri Sarha <jsarha@ti.com>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_AUDIO_RESAMPLER_SPEEX_H
-#define ANDROID_AUDIO_RESAMPLER_SPEEX_H
-
-#ifndef OMAP_ENHANCEMENT
-#error This file should only be used with the OMAP_ENHANCEMENT macro.
-#endif
-
-#include <stdint.h>
-#include <sys/types.h>
-#include <cutils/log.h>
-
-#include <speex/speex_resampler.h>
-
-#include "AudioResampler.h"
-
-namespace android {
-
-class AudioResamplerSpeex : public AudioResampler {
-public:
-    AudioResamplerSpeex(int bitDepth, int inChannelCount, int32_t sampleRate,
-                        int speexQuality = 2);
-    virtual ~AudioResamplerSpeex();
-
-    virtual void setSampleRate(int32_t inSampleRate);
-    virtual void resample(int32_t* out, size_t outFrameCount,
-            AudioBufferProvider* provider);
-    virtual void reset();
-
-    virtual int32_t checkCRate(int32_t outRate, int32_t inRate) const {
-        return 0;
-    }
-
-private:
-    void init();
-    void resampleMono16(int32_t* out, size_t outFrameCount,
-            AudioBufferProvider* provider);
-    void resampleStereo16(int32_t* out, size_t outFrameCount,
-            AudioBufferProvider* provider);
-
-    SpeexResamplerState *mSpeexResamplerState;
-    int mQuality;
-    uint32_t mRateNum;
-    uint32_t mRateDen;
-};
-
-}; // namespace android
-
-#endif /*ANDROID_AUDIO_RESAMPLER_SPEEX_H*/
diff --git a/./frameworks/av/services/camera/libcameraservice/CameraHardwareInterface.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/camera/libcameraservice/CameraHardwareInterface.h
index e94b6aa..87a0802 100644
--- a/./frameworks/av/services/camera/libcameraservice/CameraHardwareInterface.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/camera/libcameraservice/CameraHardwareInterface.h
@@ -24,10 +24,6 @@
 #include <ui/GraphicBuffer.h>
 #include <camera/Camera.h>
 #include <camera/CameraParameters.h>
-#ifdef OMAP_ENHANCEMENT_CPCAM
-#include <camera/ShotParameters.h>
-#include <camera/CameraMetadata.h>
-#endif
 #include <system/window.h>
 #include <hardware/camera.h>
 
@@ -107,35 +103,7 @@ public:
             ALOGE("Could not open camera %s: %d", mName.string(), rc);
             return rc;
         }
-
-#ifdef OMAP_ENHANCEMENT
-        memset(&mDeviceExtendedOps, 0, sizeof(mDeviceExtendedOps));
-        memset(&mPreviewStreamExtendedOps, 0, sizeof(mPreviewStreamExtendedOps));
-
-        if (mDevice->ops->send_command) {
-            int32_t arg1, arg2;
-            camera_cmd_send_command_pointer_to_args(&mDeviceExtendedOps, &arg1, &arg2);
-            mDevice->ops->send_command(mDevice, CAMERA_CMD_SETUP_EXTENDED_OPERATIONS, arg1, arg2);
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-            mPreviewStreamExtendedOps.update_and_get_buffer = __update_and_get_buffer;
-            mPreviewStreamExtendedOps.get_buffer_dimension = __get_buffer_dimension;
-            mPreviewStreamExtendedOps.get_buffer_format = __get_buffer_format;
-            mPreviewStreamExtendedOps.set_metadata = __set_metadata;
-#endif
-            if (mDeviceExtendedOps.set_extended_preview_ops) {
-                mDeviceExtendedOps.set_extended_preview_ops(mDevice, &mPreviewStreamExtendedOps);
-            }
-        }
-#endif
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        initHalPreviewWindow(mHalPreviewWindow);
-        initHalPreviewWindow(mHalTapin);
-        initHalPreviewWindow(mHalTapout);
-#else
         initHalPreviewWindow();
-#endif
         return rc;
     }
 
@@ -147,9 +115,6 @@ public:
         if (mDevice->ops->set_preview_window) {
             mPreviewWindow = buf;
             mHalPreviewWindow.user = this;
-#ifdef OMAP_ENHANCEMENT_CPCAM
-            mHalPreviewWindow.window = mPreviewWindow.get();
-#endif
             ALOGV("%s &mHalPreviewWindow %p mHalPreviewWindow.user %p", __FUNCTION__,
                     &mHalPreviewWindow, mHalPreviewWindow.user);
             return mDevice->ops->set_preview_window(mDevice,
@@ -397,18 +362,6 @@ public:
         return INVALID_OPERATION;
     }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    status_t takePictureWithParameters(const ShotParameters &params)
-    {
-        ALOGV("%s(%s)", __FUNCTION__, mName.string());
-        if (mDeviceExtendedOps.take_picture_with_parameters) {
-            return mDeviceExtendedOps.take_picture_with_parameters(mDevice,
-                    params.flatten().string());
-        }
-        return INVALID_OPERATION;
-    }
-#endif
-
     /**
      * Cancel a picture that was started with takePicture.  Calling this
      * method when no picture is being taken is a no-op.
@@ -471,37 +424,6 @@ public:
             mDevice->ops->release(mDevice);
     }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    /** Set the ANativeWindow to which preview frames are sent */
-    status_t setBufferSource(const sp<ANativeWindow>& tapin,
-                             const sp<ANativeWindow>& tapout)
-    {
-        ALOGV("%s(%s)", __FUNCTION__, mName.string());
-        if (mDeviceExtendedOps.set_buffer_source) {
-            const status_t err = mDeviceExtendedOps.set_buffer_source(mDevice,
-                    tapin.get() ? &mHalTapin.nw : 0,
-                    tapout.get() ? &mHalTapout.nw : 0);
-            mTapin = tapin;
-            mHalTapin.user = this;
-            mHalTapin.window = mTapin.get();
-            mTapout = tapout;
-            mHalTapout.user = this;
-            mHalTapout.window = mTapout.get();
-            return err;
-        }
-        return INVALID_OPERATION;
-    }
-
-    status_t reprocess(const ShotParameters &params)
-    {
-        ALOGV("%s(%s)", __FUNCTION__, mName.string());
-        if (mDeviceExtendedOps.reprocess) {
-            return mDeviceExtendedOps.reprocess(mDevice, params.flatten().string());
-        }
-        return INVALID_OPERATION;
-    }
-#endif
-
     /**
      * Dump state of the camera hardware
      */
@@ -517,11 +439,6 @@ private:
     camera_device_t *mDevice;
     String8 mName;
 
-#ifdef OMAP_ENHANCEMENT
-    camera_device_extended_ops_t mDeviceExtendedOps;
-    preview_stream_extended_ops_t mPreviewStreamExtendedOps;
-#endif
-
     static void __notify_cb(int32_t msg_type, int32_t ext1,
                             int32_t ext2, void *user)
     {
@@ -638,9 +555,6 @@ private:
         mem->decStrong(mem);
     }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-#define anw(n) (((struct camera_preview_window *)n)->window)
-#else
     static ANativeWindow *__to_anw(void *user)
     {
         CameraHardwareInterface *__this =
@@ -648,7 +562,6 @@ private:
         return __this->mPreviewWindow.get();
     }
 #define anw(n) __to_anw(((struct camera_preview_window *)n)->user)
-#endif
 
     static int __dequeue_buffer(struct preview_stream_ops* w,
                                 buffer_handle_t** buffer, int *stride)
@@ -746,72 +659,6 @@ private:
         return a->query(a, NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS, count);
     }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    static int __update_and_get_buffer(struct preview_stream_ops* w,
-            buffer_handle_t** buffer, int *stride)
-    {
-        ANativeWindow *a = anw(w);
-        ANativeWindowBuffer* anb;
-        int status = a->perform(a, NATIVE_WINDOW_UPDATE_AND_GET_CURRENT, &anb);
-        if (status != OK) {
-            return status;
-        }
-
-        *buffer = &anb->handle;
-        *stride = anb->stride;
-        return OK;
-    }
-
-    static int __get_buffer_dimension(struct preview_stream_ops *w,
-            int *width, int *height)
-    {
-        ANativeWindow *a = anw(w);
-        int status;
-
-        status = a->query(a, NATIVE_WINDOW_WIDTH, width);
-        if (status != OK) {
-            return status;
-        }
-
-        status = a->query(a, NATIVE_WINDOW_HEIGHT, height);
-        if (status != OK) {
-            return status;
-        }
-
-        return OK;
-    }
-
-    static int __get_buffer_format(struct preview_stream_ops *w,
-            int *format)
-    {
-        ANativeWindow *a = anw(w);
-        return a->query(a, NATIVE_WINDOW_FORMAT, format);
-    }
-
-    static int __set_metadata(struct preview_stream_ops *w,
-            const camera_memory_t *metadata)
-    {
-        ANativeWindow *a = anw(w);
-        sp<CameraHeapMemory> mem = static_cast<CameraHeapMemory *>(metadata->handle);
-        return native_window_set_buffers_metadata(a, mem->mBuffers[0].get());
-    }
-
-    struct camera_preview_window;
-    void initHalPreviewWindow(camera_preview_window &w)
-    {
-        w.nw.cancel_buffer = __cancel_buffer;
-        w.nw.lock_buffer = __lock_buffer;
-        w.nw.dequeue_buffer = __dequeue_buffer;
-        w.nw.enqueue_buffer = __enqueue_buffer;
-        w.nw.set_buffer_count = __set_buffer_count;
-        w.nw.set_buffers_geometry = __set_buffers_geometry;
-        w.nw.set_crop = __set_crop;
-        w.nw.set_usage = __set_usage;
-        w.nw.set_swap_interval = __set_swap_interval;
-        w.nw.get_min_undequeued_buffer_count = __get_min_undequeued_buffer_count;
-    }
-
-#else
     void initHalPreviewWindow()
     {
         mHalPreviewWindow.nw.cancel_buffer = __cancel_buffer;
@@ -828,27 +675,16 @@ private:
         mHalPreviewWindow.nw.get_min_undequeued_buffer_count =
                 __get_min_undequeued_buffer_count;
     }
-#endif
 
     sp<ANativeWindow>        mPreviewWindow;
 
     struct camera_preview_window {
         struct preview_stream_ops nw;
         void *user;
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        ANativeWindow *window;
-#endif
     };
 
     struct camera_preview_window mHalPreviewWindow;
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    sp<ANativeWindow>        mTapin;
-    sp<ANativeWindow>        mTapout;
-    struct camera_preview_window mHalTapin;
-    struct camera_preview_window mHalTapout;
-#endif
-
     notify_callback         mNotifyCb;
     data_callback           mDataCb;
     data_callback_timestamp mDataCbTimestamp;
diff --git a/./frameworks/av/services/camera/libcameraservice/CameraService.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/camera/libcameraservice/CameraService.cpp
index 8b82c5e..bf07f8b 100644
--- a/./frameworks/av/services/camera/libcameraservice/CameraService.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/camera/libcameraservice/CameraService.cpp
@@ -518,17 +518,6 @@ void CameraService::Client::disconnect() {
         mPreviewWindow = 0;
         mHardware->setPreviewWindow(mPreviewWindow);
     }
-#ifdef OMAP_ENHANCEMENT_CPCAM
-   // Release the held ANativeWindow resources.
-    if (mTapinClient != 0 || mTapoutClient != 0) {
-        if (mTapoutClient != 0) {
-            disconnectWindow(mTapoutClient);
-        }
-        mTapinClient = 0;
-        mTapoutClient = 0;
-        mHardware->setBufferSource(mTapinClient, mTapoutClient);
-    }
-#endif
     mHardware.clear();
 
     mCameraService->removeClient(mCameraClient);
@@ -678,11 +667,6 @@ status_t CameraService::Client::startPreviewMode() {
         native_window_set_buffers_transform(mPreviewWindow.get(),
                 mOrientation);
     }
-
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-    disableMsgType(CAMERA_MSG_COMPRESSED_BURST_IMAGE);
-#endif
-
     mHardware->setPreviewWindow(mPreviewWindow);
     result = mHardware->startPreview();
 
@@ -723,16 +707,6 @@ void CameraService::Client::stopPreview() {
     Mutex::Autolock lock(mLock);
     if (checkPidAndHardware() != NO_ERROR) return;
 
-#ifdef OMAP_ENHANCEMENT
-    // According to framework documentation, preview needs
-    // to be started for image capture. This will make sure
-    // that image capture related messages get disabled if
-    // not done already in their respective handlers.
-    // If these messages come when in the midddle of
-    // stopping preview we will deadlock the system in
-    // lockIfMessageWanted().
-    disableMsgType(CAMERA_MSG_POSTVIEW_FRAME);
-#endif
 
     disableMsgType(CAMERA_MSG_PREVIEW_FRAME);
     mHardware->stopPreview();
@@ -814,11 +788,7 @@ status_t CameraService::Client::cancelAutoFocus() {
 }
 
 // take a picture - image is returned in callback
-#ifdef OMAP_ENHANCEMENT_CPCAM
-status_t CameraService::Client::takePicture(int msgType, const String8& params) {
-#else
 status_t CameraService::Client::takePicture(int msgType) {
-#endif
     LOG1("takePicture (pid %d): 0x%x", getCallingPid(), msgType);
 
     Mutex::Autolock iLock(mICameraLock);
@@ -842,37 +812,12 @@ status_t CameraService::Client::takePicture(int msgType) {
                         CAMERA_MSG_POSTVIEW_FRAME |
                         CAMERA_MSG_RAW_IMAGE |
                         CAMERA_MSG_RAW_IMAGE_NOTIFY |
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-                        CAMERA_MSG_RAW_BURST |
-#endif
                         CAMERA_MSG_COMPRESSED_IMAGE);
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-        picMsgType |= CAMERA_MSG_COMPRESSED_BURST_IMAGE;
-#endif
+
     }
     enableMsgType(picMsgType);
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    // make sure the other capture messages are disabled
-    picMsgType = ~picMsgType &
-                 (CAMERA_MSG_SHUTTER |
-                  CAMERA_MSG_POSTVIEW_FRAME |
-                  CAMERA_MSG_RAW_IMAGE |
-                  CAMERA_MSG_RAW_IMAGE_NOTIFY |
-                  CAMERA_MSG_COMPRESSED_IMAGE |
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-                  CAMERA_MSG_RAW_BURST |
-                  CAMERA_MSG_COMPRESSED_BURST_IMAGE |
-#endif
-                  CAMERA_MSG_RAW_IMAGE_NOTIFY);
-    disableMsgType(picMsgType);
-#endif
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    return mHardware->takePictureWithParameters(params);
-#else
     return mHardware->takePicture();
-#endif
 }
 
 // set preview/capture parameters - key/value pairs
@@ -966,126 +911,11 @@ status_t CameraService::Client::sendCommand(int32_t cmd, int32_t arg1, int32_t a
     } else if (cmd == CAMERA_CMD_PING) {
         // If mHardware is 0, checkPidAndHardware will return error.
         return OK;
-#ifdef OMAP_ENHANCEMENT_VTC
-    } else if (cmd == CAMERA_CMD_PREVIEW_INITIALIZATION) {
-        mHardware->setPreviewWindow(mPreviewWindow);
-#endif
     }
 
     return mHardware->sendCommand(cmd, arg1, arg2);
 }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-// set the SurfaceTexture that the preview will use
-status_t CameraService::Client::setBufferSource(
-        const sp<ISurfaceTexture>& tapin,
-        const sp<ISurfaceTexture>& tapout) {
-    LOG1("setBufferSource(%p,%p) (pid %d)", tapin.get(), tapout.get(),
-            getCallingPid());
-
-    sp<IBinder> tapinBinder, tapoutBinder;
-    sp<ANativeWindow> tapinWindow, tapoutWindow;
-    status_t result = NO_ERROR;
-
-    Mutex::Autolock lock(mLock);
-
-    if (tapin != 0) {
-        tapinBinder = tapin->asBinder();
-        tapinWindow = new SurfaceTextureClient(tapin);
-    }
-
-    if (tapout != 0) {
-        tapoutBinder = tapout->asBinder();
-        tapoutWindow = new SurfaceTextureClient(tapout);
-    }
-
-    result = checkPidAndHardware();
-    if (result != NO_ERROR) return result;
-
-    // return if we already set this buffer source
-    if (tapinBinder == mTapin && tapoutBinder == mTapout) {
-        return NO_ERROR;
-    }
-
-    // need to connect tap out since camera will be FILLING those buffers
-    if (tapoutWindow != 0) {
-        result = native_window_api_connect(tapoutWindow.get(), NATIVE_WINDOW_API_CAMERA);
-        if (result != NO_ERROR) {
-            ALOGE("native_window_api_connect failed: %s (%d)", strerror(-result), result);
-            return result;
-        }
-    }
-
-    if (tapoutWindow != 0 || tapinWindow !=0) {
-        result = mHardware->setBufferSource(tapinWindow, tapoutWindow);
-    }
-
-    if (result == NO_ERROR) {
-        // Everything has succeeded.  Disconnect the old window and remember the new window.
-        disconnectWindow(mTapoutClient);
-        mTapin = tapinBinder;
-        mTapinClient = tapinWindow;
-        mTapout = tapoutBinder;
-        mTapoutClient = tapoutWindow;
-    } else {
-        // Something went wrong after we connected to the new window, so
-        // disconnect here.
-        disconnectWindow(tapoutWindow);
-    }
-
-    return result;
-}
-
-// reprocess - image is returned in callback
-status_t CameraService::Client::reprocess(int msgType, const String8& params) {
-    LOG1("reprocess (pid %d): 0x%x", getCallingPid(), msgType);
-
-    Mutex::Autolock lock(mLock);
-    status_t result = checkPidAndHardware();
-    if (result != NO_ERROR) return result;
-
-    if ((msgType & CAMERA_MSG_RAW_IMAGE) &&
-        (msgType & CAMERA_MSG_RAW_IMAGE_NOTIFY)) {
-        ALOGE("CAMERA_MSG_RAW_IMAGE and CAMERA_MSG_RAW_IMAGE_NOTIFY"
-                " cannot be both enabled");
-        return BAD_VALUE;
-    }
-
-    // We only accept picture related message types
-    // and ignore other types of messages for takePicture().
-    int picMsgType = msgType
-                        & (CAMERA_MSG_SHUTTER |
-                           CAMERA_MSG_POSTVIEW_FRAME |
-                           CAMERA_MSG_RAW_IMAGE |
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-                           CAMERA_MSG_RAW_BURST |
-#endif
-                           CAMERA_MSG_RAW_IMAGE_NOTIFY |
-                           CAMERA_MSG_COMPRESSED_IMAGE);
-
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-    picMsgType |= CAMERA_MSG_COMPRESSED_BURST_IMAGE;
-#endif
-
-    enableMsgType(picMsgType);
-
-    // make sure the other capture messages are disabled
-    picMsgType = ~picMsgType &
-                 (CAMERA_MSG_SHUTTER |
-                  CAMERA_MSG_POSTVIEW_FRAME |
-                  CAMERA_MSG_RAW_IMAGE |
-                  CAMERA_MSG_RAW_IMAGE_NOTIFY |
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-                  CAMERA_MSG_RAW_BURST |
-                  CAMERA_MSG_COMPRESSED_BURST_IMAGE |
-#endif
-                  CAMERA_MSG_COMPRESSED_IMAGE);
-    disableMsgType(picMsgType);
-
-    return mHardware->reprocess(params);
-}
-#endif
-
 // ----------------------------------------------------------------------------
 
 void CameraService::Client::enableMsgType(int32_t msgType) {
@@ -1229,11 +1059,6 @@ void CameraService::Client::dataCallback(int32_t msgType,
         case CAMERA_MSG_COMPRESSED_IMAGE:
             client->handleCompressedPicture(dataPtr);
             break;
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-        case CAMERA_MSG_COMPRESSED_BURST_IMAGE:
-            client->handleCompressedBurstPicture(dataPtr);
-            break;
-#endif
         default:
             client->handleGenericData(msgType, dataPtr, metadata);
             break;
@@ -1362,20 +1187,6 @@ void CameraService::Client::handleCompressedPicture(const sp<IMemory>& mem) {
     }
 }
 
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-// burst picture callback - compressed picture ready
-void CameraService::Client::handleCompressedBurstPicture(const sp<IMemory>& mem) {
-    // Don't disable this message type yet. In this mode takePicture() will
-    // get called only once. When burst finishes this message will get automatically
-    // disabled in the respective call for restarting the preview.
-
-    sp<ICameraClient> c = mCameraClient;
-    mLock.unlock();
-    if (c != 0) {
-        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, mem, NULL);
-    }
-}
-#endif
 
 void CameraService::Client::handleGenericNotify(int32_t msgType,
     int32_t ext1, int32_t ext2) {
diff --git a/./frameworks/av/services/camera/libcameraservice/CameraService.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/camera/libcameraservice/CameraService.h
index a0c532c..95ac197 100644
--- a/./frameworks/av/services/camera/libcameraservice/CameraService.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/av/services/camera/libcameraservice/CameraService.h
@@ -23,11 +23,7 @@
 #include <hardware/camera.h>
 
 /* This needs to be increased if we can have more cameras */
-#ifdef OMAP_ENHANCEMENT
-#define MAX_CAMERAS 4
-#else
 #define MAX_CAMERAS 2
-#endif
 
 namespace android {
 
@@ -111,21 +107,10 @@ private:
         virtual void            releaseRecordingFrame(const sp<IMemory>& mem);
         virtual status_t        autoFocus();
         virtual status_t        cancelAutoFocus();
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        virtual status_t        takePicture(int msgType, const String8& params);
-#else
         virtual status_t        takePicture(int msgType);
-#endif
         virtual status_t        setParameters(const String8& params);
         virtual String8         getParameters() const;
         virtual status_t        sendCommand(int32_t cmd, int32_t arg1, int32_t arg2);
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        virtual status_t        setBufferSource(const sp<ISurfaceTexture>& tapin,
-                                                const sp<ISurfaceTexture>& tapout);
-        virtual status_t        reprocess(int msgType, const String8& params);
-#endif
-
     private:
         friend class CameraService;
                                 Client(const sp<CameraService>& cameraService,
@@ -174,9 +159,6 @@ private:
         void                    handlePostview(const sp<IMemory>& mem);
         void                    handleRawPicture(const sp<IMemory>& mem);
         void                    handleCompressedPicture(const sp<IMemory>& mem);
-#ifdef OMAP_ENHANCEMENT_BURST_CAPTURE
-        void                    handleCompressedBurstPicture(const sp<IMemory>& mem);
-#endif
         void                    handleGenericNotify(int32_t msgType, int32_t ext1, int32_t ext2);
         void                    handleGenericData(int32_t msgType, const sp<IMemory>& dataPtr,
                                                   camera_frame_metadata_t *metadata);
@@ -217,14 +199,6 @@ private:
         sp<IBinder>                     mSurface;
         sp<ANativeWindow>               mPreviewWindow;
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        // This is a binder of Surface or SurfaceTexture.
-        sp<IBinder>                     mTapin;
-        sp<ANativeWindow>               mTapinClient;
-        sp<IBinder>                     mTapout;
-        sp<ANativeWindow>               mTapoutClient;
-#endif
-
         // If the user want us to return a copy of the preview frame (instead
         // of the original one), we allocate mPreviewBuffer and reuse it if possible.
         sp<MemoryHeapBase>              mPreviewBuffer;
diff --git a/./frameworks/base/cmds/am/src/com/android/commands/am/Am.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/cmds/am/src/com/android/commands/am/Am.java
index 05d2df6..54b5836 100644
--- a/./frameworks/base/cmds/am/src/com/android/commands/am/Am.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/cmds/am/src/com/android/commands/am/Am.java
@@ -186,11 +186,6 @@ public class Am {
             } else if (opt.equals("--esn")) {
                 String key = nextArgRequired();
                 intent.putExtra(key, (String) null);
-            } else if (SystemProperties.OMAP_ENHANCEMENT && opt.equals("--ent")) {
-                String key = nextArgRequired();
-                String act = nextArgRequired();
-                String value = nextArgRequired();
-                intent.putExtra(key, new Intent(act, Uri.parse(value)));
             } else if (opt.equals("--ei")) {
                 String key = nextArgRequired();
                 String value = nextArgRequired();
@@ -1375,12 +1370,7 @@ public class Am {
                 "    [--ecn <EXTRA_KEY> <EXTRA_COMPONENT_NAME_VALUE>]\n" +
                 "    [--eia <EXTRA_KEY> <EXTRA_INT_VALUE>[,<EXTRA_INT_VALUE...]]\n" +
                 "    [--ela <EXTRA_KEY> <EXTRA_LONG_VALUE>[,<EXTRA_LONG_VALUE...]]\n" +
-                "    [--efa <EXTRA_KEY> <EXTRA_FLOAT_VALUE>[,<EXTRA_FLOAT_VALUE...]]\n"
-                );
-        if (SystemProperties.OMAP_ENHANCEMENT) {
-            System.err.println("    [--ent <EXTRA_KEY> <EXTRA_SUBINTENT_ACTION> <SUBINTENT_URI_DATA>]\n");
-        }
-        System.err.println(
+                "    [--efa <EXTRA_KEY> <EXTRA_FLOAT_VALUE>[,<EXTRA_FLOAT_VALUE...]]\n" +
                 "    [-n <COMPONENT>] [-f <FLAGS>]\n" +
                 "    [--grant-read-uri-permission] [--grant-write-uri-permission]\n" +
                 "    [--debug-log-resolution] [--exclude-stopped-packages]\n" +
diff --git a/./frameworks/base/core/java/android/os/Process.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/os/Process.java
index 224a99f..8eaeb1d 100644
--- a/./frameworks/base/core/java/android/os/Process.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/os/Process.java
@@ -116,12 +116,6 @@ public class Process {
     public static final int NFC_UID = 1027;
 
     /**
-     * Defines the UID/GID for the FM Radio service process.
-     * @hide
-     */
-    public static final int FMRADIO_UID = 1029;
-
-    /**
      * Defines the GID for the group that allows write access to the internal media storage.
      * @hide
      */
diff --git a/./frameworks/base/core/java/android/os/SystemProperties.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/os/SystemProperties.java
index 098dcc6..156600e 100644
--- a/./frameworks/base/core/java/android/os/SystemProperties.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/os/SystemProperties.java
@@ -31,7 +31,6 @@ public class SystemProperties
 {
     public static final int PROP_NAME_MAX = 31;
     public static final int PROP_VALUE_MAX = 91;
-    public static final boolean OMAP_ENHANCEMENT = native_get_boolean("com.ti.omap_enhancement", false);
 
     private static final ArrayList<Runnable> sChangeCallbacks = new ArrayList<Runnable>();
 
diff --git a/./frameworks/base/core/java/android/server/BluetoothService.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/server/BluetoothService.java
index 170fb33..97c0209 100755
--- a/./frameworks/base/core/java/android/server/BluetoothService.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/server/BluetoothService.java
@@ -55,7 +55,6 @@ import android.os.ParcelFileDescriptor;
 import android.os.ParcelUuid;
 import android.os.RemoteException;
 import android.os.ServiceManager;
-import android.os.SystemProperties;
 import android.provider.Settings;
 import android.util.Log;
 import android.util.Pair;
@@ -2440,15 +2439,7 @@ public class BluetoothService extends IBluetooth.Stub {
     BluetoothDeviceProfileState addProfileState(String address, boolean setTrust) {
         BluetoothDeviceProfileState state =
             new BluetoothDeviceProfileState(mContext, address, this, mA2dpService, setTrust);
-        if (SystemProperties.OMAP_ENHANCEMENT) {
-            BluetoothDeviceProfileState oldStateMachine  = mDeviceProfileState.put(address, state);
-            if (oldStateMachine != null) {
-                oldStateMachine.quit();
-                oldStateMachine = null;
-            }
-        } else {
-            mDeviceProfileState.put(address, state);
-        }
+        mDeviceProfileState.put(address, state);
         state.start();
         return state;
     }
diff --git a/./frameworks/base/core/java/android/view/Display.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/view/Display.java
index 682ac41..c947312 100644
--- a/./frameworks/base/core/java/android/view/Display.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/view/Display.java
@@ -22,7 +22,6 @@ import android.graphics.Rect;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.SystemClock;
-import android.os.SystemProperties;
 import android.util.DisplayMetrics;
 import android.util.Slog;
 
@@ -379,16 +378,7 @@ public class Display {
      * @hide
      */
     public int getRawExternalWidth() {
-        if (SystemProperties.OMAP_ENHANCEMENT) {
-            int primaryTv = SystemProperties.getInt("persist.hwc.primary.tv", 0);
-            if (primaryTv == 1) {
-                return getRawWidth();
-            } else {
-                return getMirroringRegion().width();
-            }
-        } else {
-            return 1280;
-        }
+        return 1280;
     }
 
     /**
@@ -397,27 +387,7 @@ public class Display {
      * @hide
      */
     public int getRawExternalHeight() {
-        if (SystemProperties.OMAP_ENHANCEMENT) {
-            int primaryTv = SystemProperties.getInt("persist.hwc.primary.tv", 0);
-            if (primaryTv == 1) {
-                return getRawHeight();
-            } else {
-                return getMirroringRegion().height();
-            }
-        } else {
-            return 720;
-        }
-    }
-
-    /**
-     * Gets maximal supported texture size.
-     * @hide
-     */
-    public int getMaximumTextureSize() {
-        if (SystemProperties.OMAP_ENHANCEMENT) {
-            return mMaximumTextureSize;
-        }
-        return -1;
+        return 720;
     }
 
     /**
@@ -464,40 +434,6 @@ public class Display {
     
     private native void init(int display);
 
-    /**
-     * If the display is mirrored to an external HDMI display, returns the
-     * region that has to be mirrored on that display.
-     * @hide
-     */
-    private Rect getMirroringRegion() {
-        if (SystemProperties.OMAP_ENHANCEMENT) {
-            if (mMirroringRegion.width() == 0) {
-                mMirroringRegion.set(0, 0, 1280, 720);
-
-                String[] values = SystemProperties.get("persist.hwc.mirroring.region", "").split(":");
-
-                if (values.length == 4) {
-                    try {
-                        int left = Integer.parseInt(values[0]);
-                        int top = Integer.parseInt(values[1]);
-                        int right = Integer.parseInt(values[2]);
-                        int bottom = Integer.parseInt(values[3]);
-
-                        if (left >= right || top >= bottom) {
-                            throw new NumberFormatException();
-                        }
-
-                        mMirroringRegion.set(left, top, right, bottom);
-                    } catch (NumberFormatException e) {
-                    }
-                }
-
-                Slog.i(TAG, "Mirroring region is " + mMirroringRegion);
-            }
-        }
-        return mMirroringRegion;
-    }
-
     private final CompatibilityInfoHolder mCompatibilityInfo;
     private final int   mDisplay;
     // Following fields are initialized from native code
@@ -506,8 +442,6 @@ public class Display {
     /*package*/ float   mDensity;
     /*package*/ float   mDpiX;
     /*package*/ float   mDpiY;
-    private Rect        mMirroringRegion = new Rect();
-    private int         mMaximumTextureSize;
     
     private final Point mTmpPoint = new Point();
     private final DisplayMetrics mTmpMetrics = new DisplayMetrics();
diff --git a/./frameworks/base/core/java/android/widget/MediaController.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/widget/MediaController.java
index 6fd6cd6..fc35f05 100644
--- a/./frameworks/base/core/java/android/widget/MediaController.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/java/android/widget/MediaController.java
@@ -40,9 +40,6 @@ import com.android.internal.policy.PolicyManager;
 import java.util.Formatter;
 import java.util.Locale;
 
-import android.os.SystemClock;
-import android.os.SystemProperties;
-
 /**
  * A view containing controls for a MediaPlayer. Typically contains the
  * buttons like "Play/Pause", "Rewind", "Fast Forward" and a progress
@@ -99,7 +96,6 @@ public class MediaController extends FrameLayout {
     private ImageButton         mRewButton;
     private ImageButton         mNextButton;
     private ImageButton         mPrevButton;
-    private long                mLastSeekEventTime;
 
     public MediaController(Context context, AttributeSet attrs) {
         super(context, attrs);
@@ -535,7 +531,6 @@ public class MediaController extends FrameLayout {
     // we will simply apply the updated position without suspending regular updates.
     private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {
         public void onStartTrackingTouch(SeekBar bar) {
-            mLastSeekEventTime = 0;
             show(3600000);
 
             mDragging = true;
@@ -555,23 +550,11 @@ public class MediaController extends FrameLayout {
                 return;
             }
 
-            if (SystemProperties.OMAP_ENHANCEMENT) {
-                long now = SystemClock.elapsedRealtime();
-                if ((now - mLastSeekEventTime) > 250) {
-                    mLastSeekEventTime = now;
-                    long duration = mPlayer.getDuration();
-                    long newposition = (duration * progress) / 1000L;
-                    mPlayer.seekTo( (int) newposition);
-                    if (mCurrentTime != null)
-                        mCurrentTime.setText(stringForTime( (int) newposition));
-                }
-            } else {
-                long duration = mPlayer.getDuration();
-                long newposition = (duration * progress) / 1000L;
-                mPlayer.seekTo( (int) newposition);
-                if (mCurrentTime != null)
-                    mCurrentTime.setText(stringForTime( (int) newposition));
-            }
+            long duration = mPlayer.getDuration();
+            long newposition = (duration * progress) / 1000L;
+            mPlayer.seekTo( (int) newposition);
+            if (mCurrentTime != null)
+                mCurrentTime.setText(stringForTime( (int) newposition));
         }
 
         public void onStopTrackingTouch(SeekBar bar) {
diff --git a/./frameworks/base/core/jni/android_view_Display.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/jni/android_view_Display.cpp
index 09b2404..aedf1e4 100644
--- a/./frameworks/base/core/jni/android_view_Display.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/core/jni/android_view_Display.cpp
@@ -43,9 +43,6 @@ struct offsets_t {
     jfieldID density;
     jfieldID xdpi;
     jfieldID ydpi;
-#ifdef OMAP_ENHANCEMENT
-    jfieldID maxTex;
-#endif
 };
 static offsets_t offsets;
 static bool headless = false;
@@ -75,9 +72,6 @@ static void android_view_Display_init(
     env->SetFloatField(clazz, offsets.density,  info.density);
     env->SetFloatField(clazz, offsets.xdpi,     info.xdpi);
     env->SetFloatField(clazz, offsets.ydpi,     info.ydpi);
-#ifdef OMAP_ENHANCEMENT
-    env->SetIntField(clazz, offsets.maxTex,     info.maxTex);
-#endif
 }
 
 static jint android_view_Display_getRawWidthNative(
@@ -146,9 +140,6 @@ void nativeClassInit(JNIEnv* env, jclass clazz)
     offsets.density     = env->GetFieldID(clazz, "mDensity", "F");
     offsets.xdpi        = env->GetFieldID(clazz, "mDpiX", "F");
     offsets.ydpi        = env->GetFieldID(clazz, "mDpiY", "F");
-#ifdef OMAP_ENHANCEMENT
-    offsets.maxTex      = env->GetFieldID(clazz, "mMaximumTextureSize", "I");
-#endif
 }
 
 int register_android_view_Display(JNIEnv* env)
diff --git a/./frameworks/base/media/java/android/media/AudioService.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/AudioService.java
index 584b1db..2e153dd 100644
--- a/./frameworks/base/media/java/android/media/AudioService.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/AudioService.java
@@ -173,9 +173,6 @@ public class AudioService extends IAudioService.Stub implements OnFinished {
 
     private boolean mMediaServerOk;
 
-    private static final String ACTION_FMRx_PLUG = "ti.android.intent.action.FMRx_PLUG";
-    private static final String ACTION_FMTx_PLUG = "ti.android.intent.action.FMTx_PLUG";
-
     private SoundPool mSoundPool;
     private final Object mSoundEffectsLock = new Object();
     private static final int NUM_SOUNDPOOL_CHANNELS = 4;
@@ -470,10 +467,6 @@ public class AudioService extends IAudioService.Stub implements OnFinished {
         intentFilter.addAction(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG);
         intentFilter.addAction(Intent.ACTION_USB_AUDIO_DEVICE_PLUG);
         intentFilter.addAction(Intent.ACTION_BOOT_COMPLETED);
-        if ( SystemProperties.OMAP_ENHANCEMENT) {
-           intentFilter.addAction(ACTION_FMRx_PLUG);
-           intentFilter.addAction(ACTION_FMTx_PLUG);
-        }
         intentFilter.addAction(Intent.ACTION_SCREEN_ON);
         intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
 
@@ -3457,34 +3450,6 @@ public class AudioService extends IAudioService.Stub implements OnFinished {
                         }
                     }
                 }
-            } else if ( SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_FMRx_PLUG)) {
-               state = intent.getIntExtra("state",0);
-               Log.i(TAG,"Broadcast Receiver: Got ACTION_FMRx_PLUG, state ="+state);
-               boolean isConnected =
-                   mConnectedDevices.containsKey(AudioSystem.DEVICE_IN_FM_RADIO_RX );
-               if (state == 0 && isConnected) {
-                      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_FM_RADIO_RX ,
-                               AudioSystem.DEVICE_STATE_UNAVAILABLE,"");
-                      mConnectedDevices.remove(AudioSystem.DEVICE_IN_FM_RADIO_RX );
-               } else if (state == 1 && !isConnected)  {
-                      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_FM_RADIO_RX ,
-                                AudioSystem.DEVICE_STATE_AVAILABLE,"");
-                      mConnectedDevices.put( new Integer(AudioSystem.DEVICE_IN_FM_RADIO_RX ), "");
-               }
-            } else if ( SystemProperties.OMAP_ENHANCEMENT && action.equals(ACTION_FMTx_PLUG)) {
-                state = intent.getIntExtra("state",0);
-                Log.i(TAG,"Broadcast Receiver: Got Action_FMTx_PLUG, state ="+state);
-                boolean isConnected =
-                   mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_FM_RADIO_TX );
-                if (state == 0 && isConnected) {
-                       AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_RADIO_TX ,
-                                AudioSystem.DEVICE_STATE_UNAVAILABLE,"");
-                       mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_RADIO_TX );
-                } else if (state == 1 && !isConnected)  {
-                       AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_RADIO_TX ,
-                                 AudioSystem.DEVICE_STATE_AVAILABLE,"");
-                       mConnectedDevices.put( new Integer(AudioSystem.DEVICE_OUT_FM_RADIO_TX ), "");
-                }
             } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ||
                            action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
                 state = intent.getIntExtra("state", 0);
diff --git a/./frameworks/base/media/java/android/media/AudioSystem.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/AudioSystem.java
index 9dee731..1ca0df4 100644
--- a/./frameworks/base/media/java/android/media/AudioSystem.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/AudioSystem.java
@@ -204,7 +204,7 @@ public class AudioSystem
     public static final int DEVICE_OUT_DGTL_DOCK_HEADSET = 0x1000;
     public static final int DEVICE_OUT_USB_ACCESSORY = 0x2000;
     public static final int DEVICE_OUT_USB_DEVICE = 0x4000;
-    public static final int DEVICE_OUT_FM_RADIO_TX = 0x20000000;
+
     public static final int DEVICE_OUT_DEFAULT = 0x8000;
     public static final int DEVICE_OUT_ALL = (DEVICE_OUT_EARPIECE |
                                               DEVICE_OUT_SPEAKER |
@@ -240,7 +240,6 @@ public class AudioSystem
     public static final int DEVICE_IN_BLUETOOTH_SCO_HEADSET = 0x200000;
     public static final int DEVICE_IN_WIRED_HEADSET = 0x400000;
     public static final int DEVICE_IN_AUX_DIGITAL = 0x800000;
-    public static final int DEVICE_IN_FM_RADIO_RX = 0x2000000;
     public static final int DEVICE_IN_DEFAULT = 0x80000000;
 
     // device states, must match AudioSystem::device_connection_state
diff --git a/./frameworks/base/media/java/android/media/DecoderCapabilities.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/DecoderCapabilities.java
index 817fcd3..f16cccf 100644
--- a/./frameworks/base/media/java/android/media/DecoderCapabilities.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/DecoderCapabilities.java
@@ -33,7 +33,6 @@ public class DecoderCapabilities
      */
     public enum VideoDecoder {
         VIDEO_DECODER_WMV,
-        VIDEO_DECODER_MPEG2,
     };
 
     /**
diff --git a/./frameworks/base/media/java/android/media/MediaFile.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/MediaFile.java
index a21db77..c9bec18 100644
--- a/./frameworks/base/media/java/android/media/MediaFile.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/MediaFile.java
@@ -24,7 +24,6 @@ import android.media.DecoderCapabilities;
 import android.media.DecoderCapabilities.VideoDecoder;
 import android.media.DecoderCapabilities.AudioDecoder;
 import android.mtp.MtpConstants;
-import android.os.SystemProperties;
 
 import java.util.HashMap;
 import java.util.Iterator;
@@ -211,20 +210,10 @@ public class MediaFile {
         addFileType("AVI", FILE_TYPE_AVI, "video/avi");
 
         if (isWMVEnabled()) {
-            if(SystemProperties.OMAP_ENHANCEMENT) {
-                addFileType("WMV", FILE_TYPE_WMV, "video/asf", MtpConstants.FORMAT_WMV);
-            } else {
-                addFileType("WMV", FILE_TYPE_WMV, "video/x-ms-wmv", MtpConstants.FORMAT_WMV);
-            }
+            addFileType("WMV", FILE_TYPE_WMV, "video/x-ms-wmv", MtpConstants.FORMAT_WMV);
             addFileType("ASF", FILE_TYPE_ASF, "video/x-ms-asf");
         }
 
-        if(SystemProperties.OMAP_ENHANCEMENT) {
-            addFileType("WMA", FILE_TYPE_WMA, "audio/x-ms-wma");
-            addFileType("WMV", FILE_TYPE_WMV, "video/asf");
-            addFileType("ASF", FILE_TYPE_ASF, "video/asf");
-        }
-
         addFileType("JPG", FILE_TYPE_JPEG, "image/jpeg", MtpConstants.FORMAT_EXIF_JPEG);
         addFileType("JPEG", FILE_TYPE_JPEG, "image/jpeg", MtpConstants.FORMAT_EXIF_JPEG);
         addFileType("GIF", FILE_TYPE_GIF, "image/gif", MtpConstants.FORMAT_GIF);
diff --git a/./frameworks/base/media/java/android/media/MediaRecorder.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/MediaRecorder.java
index 0b6f2fc..9af201d 100644
--- a/./frameworks/base/media/java/android/media/MediaRecorder.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/java/android/media/MediaRecorder.java
@@ -27,8 +27,6 @@ import java.io.FileDescriptor;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
-import android.os.SystemProperties;
-
 
 /**
  * Used to record audio and video. The recording control is based on a
@@ -333,21 +331,6 @@ public class MediaRecorder
             setAudioSamplingRate(profile.audioSampleRate);
             setAudioEncoder(profile.audioCodec);
         }
-
-        if(SystemProperties.OMAP_ENHANCEMENT) {
-            // Set Encoder Profile  from system properties for H264 Encoder
-            if(profile.videoCodec == MediaRecorder.VideoEncoder.H264){
-                String encProfile;
-                encProfile = SystemProperties.get("video.h264enc.profile");
-                if(encProfile.equals("1") ||encProfile.equals("2") || encProfile.equals("8")) {
-                    Log.v(TAG,"Profile read is : " + encProfile);
-                }else{
-                    Log.v(TAG," Profile is not set or is Invalid .. So setting Baseline as Default");
-                    encProfile = "1";
-                }
-                setParameter(String.format("video-param-encoder-profile="+encProfile));
-            }
-        }
     }
 
     /**
diff --git a/./frameworks/base/media/jni/mediaeditor/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/jni/mediaeditor/Android.mk
index da0d272..040d2ab 100755
--- a/./frameworks/base/media/jni/mediaeditor/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/media/jni/mediaeditor/Android.mk
@@ -44,12 +44,7 @@ LOCAL_C_INCLUDES += \
     $(TOP)/frameworks/av/libvideoeditor/vss/stagefrightshells/inc \
     $(TOP)/frameworks/av/libvideoeditor/lvpp \
     $(TOP)/frameworks/av/libvideoeditor/osal/inc \
-
-ifdef OMAP_ENHANCEMENT
-LOCAL_C_INCLUDES += $(DOMX_PATH)/omx_core/inc
-else
-LOCAL_C_INCLUDES += $(TOP)/frameworks/native/include/media/openmax
-endif
+    $(TOP)/frameworks/native/include/media/openmax
 
 LOCAL_SHARED_LIBRARIES := \
     libandroid_runtime \
diff --git a/./frameworks/base/packages/SystemUI/src/com/android/systemui/ImageWallpaper.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/packages/SystemUI/src/com/android/systemui/ImageWallpaper.java
index f39c245..96f83c6 100644
--- a/./frameworks/base/packages/SystemUI/src/com/android/systemui/ImageWallpaper.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/packages/SystemUI/src/com/android/systemui/ImageWallpaper.java
@@ -20,9 +20,7 @@ import android.app.ActivityManager;
 import android.app.WallpaperManager;
 import android.content.BroadcastReceiver;
 import android.content.Context;
-import android.content.res.Configuration;
 import android.content.Intent;
-import android.content.IntentFilter;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Rect;
@@ -113,8 +111,6 @@ public class ImageWallpaper extends WallpaperService {
         int mLastXTranslation;
         int mLastYTranslation;
 
-        int mLastOrientation;
-
         private EGL10 mEgl;
         private EGLDisplay mEglDisplay;
         private EGLConfig mEglConfig;
@@ -150,31 +146,11 @@ public class ImageWallpaper extends WallpaperService {
                     Log.d(TAG, "onReceive");
                 }
 
-                if (SystemProperties.OMAP_ENHANCEMENT) {
-                    if (Intent.ACTION_WALLPAPER_CHANGED.equals(intent.getAction())) {
-                        synchronized (mLock) {
-                            mBackgroundWidth = mBackgroundHeight = -1;
-                            mBackground = null;
-                            mRedrawNeeded = true;
-                            drawFrameLocked();
-                        }
-                    } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {
-                        final Configuration newConfig = context.getResources().getConfiguration();
-                        if (mLastOrientation != newConfig.orientation) {
-                            mLastOrientation = newConfig.orientation;
-                            synchronized (mLock) {
-                                mRedrawNeeded = true;
-                                drawFrameLocked();
-                            }
-                        }
-                    }
-                } else {
-                    synchronized (mLock) {
-                        mBackgroundWidth = mBackgroundHeight = -1;
-                        mBackground = null;
-                        mRedrawNeeded = true;
-                        drawFrameLocked();
-                    }
+                synchronized (mLock) {
+                    mBackgroundWidth = mBackgroundHeight = -1;
+                    mBackground = null;
+                    mRedrawNeeded = true;
+                    drawFrameLocked();
                 }
             }
         }
@@ -192,18 +168,11 @@ public class ImageWallpaper extends WallpaperService {
 
             super.onCreate(surfaceHolder);
             
-            if (!SystemProperties.OMAP_ENHANCEMENT) {
-                // TODO: Don't need this currently because the wallpaper service
-                // will restart the image wallpaper whenever the image changes.
-                //IntentFilter filter = new IntentFilter(Intent.ACTION_WALLPAPER_CHANGED);
-                //mReceiver = new WallpaperObserver();
-                //registerReceiver(mReceiver, filter, null, mHandler);
-            } else {
-                IntentFilter filter = new IntentFilter();
-                filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
-                mReceiver = new WallpaperObserver();
-                registerReceiver(mReceiver, filter);
-            }
+            // TODO: Don't need this currently because the wallpaper service
+            // will restart the image wallpaper whenever the image changes.
+            //IntentFilter filter = new IntentFilter(Intent.ACTION_WALLPAPER_CHANGED);
+            //mReceiver = new WallpaperObserver();
+            //registerReceiver(mReceiver, filter, null, mHandler);
 
             updateSurfaceSize(surfaceHolder);
 
diff --git a/./frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java
index 871e9f4..f947369 100644
--- a/./frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/tablet/TabletStatusBar.java
@@ -39,7 +39,6 @@ import android.os.IBinder;
 import android.os.Message;
 import android.os.RemoteException;
 import android.os.ServiceManager;
-import android.os.SystemProperties;
 import android.text.TextUtils;
 import android.util.Slog;
 import android.view.Display;
@@ -225,31 +224,18 @@ public class TabletStatusBar extends BaseStatusBar implements
 
     private void addStatusBarWindow() {
         final View sb = makeStatusBarView();
-        final WindowManager.LayoutParams lp;
-
-        if (!SystemProperties.OMAP_ENHANCEMENT) {
-            lp = new WindowManager.LayoutParams(
-                    ViewGroup.LayoutParams.MATCH_PARENT,
-                    ViewGroup.LayoutParams.MATCH_PARENT,
-                    WindowManager.LayoutParams.TYPE_NAVIGATION_BAR,
-                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+
+        final WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
+                ViewGroup.LayoutParams.MATCH_PARENT,
+                ViewGroup.LayoutParams.MATCH_PARENT,
+                WindowManager.LayoutParams.TYPE_NAVIGATION_BAR,
+                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                     | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING
                     | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH,
-                    // We use a pixel format of RGB565 for the status bar to save memory bandwidth and
-                    // to ensure that the layer can be handled by HWComposer.  On some devices the
-                    // HWComposer is unable to handle SW-rendered RGBX_8888 layers.
-                    PixelFormat.RGB_565);
-        } else {
-            lp = new WindowManager.LayoutParams(
-                    ViewGroup.LayoutParams.MATCH_PARENT,
-                    ViewGroup.LayoutParams.MATCH_PARENT,
-                    WindowManager.LayoutParams.TYPE_NAVIGATION_BAR,
-                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
-                    | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING
-                    | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH
-                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
-                    PixelFormat.OPAQUE);
-        }
+                // We use a pixel format of RGB565 for the status bar to save memory bandwidth and
+                // to ensure that the layer can be handled by HWComposer.  On some devices the
+                // HWComposer is unable to handle SW-rendered RGBX_8888 layers.
+                PixelFormat.RGB_565);
 
         // We explicitly leave FLAG_HARDWARE_ACCELERATED out of the flags.  The status bar occupies
         // very little screen real-estate and is updated fairly frequently.  By using CPU rendering
diff --git a/./frameworks/base/services/java/com/android/server/SUPLLib/SUPLService.java b/./frameworks/base/services/java/com/android/server/SUPLLib/SUPLService.java
deleted file mode 100644
index 6da5c59..0000000
--- a/./frameworks/base/services/java/com/android/server/SUPLLib/SUPLService.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.server;
-
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.text.TextUtils;
-import android.util.Log;
-import android.os.Binder;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Handler;
-import java.io.File;
-import java.io.FileReader;
-
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.InetAddress;
-import java.io.IOException;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.BufferedWriter;
-import java.io.OutputStreamWriter;
-
-/*
- *
- * SUPLService has to be created with providing Binder Interface.
- *
- *
- */
-public class SUPLService extends Binder {
-	private static final String TAG = "SUPLService";
-	private Context mContext;
-	private static SUPLService sServiceInstance;
-
-	/*
-	 * SUPLThread
-	 *
-	 */
-	public static class SUPLThread extends Thread {
-		private Context mContext;
-
-		private SUPLThread(Context context){
-			super("SUPL Thread");
-			mContext = context;
-		}
-
-		@Override
-			public void run(){
-				Looper.prepare();
-				synchronized(this){
-					sServiceInstance = new SUPLService(mContext);
-					notifyAll();
-				}
-				Looper.loop();
-			}
-
-
-		public static SUPLService getServiceInstance(Context context){
-			SUPLThread thread = new SUPLThread(context);
-			thread.start();
-			synchronized(thread){
-				while(sServiceInstance ==  null){
-					try{
-						thread.wait();
-					}catch(InterruptedException ignore){
-						Log.e(TAG,"SUPLService: Unexpected InterruptedException while waiting for SUPLService Thread\n");
-
-					}
-				}
-
-			}
-
-			return sServiceInstance;
-		}
-
-	}
-
-	public static SUPLService getInstance(Context context){
-		return SUPLThread.getServiceInstance(context);
-	}
-
-	private SUPLService(Context context){
-		mContext = context;
-	}
-}
diff --git a/./frameworks/base/services/java/com/android/server/SystemServer.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/services/java/com/android/server/SystemServer.java
index 550d419..9dd4a91 100644
--- a/./frameworks/base/services/java/com/android/server/SystemServer.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/services/java/com/android/server/SystemServer.java
@@ -481,14 +481,7 @@ class ServerThread extends Thread {
             } catch (Throwable e) {
                 reportWtf("starting DeviceStorageMonitor service", e);
             }
-            if(SystemProperties.OMAP_ENHANCEMENT) {
-            try {
-                Slog.i(TAG, "starting SUPL Service (SystemServer)");
-                ServiceManager.addService("SUPL_SERVICE",SUPLService.getInstance(context));
-            } catch (Throwable e) {
-                Slog.e(TAG,"Failure installing SUPL Service", e);
-            }
-            }
+
             try {
                 Slog.i(TAG, "Location Manager");
                 location = new LocationManagerService(context);
diff --git a/./frameworks/base/services/java/com/android/server/WallpaperManagerService.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/services/java/com/android/server/WallpaperManagerService.java
index ad6af31..d97d335 100644
--- a/./frameworks/base/services/java/com/android/server/WallpaperManagerService.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/services/java/com/android/server/WallpaperManagerService.java
@@ -47,7 +47,6 @@ import android.os.ParcelFileDescriptor;
 import android.os.RemoteCallbackList;
 import android.os.ServiceManager;
 import android.os.SystemClock;
-import android.os.SystemProperties;
 import android.os.UserId;
 import android.service.wallpaper.IWallpaperConnection;
 import android.service.wallpaper.IWallpaperEngine;
@@ -530,16 +529,6 @@ class WallpaperManagerService extends IWallpaperManager.Stub {
             throw new IllegalArgumentException("width and height must be > 0");
         }
 
-        if (SystemProperties.OMAP_ENHANCEMENT) {
-            WindowManager wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
-            int maxTextureSize = wm.getDefaultDisplay().getMaximumTextureSize();
-
-            if (maxTextureSize > 0) {
-                if (width > maxTextureSize) width = maxTextureSize;
-                if (height > maxTextureSize) height = maxTextureSize;
-            }
-        }
-
         synchronized (mLock) {
             if (width != wallpaper.width || height != wallpaper.height) {
                 wallpaper.width = width;
diff --git a/./frameworks/base/services/java/com/android/server/pm/PackageManagerService.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/services/java/com/android/server/pm/PackageManagerService.java
index 62cd220..3501e47 100644
--- a/./frameworks/base/services/java/com/android/server/pm/PackageManagerService.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/services/java/com/android/server/pm/PackageManagerService.java
@@ -173,7 +173,6 @@ public class PackageManagerService extends IPackageManager.Stub {
     private static final int RADIO_UID = Process.PHONE_UID;
     private static final int LOG_UID = Process.LOG_UID;
     private static final int NFC_UID = Process.NFC_UID;
-    private static final int FMRADIO_UID = Process.FMRADIO_UID;
 
     private static final boolean GET_CERTIFICATES = true;
 
@@ -882,10 +881,6 @@ public class PackageManagerService extends IPackageManager.Stub {
         mSettings.addSharedUserLPw("android.uid.log", LOG_UID, ApplicationInfo.FLAG_SYSTEM);
         mSettings.addSharedUserLPw("android.uid.nfc", NFC_UID, ApplicationInfo.FLAG_SYSTEM);
 
-        if(SystemProperties.OMAP_ENHANCEMENT) {
-            mSettings.addSharedUserLPw("android.uid.fmradio", FMRADIO_UID, ApplicationInfo.FLAG_SYSTEM);
-        }
-
         String separateProcesses = SystemProperties.get("debug.separate_processes");
         if (separateProcesses != null && separateProcesses.length() > 0) {
             if ("*".equals(separateProcesses)) {
diff --git a/./frameworks/base/telephony/java/com/android/internal/telephony/CommandsInterface.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/telephony/java/com/android/internal/telephony/CommandsInterface.java
index f15640e..f7757b3 100644
--- a/./frameworks/base/telephony/java/com/android/internal/telephony/CommandsInterface.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/telephony/java/com/android/internal/telephony/CommandsInterface.java
@@ -1311,26 +1311,6 @@ public interface CommandsInterface {
 
     void invokeOemRilRequestStrings(String[] strings, Message response);
 
-    /**
-     * OEMRIL_ENHANCEMENT
-     * Subscribes the Handler for OEM unsolisticated messages from the modem.
-     *
-     * @param h: Handler to be invoked on event.
-     * @param what: Messge ID to be assigned to the Message object sent to the handler.
-     * @param obj: User-defined object to be sent to the handler as a part of event.
-     *        ((AsyncResult)Message.obj).userObj will contain this object.
-     */
-    void setOnUnsolOemHookRaw(Handler h, int what, Object obj);
-
-    /**
-     * OEMRIL_ENHANCEMENT
-     * Unsubscribes the Handler from OEM unsolisticated messages.
-     *
-     * @param h: Subscriber identification. Should be the same as it was in
-     *           the setOnUnsolOemHookRaw call.
-     */
-    void unSetOnUnsolOemHookRaw(Handler h);
-
 
     /**
      * Send TERMINAL RESPONSE to the SIM, after processing a proactive command
diff --git a/./frameworks/base/telephony/java/com/android/internal/telephony/Phone.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/telephony/java/com/android/internal/telephony/Phone.java
index bdfe048..d41ce4d 100644
--- a/./frameworks/base/telephony/java/com/android/internal/telephony/Phone.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/telephony/java/com/android/internal/telephony/Phone.java
@@ -1248,26 +1248,6 @@ public interface Phone {
     void invokeOemRilRequestStrings(String[] strings, Message response);
 
     /**
-     * OEMRIL_ENHANCEMENT
-     * Subscribes the Handler for OEM unsolicited messages from the modem.
-     *
-     * @param h: Handler to be invoked on event.
-     * @param what: Messge ID to be assigned to the Message object sent to the handler.
-     * @param obj: User-defined object to be sent to the handler as a part of event.
-     *        ((AsyncResult)Message.obj).userObj will contain this object.
-     */
-    void setOnUnsolOemHookRaw(Handler h, int what, Object obj);
-
-    /**
-     * OEMRIL_ENHANCEMENT
-     * Unsubscribes the Handler from OEM unsolicited messages.
-     *
-     * @param h: Subscriber identification. Should be the same as it was in
-     *           the setOnUnsolOemHookRaw call.
-     */
-    void unSetOnUnsolOemHookRaw(Handler h);
-
-    /**
      * Get the current active Data Call list
      *
      * @param response <strong>On success</strong>, "response" bytes is
diff --git a/./frameworks/base/telephony/java/com/android/internal/telephony/PhoneBase.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/telephony/java/com/android/internal/telephony/PhoneBase.java
index fcde047..2ac9365 100644
--- a/./frameworks/base/telephony/java/com/android/internal/telephony/PhoneBase.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/telephony/java/com/android/internal/telephony/PhoneBase.java
@@ -758,16 +758,6 @@ public abstract class PhoneBase extends Handler implements Phone {
         mCM.invokeOemRilRequestStrings(strings, response);
     }
 
-    // OEMRIL_ENHANCEMENT
-    public void setOnUnsolOemHookRaw(Handler h, int what, Object obj) {
-        mCM.setOnUnsolOemHookRaw(h, what, obj);
-    }
-
-    // OEMRIL_ENHANCEMENT
-    public void unSetOnUnsolOemHookRaw(Handler h) {
-        mCM.unSetOnUnsolOemHookRaw(h);
-    }
-
     public void notifyDataActivity() {
         mNotifier.notifyDataActivity(this);
     }
diff --git a/./frameworks/base/telephony/java/com/android/internal/telephony/PhoneProxy.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/telephony/java/com/android/internal/telephony/PhoneProxy.java
index b6ef57e..1a8b3ca 100644
--- a/./frameworks/base/telephony/java/com/android/internal/telephony/PhoneProxy.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/telephony/java/com/android/internal/telephony/PhoneProxy.java
@@ -677,16 +677,6 @@ public class PhoneProxy extends Handler implements Phone {
         mActivePhone.invokeOemRilRequestStrings(strings, response);
     }
 
-    // OEMRIL_ENHANCEMENT
-    public void setOnUnsolOemHookRaw(Handler h, int what, Object obj) {
-        mActivePhone.setOnUnsolOemHookRaw(h, what, obj);
-    }
-
-    // OEMRIL_ENHANCEMENT
-    public void unSetOnUnsolOemHookRaw(Handler h) {
-        mActivePhone.unSetOnUnsolOemHookRaw(h);
-    }
-
     public void getDataCallList(Message response) {
         mActivePhone.getDataCallList(response);
     }
diff --git a/./frameworks/base/wifi/java/android/net/wifi/WifiStateMachine.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/wifi/java/android/net/wifi/WifiStateMachine.java
index 274ade1..7f8f9ce 100644
--- a/./frameworks/base/wifi/java/android/net/wifi/WifiStateMachine.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/wifi/java/android/net/wifi/WifiStateMachine.java
@@ -3535,13 +3535,6 @@ public class WifiStateMachine extends StateMachine {
                     if (DBG) log("Network connection lost");
                     handleNetworkDisconnect();
                     break;
-                case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
-                    // Disregard auth failure events during WPS connection. The
-                    // EAP sequence is retried several times, and there might be
-                    // failures (especially for wps pin). We will get a WPS_XXX
-                    // event at the end of the sequence anyway.
-                    if (DBG) log("Ignore auth failure during WPS connection");
-                    break;
                 case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
                     //Throw away supplicant state changes when WPS is running.
                     //We will start getting supplicant state changes once we get
diff --git a/./frameworks/base/wifi/java/android/net/wifi/WifiWatchdogStateMachine.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/wifi/java/android/net/wifi/WifiWatchdogStateMachine.java
index c6d3eae..1a42f93 100644
--- a/./frameworks/base/wifi/java/android/net/wifi/WifiWatchdogStateMachine.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/wifi/java/android/net/wifi/WifiWatchdogStateMachine.java
@@ -881,9 +881,6 @@ public class WifiWatchdogStateMachine extends StateMachine {
             //test to avoid any wifi connectivity issues
             loge("ARP test initiation failure: " + se);
             success = true;
-        } catch (IllegalArgumentException ae) {
-            log("ARP test initiation failure: " + ae);
-            success = true;
         }
 
         return success;
diff --git a/./frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pService.java b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pService.java
index 066d308..9e004d0 100644
--- a/./frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pService.java
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pService.java
@@ -1414,9 +1414,6 @@ public class WifiP2pService extends IWifiP2pManager.Stub {
 
     private void stopDhcpServer() {
         try {
-            if (SystemProperties.OMAP_ENHANCEMENT) {
-                mNwService.clearInterfaceAddresses(mInterface);
-            }
             mNwService.stopTethering();
         } catch (Exception e) {
             loge("Error stopping Dhcp server" + e);
diff --git a/./frameworks/native/cmds/surfaceflinger/main_surfaceflinger.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/cmds/surfaceflinger/main_surfaceflinger.cpp
index cc6f8a6..28e58e4 100644
--- a/./frameworks/native/cmds/surfaceflinger/main_surfaceflinger.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/cmds/surfaceflinger/main_surfaceflinger.cpp
@@ -17,18 +17,10 @@
 #include <binder/BinderService.h>
 #include <SurfaceFlinger.h>
 
-#ifdef OMAP_ENHANCEMENT_S3D
-#include <S3DSurfaceFlinger.h>
-#endif
-
 using namespace android;
 
 int main(int argc, char** argv) {
-#ifdef OMAP_ENHANCEMENT_S3D
-    BinderService<S3DSurfaceFlinger>::publishAndJoinThreadPool();
-#else
     SurfaceFlinger::publishAndJoinThreadPool(true);
-#endif
     // When SF is launched in its own process, limit the number of
     // binder threads to 4.
     ProcessState::self()->setThreadPoolMaxThreadCount(4);
diff --git a/./frameworks/native/include/gui/BufferQueue.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/gui/BufferQueue.h
index 73d157e..1c80d0c 100644
--- a/./frameworks/native/include/gui/BufferQueue.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/gui/BufferQueue.h
@@ -125,14 +125,8 @@ public:
     // nanoseconds, and must be monotonically increasing. Its other semantics
     // (zero point, etc) are client-dependent and should be documented by the
     // client.
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    virtual status_t queueBuffer(int buf,
-            const QueueBufferInput& input, QueueBufferOutput* output,
-            const sp<IMemory>& metadata);
-#else
     virtual status_t queueBuffer(int buf,
             const QueueBufferInput& input, QueueBufferOutput* output);
-#endif
 
     virtual void cancelBuffer(int buf);
 
@@ -199,17 +193,6 @@ public:
 
         // mBuf is the slot index of this buffer
         int mBuf;
-
-#ifdef OMAP_ENHANCEMENT
-        // layout for the buffers
-        uint32_t mLayout;
-#endif
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        // mMetadata is a shared memory containing camera_metadata_t for this
-        // slot. Content of metadata may be different dependeing on usecase.
-        sp<IMemory> mMetadata;
-#endif
     };
 
     // The following public functions is the consumer facing interface
@@ -274,11 +257,6 @@ public:
     // setTransformHint bakes in rotation to buffers so overlays can be used
     status_t setTransformHint(uint32_t hint);
 
-#ifdef OMAP_ENHANCEMENT
-    //sets the layout for the buffers
-    status_t setLayout(uint32_t layout);
-#endif
-
 private:
     // freeBufferLocked frees the resources (both GraphicBuffer and EGLImage)
     // for the given slot.
@@ -398,17 +376,6 @@ private:
 
         // Indicates whether this buffer needs to be cleaned up by consumer
         bool mNeedsCleanupOnRelease;
-
-#ifdef OMAP_ENHANCEMENT
-       // next layout for the buffers
-       uint32_t mLayout;
-#endif
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        // mMetadata is a shared memory containing camera_metadata_t for this
-        // slot. Content of metadata may be different dependeing on usecase.
-        sp<IMemory> mMetadata;
-#endif
     };
 
     // mSlots is the array of buffer slots that must be mirrored on the client
@@ -502,11 +469,6 @@ private:
     // with the surface Texture.
     uint64_t mFrameCounter;
 
-#ifdef OMAP_ENHANCEMENT
-    // next layout for the buffers
-    uint32_t mNextLayout;
-#endif
-
     // mBufferHasBeenQueued is true once a buffer has been queued.  It is reset
     // by changing the buffer count.
     bool mBufferHasBeenQueued;
@@ -520,19 +482,6 @@ private:
 
     // mTransformHint is used to optimize for screen rotations
     uint32_t mTransformHint;
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-public:
-    // updateAndGetCurrent() updates to the current buffer and returns.
-    virtual status_t updateAndGetCurrent(sp<GraphicBuffer>* buf);
-
-    // addBufferSlot() adds the provided buffer to the buffer slots array.
-    virtual int addBufferSlot(const sp<GraphicBuffer>& buffer);
-
-    // getBuffer() allows consumer to get a BufferItem for particular
-    // slot without getting a reference to it.
-    status_t getBuffer(int slot, BufferItem *buffer);
-#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/./frameworks/native/include/gui/ISurfaceTexture.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/gui/ISurfaceTexture.h
index f7b16de..1e33764 100644
--- a/./frameworks/native/include/gui/ISurfaceTexture.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/gui/ISurfaceTexture.h
@@ -28,10 +28,6 @@
 #include <ui/GraphicBuffer.h>
 #include <ui/Rect.h>
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-#include <binder/IMemory.h>
-#endif
-
 namespace android {
 // ----------------------------------------------------------------------------
 
@@ -133,14 +129,8 @@ protected:
         uint32_t numPendingBuffers;
     };
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    virtual status_t queueBuffer(int slot,
-            const QueueBufferInput& input, QueueBufferOutput* output,
-            const sp<IMemory>& metadata) = 0;
-#else
     virtual status_t queueBuffer(int slot,
             const QueueBufferInput& input, QueueBufferOutput* output) = 0;
-#endif
 
     // cancelBuffer indicates that the client does not wish to fill in the
     // buffer associated with slot and transfers ownership of the slot back to
@@ -179,20 +169,6 @@ protected:
     // This method will fail if the the SurfaceTexture is not currently
     // connected to the specified client API.
     virtual status_t disconnect(int api) = 0;
-
-#ifdef OMAP_ENHANCEMENT
-    //method to set the buffer layout
-    virtual status_t setLayout(uint32_t layout) = 0;
-#endif
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    // updateAndGetCurrent gets the latest buffer and gives the ownership
-    // of the buffer to the client
-    virtual status_t updateAndGetCurrent(sp<GraphicBuffer>* buf) = 0;
-
-    // addBufferSlot() adds the provided buffer to the buffer slots array.
-    virtual int addBufferSlot(const sp<GraphicBuffer>& buffer) = 0;
-#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/./frameworks/native/include/gui/SurfaceTexture.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/gui/SurfaceTexture.h
index b54eaec..2635e2f 100644
--- a/./frameworks/native/include/gui/SurfaceTexture.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/gui/SurfaceTexture.h
@@ -225,13 +225,6 @@ public:
     virtual void dump(String8& result) const;
     virtual void dump(String8& result, const char* prefix, char* buffer, size_t SIZE) const;
 
-#ifdef OMAP_ENHANCEMENT
-    //sets the layout for the buffers
-    virtual status_t setLayout(uint32_t layout);
-    // getCurrentLayout returns the layout of the current buffer
-    uint32_t getCurrentLayout() const;
-#endif
-
 protected:
 
     // Implementation of the BufferQueue::ConsumerListener interface.  These
@@ -311,11 +304,6 @@ private:
     // gets set each time updateTexImage is called.
     int64_t mCurrentTimestamp;
 
-#ifdef OMAP_ENHANCEMENT
-    // current layout for the buffers
-    uint32_t mCurrentLayout;
-#endif
-
     uint32_t mDefaultWidth, mDefaultHeight;
 
     // mFilteringEnabled indicates whether the transform matrix is computed for
@@ -361,13 +349,6 @@ private:
         // to EGL_NO_SYNC_KHR when the buffer is created and (optionally, based
         // on a compile-time option) set to a new sync object in updateTexImage.
         EGLSyncKHR mFence;
-
-#ifdef OMAP_ENHANCEMENT
-        // mLayout is the current layout of the buffer for this buffer slot. This gets
-        // set to mNextLayout each time queueBuffer gets called for this buffer.
-        uint32_t mLayout;
-#endif
-
     };
 
     // mEglDisplay is the EGLDisplay with which this SurfaceTexture is currently
diff --git a/./frameworks/native/include/gui/SurfaceTextureClient.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/gui/SurfaceTextureClient.h
index 5ad2802..8fa85b6 100644
--- a/./frameworks/native/include/gui/SurfaceTextureClient.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/gui/SurfaceTextureClient.h
@@ -28,10 +28,6 @@
 #include <utils/threads.h>
 #include <utils/KeyedVector.h>
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-#include <binder/MemoryBase.h>
-#endif
-
 struct ANativeWindow_Buffer;
 
 namespace android {
@@ -88,15 +84,6 @@ private:
     int dispatchSetUsage(va_list args);
     int dispatchLock(va_list args);
     int dispatchUnlockAndPost(va_list args);
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    int dispatchUpdateAndGetCurrent(va_list args);
-    int dispatchSetBuffersMetadata(va_list args);
-    int dispatchAddBufferSlot(va_list args);
-#endif
-
-#ifdef OMAP_ENHANCEMENT
-    int dispatchSetBuffersLayout(va_list args);
-#endif
 
 protected:
     virtual int cancelBuffer(ANativeWindowBuffer* buffer);
@@ -120,14 +107,6 @@ protected:
     virtual int setUsage(uint32_t reqUsage);
     virtual int lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds);
     virtual int unlockAndPost();
-#ifdef OMAP_ENHANCEMENT
-    virtual int setBuffersLayout(uint32_t layout);
-#endif
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    virtual int updateAndGetCurrent(ANativeWindowBuffer** buffer);
-    virtual int setBuffersMetadata(const sp<MemoryBase>& metadata);
-    virtual int addBufferSlot(const sp<GraphicBuffer>& buffer);
-#endif
 
     enum { NUM_BUFFER_SLOTS = BufferQueue::NUM_BUFFER_SLOTS };
     enum { DEFAULT_FORMAT = PIXEL_FORMAT_RGBA_8888 };
@@ -213,10 +192,6 @@ private:
     // one buffer behind the producer.
     mutable bool mConsumerRunningBehind;
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    // Metadata for the current texture
-    sp<MemoryBase> mMetadata;
-#endif
     // mMutex is the mutex used to prevent concurrent access to the member
     // variables of SurfaceTexture objects. It must be locked whenever the
     // member variables are accessed.
@@ -229,12 +204,6 @@ private:
 
     // must be accessed from lock/unlock thread only
     Region mDirtyRegion;
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    // mCurrentBuffer contains the current buffer from SurfaceTexture
-    // used in updateAndGetCurrent().
-    sp<GraphicBuffer> mCurrentBuffer;
-#endif
 };
 
 }; // namespace android
diff --git a/./frameworks/native/include/private/gui/SharedBufferStack.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/private/gui/SharedBufferStack.h
index 693fc88..0da03d1 100644
--- a/./frameworks/native/include/private/gui/SharedBufferStack.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/private/gui/SharedBufferStack.h
@@ -38,12 +38,7 @@ struct display_cblk_t
     float       density;
     float       xdpi;
     float       ydpi;
-#ifdef OMAP_ENHANCEMENT
-    uint32_t    maxTex;
-    uint32_t    pad[1];
-#else
     uint32_t    pad[2];
-#endif
 };
 
 struct surface_flinger_cblk_t   // 4KB max
diff --git a/./frameworks/native/include/ui/DisplayInfo.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/ui/DisplayInfo.h
index 32ef149..edd28a6 100644
--- a/./frameworks/native/include/ui/DisplayInfo.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/include/ui/DisplayInfo.h
@@ -35,9 +35,6 @@ struct DisplayInfo {
     float               density;
     float               xdpi;
     float               ydpi;
-#ifdef OMAP_ENHANCEMENT
-    uint32_t            maxTex;
-#endif
 };
 
 /* Display orientations as defined in Surface.java and ISurfaceComposer.h. */
diff --git a/./frameworks/native/include/ui/S3DFormat.h b/./frameworks/native/include/ui/S3DFormat.h
deleted file mode 100644
index 70fb745..0000000
--- a/./frameworks/native/include/ui/S3DFormat.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef UI_S3DFORMAT_H
-#define UI_S3DFORMAT_H
-
-#include <sys/types.h>
-
-#ifdef __cplusplus
-namespace android {
-#endif
-//These define how the content is layed out in the buffer
-//When describing a S3D display these are defined in relation to the panel
-//native scan order
-enum S3DLayoutType {
-    eMono           = 0x0,
-    eSideBySide     = 0x1,
-    eTopBottom      = 0x2,
-    eRowInterleaved = 0x3,
-    eColInterleaved = 0x4,
-};
-
-// S3DLayoutType is stored using 3 bits in 32 bit "flags" variable.
-//Position in 32-bit flag |31|30|20|..|00| are bits: 18,17,16
-#define S3DLayoutTypeMask  0x70000
-#define S3DLayoutTypeShift 16
-
-
-//This defines which view was drawn first
-//eMono: Don't care
-//eSideBySide - eLeftViewFirst = L | R , eRightViewFirst = R | L
-//eTopBottom - eLeftViewFirst = _L_, eRightViewFirst = _R_
-//                               R                      L
-//eRowInterleaved - eLeftViewFirst = first row is the left view
-//eRowInterleaved - eRightViewFirst = first row is the right view
-//eColInterleaved - eLeftViewFirst = first column is the left view
-//eColInterleaved - eRightViewFirst = first column is the right view
-enum S3DLayoutOrder {
-    eLeftViewFirst      = 0x0,
-    eRightViewFirst     = 0x1,
-};
-
-//S3DLayoutOrder is stored using 1 bit in "flags" variable.
-//Position in 32-bit flag |31|30|20|..|00| is bit 19
-#define S3DLayoutOrderMask     0x80000
-#define S3DLayoutOrderShift    19
-
-//Sources can use this values to define if only one or both of the views
-//can be rendered. Mostly used for pre-rendered content.
-enum S3DRenderMode {
-    eRenderLeft     = 0x0,
-    eRenderRight    = 0x1,
-    eRenderStereo   = 0x2,
-};
-//S3DRenderMode is stored using 2 bits in "flags" variable.
-//Position in 32-bit flag |31|30|20|..|00| are bits 21, 20
-#define S3DRenderModeMask  0x300000
-#define S3DRenderModeShift 20
-
-#ifdef __cplusplus
-};
-#endif
-#endif //UI_S3DFORMAT_H
diff --git a/./frameworks/native/libs/gui/BufferQueue.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/BufferQueue.cpp
index 104102f..a0774cf 100644
--- a/./frameworks/native/libs/gui/BufferQueue.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/BufferQueue.cpp
@@ -99,9 +99,6 @@ BufferQueue::BufferQueue(  bool allowSynchronousMode, int bufferCount ) :
     mBufferHasBeenQueued(false),
     mDefaultBufferFormat(0),
     mConsumerUsageBits(0),
-#ifdef OMAP_ENHANCEMENT
-    mNextLayout(NATIVE_WINDOW_BUFFERS_LAYOUT_PROGRESSIVE),
-#endif
     mTransformHint(0)
 {
     // Choose a name using the PID and a process-unique ID.
@@ -182,14 +179,6 @@ status_t BufferQueue::setTransformHint(uint32_t hint) {
     return OK;
 }
 
-#ifdef OMAP_ENHANCEMENT
-status_t BufferQueue::setLayout(uint32_t layout) {
-    Mutex::Autolock lock(mMutex);
-    mNextLayout = layout;
-    return OK;
-}
-#endif
-
 status_t BufferQueue::setBufferCount(int bufferCount) {
     ST_LOGV("setBufferCount: count=%d", bufferCount);
 
@@ -551,14 +540,8 @@ status_t BufferQueue::setSynchronousMode(bool enabled) {
     return err;
 }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-status_t BufferQueue::queueBuffer(int buf,
-        const QueueBufferInput& input, QueueBufferOutput* output,
-        const sp<IMemory>& metadata) {
-#else
 status_t BufferQueue::queueBuffer(int buf,
         const QueueBufferInput& input, QueueBufferOutput* output) {
-#endif
     ATRACE_CALL();
     ATRACE_BUFFER_INDEX(buf);
 
@@ -650,12 +633,6 @@ status_t BufferQueue::queueBuffer(int buf,
         mSlots[buf].mScalingMode = scalingMode;
         mFrameCounter++;
         mSlots[buf].mFrameNumber = mFrameCounter;
-#ifdef OMAP_ENHANCEMENT
-        mSlots[buf].mLayout = mNextLayout;
-#endif
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        mSlots[buf].mMetadata = metadata;
-#endif
 
         mBufferHasBeenQueued = true;
         mDequeueCondition.broadcast();
@@ -879,14 +856,6 @@ void BufferQueue::freeAllBuffersLocked() {
 status_t BufferQueue::acquireBuffer(BufferItem *buffer) {
     ATRACE_CALL();
     Mutex::Autolock _l(mMutex);
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    if (mAbandoned) {
-        ST_LOGE("acquireBuffer: SurfaceTexture has been abandoned!");
-        return NO_INIT;
-    }
-#endif
-
     // check if queue is empty
     // In asynchronous mode the list is guaranteed to be one buffer
     // deep, while in synchronous mode we use the oldest buffer.
@@ -906,13 +875,7 @@ status_t BufferQueue::acquireBuffer(BufferItem *buffer) {
         buffer->mScalingMode = mSlots[buf].mScalingMode;
         buffer->mFrameNumber = mSlots[buf].mFrameNumber;
         buffer->mTimestamp = mSlots[buf].mTimestamp;
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        buffer->mMetadata = mSlots[buf].mMetadata;
-#endif
         buffer->mBuf = buf;
-#ifdef OMAP_ENHANCEMENT
-        buffer->mLayout = mSlots[buf].mLayout;
-#endif
         mSlots[buf].mAcquireCalled = true;
 
         mSlots[buf].mBufferState = BufferSlot::ACQUIRED;
@@ -1091,64 +1054,4 @@ void BufferQueue::ProxyConsumerListener::onBuffersReleased() {
     }
 }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-status_t BufferQueue::updateAndGetCurrent(sp<GraphicBuffer>* buf) {
-    ST_LOGV("updateAndGetCurrent");
-    BufferItem item;
-    status_t status = acquireBuffer(&item);
-    if (status != NO_BUFFER_AVAILABLE) {
-        *buf = mSlots[item.mBuf].mGraphicBuffer;
-    }
-    return status;
-}
-
-
-int BufferQueue::addBufferSlot(const sp<GraphicBuffer>& buffer) {
-    Mutex::Autolock lock(mMutex);
-
-    // Find first free slot to add buffer
-    for (int i = 0; i < mBufferCount; i++) {
-        if ((mSlots[i].mGraphicBuffer == NULL) &&
-                (mSlots[i].mBufferState == BufferSlot::FREE)) {
-            // add buffer is dequeued state since client still has ownership of it
-            mSlots[i].mBufferState = BufferSlot::DEQUEUED;
-            mSlots[i].mRequestBufferCalled = true;
-            mSlots[i].mGraphicBuffer = buffer;
-            return i;
-        }
-    }
-    return -1;
-}
-
-status_t BufferQueue::getBuffer(int slot, BufferItem *buffer) {
-    ATRACE_CALL();
-    Mutex::Autolock _l(mMutex);
-
-    if (slot < 0 || slot >= mBufferCount) {
-        ALOGE("Invalid slot index");
-        return BAD_VALUE;
-    }
-
-    ATRACE_BUFFER_INDEX(slot);
-
-    if (mSlots[slot].mAcquireCalled) {
-        buffer->mGraphicBuffer = mSlots[slot].mGraphicBuffer;
-    } else {
-        buffer->mGraphicBuffer = NULL;
-    }
-
-    buffer->mCrop = mSlots[slot].mCrop;
-    buffer->mTransform = mSlots[slot].mTransform;
-    buffer->mScalingMode = mSlots[slot].mScalingMode;
-    buffer->mFrameNumber = mSlots[slot].mFrameNumber;
-    buffer->mTimestamp = mSlots[slot].mTimestamp;
-    buffer->mMetadata = mSlots[slot].mMetadata;
-
-    buffer->mBuf = slot;
-
-    return OK;
-
-}
-#endif
-
 }; // namespace android
diff --git a/./frameworks/native/libs/gui/ISurfaceTexture.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/ISurfaceTexture.cpp
index cd41e6c..3eb5e7a 100644
--- a/./frameworks/native/libs/gui/ISurfaceTexture.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/ISurfaceTexture.cpp
@@ -40,13 +40,6 @@ enum {
     SET_SYNCHRONOUS_MODE,
     CONNECT,
     DISCONNECT,
-#ifdef OMAP_ENHANCEMENT
-    SET_LAYOUT,
-#endif
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    UPDATE_AND_GET_CURRENT,
-    ADD_BUFFER_SLOT,
-#endif
 };
 
 
@@ -105,21 +98,12 @@ public:
         return result;
     }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
     virtual status_t queueBuffer(int buf,
-            const QueueBufferInput& input, QueueBufferOutput* output,
-            const sp<IMemory>& metadata) {
-#else
-     virtual status_t queueBuffer(int buf,
             const QueueBufferInput& input, QueueBufferOutput* output) {
-#endif
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(buf);
         memcpy(data.writeInplace(sizeof(input)), &input, sizeof(input));
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        data.writeStrongBinder(metadata->asBinder());
-#endif
         status_t result = remote()->transact(QUEUE_BUFFER, data, &reply);
         if (result != NO_ERROR) {
             return result;
@@ -185,50 +169,6 @@ public:
         result = reply.readInt32();
         return result;
     }
-
-#ifdef OMAP_ENHANCEMENT
-    virtual status_t setLayout(uint32_t layout) {
-        Parcel data, reply;
-        data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
-        data.writeInt32((int32_t)layout);
-        status_t result = remote()->transact(SET_LAYOUT, data, &reply);
-        if (result != NO_ERROR) {
-            return result;
-        }
-        result = reply.readInt32();
-        return result;
-    }
-#endif
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    virtual status_t updateAndGetCurrent(sp<GraphicBuffer>* buf) {
-        Parcel data, reply;
-        data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
-        status_t result = remote()->transact(UPDATE_AND_GET_CURRENT, data, &reply);
-        if (result != NO_ERROR) {
-            return result;
-        }
-        bool nonNull = reply.readInt32();
-        if (nonNull) {
-            *buf = new GraphicBuffer();
-            reply.read(**buf);
-        }
-        result = reply.readInt32();
-        return result;
-    }
-
-    virtual int addBufferSlot(const sp<GraphicBuffer>& buffer) {
-        Parcel data, reply;
-        data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
-        data.write(*buffer);
-        status_t result = remote()->transact(ADD_BUFFER_SLOT, data, &reply);
-        if (result != NO_ERROR) {
-            return -1;
-        }
-        int bufferIndex = reply.readInt32();
-        return bufferIndex;
-    }
-#endif
 };
 
 IMPLEMENT_META_INTERFACE(SurfaceTexture, "android.gui.SurfaceTexture");
@@ -279,12 +219,7 @@ status_t BnSurfaceTexture::onTransact(
             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
-#ifdef OMAP_ENHANCEMENT_CPCAM
-            sp<IMemory> metadata = interface_cast<IMemory>(data.readStrongBinder());
-            status_t result = queueBuffer(buf, *input, output, metadata);
-#else
             status_t result = queueBuffer(buf, *input, output);
-#endif
             reply->writeInt32(result);
             return NO_ERROR;
         } break;
@@ -327,39 +262,6 @@ status_t BnSurfaceTexture::onTransact(
             reply->writeInt32(res);
             return NO_ERROR;
         } break;
-
-#ifdef OMAP_ENHANCEMENT
-        case SET_LAYOUT: {
-            uint32_t layout;
-            CHECK_INTERFACE(ISurfaceTexture, data, reply);
-            layout = (uint32_t)data.readInt32();
-            status_t result = setLayout(layout);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        } break;
-#endif
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-        case UPDATE_AND_GET_CURRENT: {
-            CHECK_INTERFACE(ISurfaceTexture, data, reply);
-            sp<GraphicBuffer> buffer;
-            int result = updateAndGetCurrent(&buffer);
-            reply->writeInt32(buffer != 0);
-            if (buffer != 0) {
-                reply->write(*buffer);
-            }
-            reply->writeInt32(result);
-            return NO_ERROR;
-        } break;
-       case ADD_BUFFER_SLOT: {
-            CHECK_INTERFACE(ISurfaceTexture, data, reply);
-            sp<GraphicBuffer> buffer = new GraphicBuffer();
-            data.read(*buffer);
-            int bufferIndex = addBufferSlot(buffer);
-            reply->writeInt32(bufferIndex);
-            return NO_ERROR;
-        } break;
-#endif
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/./frameworks/native/libs/gui/SurfaceComposerClient.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/SurfaceComposerClient.cpp
index 3d7fcc4..8fa2167 100644
--- a/./frameworks/native/libs/gui/SurfaceComposerClient.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/SurfaceComposerClient.cpp
@@ -498,9 +498,6 @@ status_t SurfaceComposerClient::getDisplayInfo(
     info->ydpi           = dcblk->ydpi;
     info->fps            = dcblk->fps;
     info->density        = dcblk->density;
-#ifdef OMAP_ENHANCEMENT
-    info->maxTex         = dcblk->maxTex;
-#endif
     return getPixelFormatInfo(dcblk->format, &(info->pixelFormatInfo));
 }
 
diff --git a/./frameworks/native/libs/gui/SurfaceTexture.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/SurfaceTexture.cpp
index d11d74b..55be4bc 100644
--- a/./frameworks/native/libs/gui/SurfaceTexture.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/SurfaceTexture.cpp
@@ -120,9 +120,6 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     mEglContext(EGL_NO_CONTEXT),
     mAbandoned(false),
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
-#ifdef OMAP_ENHANCEMENT
-    mCurrentLayout(NATIVE_WINDOW_BUFFERS_LAYOUT_PROGRESSIVE),
-#endif
     mAttached(true)
 {
     // Choose a name using the PID and a process-unique ID.
@@ -318,9 +315,6 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter) {
         mCurrentTransform = item.mTransform;
         mCurrentScalingMode = item.mScalingMode;
         mCurrentTimestamp = item.mTimestamp;
-#ifdef OMAP_ENHANCEMENT
-        mCurrentLayout = item.mLayout;
-#endif
         computeCurrentTransformMatrix();
     } else  {
         if (err < 0) {
@@ -771,24 +765,6 @@ status_t SurfaceTexture::setTransformHint(uint32_t hint) {
     return mBufferQueue->setTransformHint(hint);
 }
 
-#ifdef OMAP_ENHANCEMENT
-status_t SurfaceTexture::setLayout(uint32_t layout) {
-    ST_LOGV("SurfaceTexture::setLayout");
-    Mutex::Autolock lock(mMutex);
-
-    if (mAbandoned) {
-       // Nothing to do if we're already abandoned.
-        return NO_INIT;
-    }
-    return mBufferQueue->setLayout(layout);
-}
-
-uint32_t SurfaceTexture::getCurrentLayout() const {
-    Mutex::Autolock lock(mMutex);
-    return mCurrentLayout;
-}
-#endif
-
 // Used for refactoring BufferQueue from SurfaceTexture
 // Should not be in final interface once users of SurfaceTexture are clean up.
 status_t SurfaceTexture::setSynchronousMode(bool enabled) {
diff --git a/./frameworks/native/libs/gui/SurfaceTextureClient.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/SurfaceTextureClient.cpp
index 0cec570..36a81a6 100644
--- a/./frameworks/native/libs/gui/SurfaceTextureClient.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/libs/gui/SurfaceTextureClient.cpp
@@ -244,11 +244,7 @@ int SurfaceTextureClient::queueBuffer(android_native_buffer_t* buffer) {
     ISurfaceTexture::QueueBufferOutput output;
     ISurfaceTexture::QueueBufferInput input(timestamp, crop, mScalingMode,
             mTransform);
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    status_t err = mSurfaceTexture->queueBuffer(i, input, &output, mMetadata);
-#else
     status_t err = mSurfaceTexture->queueBuffer(i, input, &output);
-#endif
     if (err != OK)  {
         ALOGE("queueBuffer: error queuing buffer to SurfaceTexture, %d", err);
     }
@@ -340,11 +336,6 @@ int SurfaceTextureClient::perform(int operation, va_list args)
     case NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP:
         res = dispatchSetBuffersTimestamp(args);
         break;
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    case NATIVE_WINDOW_SET_BUFFERS_METADATA:
-        res = dispatchSetBuffersMetadata(args);
-        break;
-#endif
     case NATIVE_WINDOW_SET_BUFFERS_DIMENSIONS:
         res = dispatchSetBuffersDimensions(args);
         break;
@@ -369,19 +360,6 @@ int SurfaceTextureClient::perform(int operation, va_list args)
     case NATIVE_WINDOW_API_DISCONNECT:
         res = dispatchDisconnect(args);
         break;
-#ifdef OMAP_ENHANCEMENT
-    case NATIVE_WINDOW_SET_BUFFERS_LAYOUT:
-        res = dispatchSetBuffersLayout(args);
-        break;
-#endif
-#ifdef OMAP_ENHANCEMENT_CPCAM
-    case NATIVE_WINDOW_UPDATE_AND_GET_CURRENT:
-        res = dispatchUpdateAndGetCurrent(args);
-        break;
-    case NATIVE_WINDOW_ADD_BUFFER_SLOT:
-        res = dispatchAddBufferSlot(args);
-        break;
-#endif
     default:
         res = NAME_NOT_FOUND;
         break;
@@ -457,13 +435,6 @@ int SurfaceTextureClient::dispatchSetBuffersTimestamp(va_list args) {
     return setBuffersTimestamp(timestamp);
 }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-int SurfaceTextureClient::dispatchSetBuffersMetadata(va_list args) {
-    MemoryBase* metadata = va_arg(args, MemoryBase*);
-    return setBuffersMetadata(metadata);
-}
-#endif
-
 int SurfaceTextureClient::dispatchLock(va_list args) {
     ANativeWindow_Buffer* outBuffer = va_arg(args, ANativeWindow_Buffer*);
     ARect* inOutDirtyBounds = va_arg(args, ARect*);
@@ -474,24 +445,6 @@ int SurfaceTextureClient::dispatchUnlockAndPost(va_list args) {
     return unlockAndPost();
 }
 
-#ifdef OMAP_ENHANCEMENT
-int SurfaceTextureClient::dispatchSetBuffersLayout(va_list args) {
-    uint32_t bufLayout = va_arg(args, uint32_t);
-    return setBuffersLayout(bufLayout);
-}
-#endif
-
-#ifdef OMAP_ENHANCEMENT_CPCAM
-int SurfaceTextureClient::dispatchUpdateAndGetCurrent(va_list args) {
-    ANativeWindowBuffer** buffer = va_arg(args, ANativeWindowBuffer**);
-    return updateAndGetCurrent(buffer);
-}
-
-int SurfaceTextureClient::dispatchAddBufferSlot(va_list args) {
-    const sp<GraphicBuffer> *buffer = va_arg(args, sp<GraphicBuffer> *);
-    return addBufferSlot(*buffer);
-}
-#endif
 
 int SurfaceTextureClient::connect(int api) {
     ATRACE_CALL();
@@ -659,16 +612,6 @@ int SurfaceTextureClient::setBuffersTimestamp(int64_t timestamp)
     return NO_ERROR;
 }
 
-#ifdef OMAP_ENHANCEMENT
-int SurfaceTextureClient::setBuffersLayout(uint32_t bufLayout)
-{
-    ALOGV("SurfaceTextureClient::setBuffersLayout");
-    Mutex::Autolock lock(mMutex);
-    status_t err = mSurfaceTexture->setLayout(bufLayout);
-    return NO_ERROR;
-}
-#endif
-
 void SurfaceTextureClient::freeAllBuffers() {
     for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
         mSlots[i].buffer = 0;
@@ -844,46 +787,4 @@ status_t SurfaceTextureClient::unlockAndPost()
     return err;
 }
 
-#ifdef OMAP_ENHANCEMENT_CPCAM
-int SurfaceTextureClient::updateAndGetCurrent(android_native_buffer_t** buffer)
-{
-    ALOGV("SurfaceTextureClient::updateAndGetCurrent");
-    status_t err = NO_ERROR;
-
-    Mutex::Autolock lock(mMutex);
-    err = mSurfaceTexture->updateAndGetCurrent(&mCurrentBuffer);
-    *buffer = mCurrentBuffer.get();
-    return err;
-}
-
-int SurfaceTextureClient::setBuffersMetadata(const sp<MemoryBase>& metadata)
-{
-    ALOGV("SurfaceTextureClient::setBuffersMetadata");
-    Mutex::Autolock lock(mMutex);
-    mMetadata = metadata;
-    return NO_ERROR;
-}
-
-int SurfaceTextureClient::addBufferSlot(const sp<GraphicBuffer>& buffer)
-{
-    ALOGV("SurfaceTextureClient::addBufferSlot");
-    int slot = -1;
-
-    Mutex::Autolock lock(mMutex);
-    slot = mSurfaceTexture->addBufferSlot(buffer);
-
-    if (0 > slot) {
-        return NO_MEMORY;
-    }
-    if (NUM_BUFFER_SLOTS <= slot) {
-        return BAD_INDEX;
-    }
-
-    mSlots[slot].buffer = buffer;
-    mSlots[slot].dirtyRegion.clear();
-
-    return NO_ERROR;
-}
-#endif
-
 }; // namespace android
diff --git a/./frameworks/native/opengl/libs/EGL/Loader.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/opengl/libs/EGL/Loader.cpp
index 6473eb2..9ee3686 100644
--- a/./frameworks/native/opengl/libs/EGL/Loader.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/opengl/libs/EGL/Loader.cpp
@@ -134,27 +134,12 @@ status_t Loader::driver_t::set(void* hnd, int32_t api)
     return NO_ERROR;
 }
 
-#ifdef OMAP_ENHANCEMENT_MULTIGPU
-int Loader::checkProcessorType(void)
-{
-    char prop[PROPERTY_VALUE_MAX];
-    int result = property_get("ro.product.processor",prop,NULL);
-    if (result) {
-        mProcessorType = prop;
-        ALOGI("Processor type: %s",prop);
-    } else
-        ALOGI("Processor type unknown");
-    return result;
-}
-#endif
-
 // ----------------------------------------------------------------------------
 
 Loader::Loader()
 {
     char line[256];
     char tag[256];
-    int ret = 0;
 
     /* Special case for GLES emulation */
     if (checkGlesEmulationStatus() == 0) {
@@ -163,10 +148,6 @@ Loader::Loader()
         mDriverTag.setTo("android");
         return;
     }
-#ifdef OMAP_ENHANCEMENT_MULTIGPU
-    int processor = checkProcessorType();
-    char proctype[256] = "";
-#endif
 
     /* Otherwise, use egl.cfg */
     FILE* cfg = fopen("/system/lib/egl/egl.cfg", "r");
@@ -177,7 +158,6 @@ Loader::Loader()
     } else {
         while (fgets(line, 256, cfg)) {
             int dpy, impl;
-#ifndef OMAP_ENHANCEMENT_MULTIGPU
             if (sscanf(line, "%u %u %s", &dpy, &impl, tag) == 3) {
                 //ALOGD(">>> %u %u %s", dpy, impl, tag);
                 // We only load the h/w accelerated implementation
@@ -185,29 +165,6 @@ Loader::Loader()
                     mDriverTag = tag;
                 }
             }
-#else
-            if ( (ret = sscanf(line, "%u %u %s %s", &dpy, &impl, tag, proctype)) == 4) {
-                // We only load the h/w accelerated implementation
-                ALOGI("egl.cfg: entry %s %s", tag, !strlen(proctype) ? "" : proctype);
-                if (tag != String8("android")) {
-                    if (processor) {
-                        if (String8(proctype) == mProcessorType) {
-                            mDriverTag = tag;
-                            ALOGI("Picked EGL type '%s' for processor '%s'", tag, proctype);
-                            break;
-                        }
-                    } else {
-                        mDriverTag = tag;
-                        ALOGI("Picked EGL type '%s' without known processor type", tag);
-                        break;
-                    }
-                }
-            } else if (ret == 3) { // If line have the only 3 arg, process it in default style
-                if (tag != String8("android")) {
-                    mDriverTag = tag;
-                }
-            }
-#endif
         }
         fclose(cfg);
     }
diff --git a/./frameworks/native/opengl/libs/EGL/Loader.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/opengl/libs/EGL/Loader.h
index efaa0bf..30773cb 100644
--- a/./frameworks/native/opengl/libs/EGL/Loader.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/opengl/libs/EGL/Loader.h
@@ -53,9 +53,6 @@ class Loader : public Singleton<Loader>
     };
     
     String8 mDriverTag;
-#ifdef OMAP_ENHANCEMENT_MULTIGPU
-    String8 mProcessorType;
-#endif
     getProcAddressType getProcAddress;
     
 public:
@@ -73,10 +70,6 @@ private:
             char const * const * api, 
             __eglMustCastToProperFunctionPointerType* curr, 
             getProcAddressType getProcAddress); 
-#ifdef OMAP_ENHANCEMENT_MULTIGPU
-    int checkProcessorType(void);
-#endif
-
 };
 
 // ----------------------------------------------------------------------------
diff --git a/./frameworks/native/services/surfaceflinger/Android.mk b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/Android.mk
index 17115c5..6f7a7e1 100644
--- a/./frameworks/native/services/surfaceflinger/Android.mk
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/Android.mk
@@ -17,13 +17,6 @@ LOCAL_SRC_FILES:= \
     SurfaceTextureLayer.cpp                 \
     Transform.cpp                           \
     
-ifdef OMAP_ENHANCEMENT_S3D
-LOCAL_SRC_FILES += \
-    S3DSurfaceFlinger.cpp                   \
-    OmapLayer.cpp                           \
-    OmapLayerScreenshot.cpp                 \
-    DisplayHardware/S3DHardware.cpp
-endif
 
 LOCAL_CFLAGS:= -DLOG_TAG=\"SurfaceFlinger\"
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
diff --git a/./frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
index d642eea..bb93215 100644
--- a/./frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
@@ -225,9 +225,6 @@ void DisplayHardware::init(uint32_t dpy)
     // initialize EGL
     EGLint attribs[] = {
             EGL_SURFACE_TYPE,       EGL_WINDOW_BIT,
-#ifdef OMAP_ENHANCEMENT_S3D
-            EGL_STENCIL_SIZE,       1,
-#endif
             EGL_NONE,               0,
             EGL_NONE
     };
@@ -237,13 +234,8 @@ void DisplayHardware::init(uint32_t dpy)
     if (property_get("debug.sf.hw", property, NULL) > 0) {
         if (atoi(property) == 0) {
             ALOGW("H/W composition disabled");
-#ifdef OMAP_ENHANCEMENT_S3D
-            attribs[4] = EGL_CONFIG_CAVEAT;
-            attribs[5] = EGL_SLOW_CONFIG;
-#else
             attribs[2] = EGL_CONFIG_CAVEAT;
             attribs[3] = EGL_SLOW_CONFIG;
-#endif
         }
     }
 
diff --git a/./frameworks/native/services/surfaceflinger/DisplayHardware/S3DHardware.cpp b/./frameworks/native/services/surfaceflinger/DisplayHardware/S3DHardware.cpp
deleted file mode 100644
index c941912..0000000
--- a/./frameworks/native/services/surfaceflinger/DisplayHardware/S3DHardware.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "S3DHardware.h"
-
-#include <fcntl.h>
-#include <utils/Log.h>
-
-namespace android {
-// ---------------------------------------------------------------------------
-
-//Assuming display0 is the default display
-static const char kS3DCapableFileName[] = "/sys/devices/platform/omapdss/display0/s3d_capable";
-static const char kS3DEnableFileName[] = "/sys/devices/platform/omapdss/display0/s3d_enable";
-static const char kS3DTypeFileName[] = "/sys/devices/platform/omapdss/display0/s3d_type";
-static const char kS3DOrderFileName[] = "/sys/devices/platform/omapdss/display0/s3d_ordering";
-static const char kS3DSwitchFileName[] = "/sys/devices/platform/omapdss/display0/s3d_switchable";
-
-static const char kTopBottomName[] = "topbottom";
-static const char kSbSName[] = "sidebyside";
-static const char kRowInterleavedName[] = "rowInterleaved";
-static const char kColInterleavedName[] = "columnInterleaved";
-
-static const char kZeroString[] = "0";
-static const char kOneString[] = "1";
-
-static const int kMaxSysfsEntrySize = 256;
-
-static int read_sysentry(const char* sysPath, char* data, size_t size) {
-    int fd = open(sysPath, O_RDONLY);
-    if (fd == -1) {
-        if (errno == ENOENT) {
-            ALOGI("Could not open sysfs entry(%s)", sysPath);
-        } else {
-            ALOGE("Error during open sysfs entry(%s)", sysPath);
-        }
-        return -1;
-    }
-    size_t bytesread = read(fd, data, size);
-    if (read(fd, data, size) < 0) {
-        ALOGE("Could not read sysfs entry(%s)", sysPath);
-        close(fd);
-        return -1;
-    }
-    close(fd);
-    return bytesread;
-}
-
-S3DHardware::S3DHardware()
-    : mType(eMono),
-      mOrder(eLeftViewFirst),
-      mSwitcheable(true)
-{
-    init();
-}
-
-status_t S3DHardware::initCheck() const {
-    return mType != eMono ? NO_ERROR : NO_INIT;
-}
-
-void S3DHardware::init()
-{
-    char data[kMaxSysfsEntrySize];
-
-    if (read_sysentry(kS3DCapableFileName, data, kMaxSysfsEntrySize) <= 0) {
-        return;
-    }
-
-    //Is display S3D capable?
-    if (!strncmp(data, kZeroString, sizeof(kZeroString)-1)) {
-        return;
-    }
-
-    if (read_sysentry(kS3DSwitchFileName, data, kMaxSysfsEntrySize) > 0) {
-        mSwitcheable = !strncmp(data, kOneString, sizeof(kOneString)-1);
-    }
-
-    if (read_sysentry(kS3DOrderFileName, data, kMaxSysfsEntrySize) > 0) {
-        if (strncmp(data, kOneString, sizeof(kOneString)-1)) {
-            mOrder = eLeftViewFirst;
-        } else {
-            mOrder = eRightViewFirst;
-        }
-    }
-
-    if (read_sysentry(kS3DTypeFileName, data, kMaxSysfsEntrySize) > 0) {
-        if(!strncmp(data, kTopBottomName, sizeof(kTopBottomName)-1)) {
-            mType = eTopBottom;
-        } else if(!strncmp(data, kSbSName, sizeof(kSbSName)-1)) {
-            mType = eSideBySide;
-        } else if(!strncmp(data, kColInterleavedName, sizeof(kColInterleavedName)-1)) {
-            mType = eColInterleaved;
-        } else if(!strncmp(data, kRowInterleavedName, sizeof(kRowInterleavedName)-1)) {
-            mType = eRowInterleaved;
-        } else {
-            ALOGE("Unsupported s3d hw type%s", data);
-        }
-    }
-}
-
-void S3DHardware::forceConfiguration(S3DLayoutType type, S3DLayoutOrder order, bool switcheable)
-{
-    mType = type;
-    mOrder = order;
-    mSwitcheable = switcheable;
-}
-
-status_t S3DHardware::enableS3D(bool state)
-{
-    if (mType == eMono || mCurrentState == state) {
-        return NO_ERROR;
-    }
-
-    int fd = open(kS3DEnableFileName, O_WRONLY);
-    if (fd == -1) {
-        return UNKNOWN_ERROR;
-    }
-
-    char data = state ? '1': '0';
-    size_t bytesWritten = write(fd, &data, 1);
-    if (bytesWritten <= 0) {
-        close(fd);
-        return UNKNOWN_ERROR;
-    }
-
-    mCurrentState = state;
-    close(fd);
-    return NO_ERROR;
-}
-
-
-// ---------------------------------------------------------------------------
-}; // namespace android
diff --git a/./frameworks/native/services/surfaceflinger/DisplayHardware/S3DHardware.h b/./frameworks/native/services/surfaceflinger/DisplayHardware/S3DHardware.h
deleted file mode 100644
index a26bd0c..0000000
--- a/./frameworks/native/services/surfaceflinger/DisplayHardware/S3DHardware.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _S3DHARDWARE_H_
-#define _S3DHARDWARE_H_
-
-#include <stdint.h>
-#include <sys/types.h>
-#include <utils/Errors.h>
-
-#include <ui/S3DFormat.h>
-
-namespace android {
-
-class S3DHardware
-{
-public:
-
-    S3DHardware();
-
-    status_t initCheck() const;
-    status_t enableS3D(bool state);
-
-    inline S3DLayoutType getType() const { return mType; }
-    inline S3DLayoutOrder getOrdering() const { return mOrder; }
-    inline bool isSwitcheable() const { return mSwitcheable; }
-
-    inline bool isInterleaved() const { return (mType == eRowInterleaved || mType == eColInterleaved); }
-
-    void forceConfiguration(S3DLayoutType type, S3DLayoutOrder order, bool switcheable);
-
-private:
-    void init();
-    S3DLayoutType mType;
-    S3DLayoutOrder mOrder;
-    bool mSwitcheable;
-
-    bool mCurrentState;
-    int32_t s3d_w;
-    int32_t s3d_h;
-};
-
-}; // namespace android
-
-#endif // _S3DHARDWARE_H_
diff --git a/./frameworks/native/services/surfaceflinger/Layer.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/Layer.cpp
index e810686..4062340 100644
--- a/./frameworks/native/services/surfaceflinger/Layer.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/Layer.cpp
@@ -56,9 +56,6 @@ Layer::Layer(SurfaceFlinger* flinger,
         mQueuedFrames(0),
         mCurrentTransform(0),
         mCurrentScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),
-#ifdef OMAP_ENHANCEMENT
-        mCurrentLayout(NATIVE_WINDOW_BUFFERS_LAYOUT_PROGRESSIVE),
-#endif
         mCurrentOpacity(true),
         mRefreshPending(false),
         mFrameLatencyNeeded(false),
@@ -301,9 +298,6 @@ void Layer::setGeometry(hwc_layer_t* hwcl)
     hwcl->sourceCrop.top    = crop.top;
     hwcl->sourceCrop.right  = crop.right;
     hwcl->sourceCrop.bottom = crop.bottom;
-#ifdef OMAP_ENHANCEMENT
-    hwcl->flags |= mCurrentLayout << 24;
-#endif
 }
 
 void Layer::setPerFrameData(hwc_layer_t* hwcl) {
@@ -654,23 +648,13 @@ void Layer::lockPageFlip(bool& recomputeVisibleRegions)
         Rect crop(mSurfaceTexture->getCurrentCrop());
         const uint32_t transform(mSurfaceTexture->getCurrentTransform());
         const uint32_t scalingMode(mSurfaceTexture->getCurrentScalingMode());
-#ifdef OMAP_ENHANCEMENT
-        const uint32_t layout(mSurfaceTexture->getCurrentLayout());
-#endif
-
         if ((crop != mCurrentCrop) ||
             (transform != mCurrentTransform) ||
-#ifdef OMAP_ENHANCEMENT
-            (layout != mCurrentLayout) ||
-#endif
             (scalingMode != mCurrentScalingMode))
         {
             mCurrentCrop = crop;
             mCurrentTransform = transform;
             mCurrentScalingMode = scalingMode;
-#ifdef OMAP_ENHANCEMENT
-            mCurrentLayout = layout;
-#endif
             mFlinger->invalidateHwcGeometry();
         }
 
diff --git a/./frameworks/native/services/surfaceflinger/Layer.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/Layer.h
index 5995a7a..393599f 100644
--- a/./frameworks/native/services/surfaceflinger/Layer.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/Layer.h
@@ -96,9 +96,6 @@ protected:
 
 private:
     friend class SurfaceTextureLayer;
-#ifdef OMAP_ENHANCEMENT_S3D
-    friend class OmapLayer;
-#endif
     void onFrameQueued();
     virtual sp<ISurface> createSurface();
     uint32_t getEffectiveUsage(uint32_t usage) const;
@@ -125,9 +122,6 @@ private:
     bool mRefreshPending;
     bool mFrameLatencyNeeded;
     int mFrameLatencyOffset;
-#ifdef OMAP_ENHANCEMENT
-    uint32_t mCurrentLayout;
-#endif
 
     struct Statistics {
         Statistics() : timestamp(0), set(0), vsync(0) { }
diff --git a/./frameworks/native/services/surfaceflinger/LayerBase.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/LayerBase.h
index 587a843..c547a40 100644
--- a/./frameworks/native/services/surfaceflinger/LayerBase.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/LayerBase.h
@@ -247,11 +247,8 @@ protected:
 
           void clearWithOpenGL(const Region& clip, GLclampf r, GLclampf g,
                                GLclampf b, GLclampf alpha) const;
-#ifdef OMAP_ENHANCEMENT_S3D
-          virtual void drawWithOpenGL(const Region& clip) const;
-#else
           void drawWithOpenGL(const Region& clip) const;
-#endif
+
           void setFiltering(bool filtering);
           bool getFiltering() const;
 
diff --git a/./frameworks/native/services/surfaceflinger/LayerScreenshot.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/LayerScreenshot.cpp
index ccefd08..b42353c 100644
--- a/./frameworks/native/services/surfaceflinger/LayerScreenshot.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/LayerScreenshot.cpp
@@ -106,14 +106,6 @@ uint32_t LayerScreenshot::doTransaction(uint32_t flags)
     return LayerBaseClient::doTransaction(flags);
 }
 
-#ifdef OMAP_ENHANCEMENT_S3D
-void LayerScreenshot::drawRegion(const Region& clip, int hw_w, int hw_h) const
-{
-    glTexCoordPointer(2, GL_FLOAT, 0, mTexCoords);
-    glDrawArrays(GL_TRIANGLE_FAN, 0, mNumVertices);
-}
-#endif
-
 void LayerScreenshot::onDraw(const Region& clip) const
 {
     const State& s(drawingState());
@@ -141,15 +133,10 @@ void LayerScreenshot::onDraw(const Region& clip) const
         glMatrixMode(GL_MODELVIEW);
 
         glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-#ifndef OMAP_ENHANCEMENT_S3D
         glTexCoordPointer(2, GL_FLOAT, 0, mTexCoords);
-#endif
         glVertexPointer(2, GL_FLOAT, 0, mVertices);
-#ifdef OMAP_ENHANCEMENT_S3D
-        drawRegion(clip, hw.getWidth(), fbHeight);
-#else
         glDrawArrays(GL_TRIANGLE_FAN, 0, mNumVertices);
-#endif
+
         glDisable(GL_BLEND);
         glDisable(GL_TEXTURE_2D);
         glDisableClientState(GL_TEXTURE_COORD_ARRAY);
diff --git a/./frameworks/native/services/surfaceflinger/LayerScreenshot.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/LayerScreenshot.h
index 4ee3796..ab90047 100644
--- a/./frameworks/native/services/surfaceflinger/LayerScreenshot.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/LayerScreenshot.h
@@ -32,15 +32,8 @@ namespace android {
 class LayerScreenshot : public LayerBaseClient
 {
     GLuint mTextureName;
-#ifndef OMAP_ENHANCEMENT_S3D
     GLfloat mTexCoords[8];
-#endif
     sp<SurfaceFlinger> mFlinger;
-#ifdef OMAP_ENHANCEMENT_S3D
-protected:
-    GLfloat mTexCoords[8];
-    virtual void drawRegion(const Region& clip, int hw_w, int hw_h) const;
-#endif
 public:    
             LayerScreenshot(SurfaceFlinger* flinger, DisplayID display,
                         const sp<Client>& client);
diff --git a/./frameworks/native/services/surfaceflinger/OmapLayer.cpp b/./frameworks/native/services/surfaceflinger/OmapLayer.cpp
deleted file mode 100644
index 3738343..0000000
--- a/./frameworks/native/services/surfaceflinger/OmapLayer.cpp
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#include "OmapLayer.h"
-#include "S3DSurfaceFlinger.h"
-
-namespace android {
-
-OmapLayer::OmapLayer(S3DSurfaceFlinger* flinger, DisplayID display, const sp<Client>& client)
-         :  Layer(flinger, display, client),
-            mFlingerS3D(flinger),
-            mType(eMono),
-            mViewOrder(eLeftViewFirst),
-            mRenderMode(eRenderStereo)
-{
-}
-
-void OmapLayer::setConfig(S3DLayoutType type, S3DLayoutOrder order, S3DRenderMode mode)
-{
-    mType = type;
-    mViewOrder = order;
-    mRenderMode = mode;
-    //Cause redraw of visible region
-    mCurrentState.sequence++;
-    requestTransaction();
-}
-
-void OmapLayer::onRemoved()
-{
-    mFlingerS3D->removeS3DLayer_l(this);
-    Layer::onRemoved();
-}
-
-void OmapLayer::setGeometry(hwc_layer_t* hwcl)
-{
-    Layer::setGeometry(hwcl);
-    hwcl->flags &= ~S3DLayoutTypeMask;
-    hwcl->flags |= mType << S3DLayoutTypeShift;
-    hwcl->flags &= ~S3DLayoutOrderMask;
-    hwcl->flags |= mViewOrder << S3DLayoutOrderShift;
-    hwcl->flags &= ~S3DRenderModeMask;
-    hwcl->flags |= mRenderMode << S3DRenderModeShift;
-}
-
-void OmapLayer::lockPageFlip(bool& recomputeVisibleRegions)
-{
-    Layer::lockPageFlip(recomputeVisibleRegions);
-#ifdef OMAP_ENHANCEMENT
-    uint8_t s3d_type = (mCurrentLayout >> 16 ) & 0xFF;
-    uint8_t s3d_order = (mCurrentLayout >> 24 ) & 0xFF;
-    S3DLayoutType prevType = mType;
-    switch (s3d_type) {
-        case eSideBySide:
-        case eTopBottom:
-        case eRowInterleaved:
-        case eColInterleaved:
-            mType = static_cast<S3DLayoutType>(s3d_type);
-            break;
-        default:
-            //Invalid type
-            return;
-    }
-    switch (s3d_order) {
-        case eLeftViewFirst:
-        case eRightViewFirst:
-            mViewOrder = static_cast<S3DLayoutOrder>(s3d_order);
-        default:
-            //Invalid order
-            mViewOrder = eLeftViewFirst;
-            break;
-    }
-    if (mType != prevType && mType != eMono) {
-        mFlingerS3D->addS3DLayer_l(this);
-    }
-#endif
-}
-
-void OmapLayer::drawWithOpenGL(const Region& clip) const
-{
-    if (mFlingerS3D->isDefaultRender() ||
-        (!isS3D() && !mFlingerS3D->isFramePackingRender())) {
-        //No custom drawing needed.
-        //TODO: filter Monoscopic layers when doing interleaved rendering
-        //if high-quality setting is selected
-        LayerBase::drawWithOpenGL(clip);
-        return;
-    }
-
-    //Enable filtering for custom drawing as there scaling will occur
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-
-    S3DRenderMode viewToRender = mFlingerS3D->isDrawingLeft() ? eRenderLeft : eRenderRight;
-    if (isS3D()&& mRenderMode != eRenderStereo && mRenderMode != viewToRender) {
-        //If the layer has been configured to render a specific view (left or right)
-        //then draw that view, not the one being asked for by surfaceflinger
-        if (mFlingerS3D->isFramePackingRender() || mFlingerS3D->isMonoRender()) {
-            viewToRender = mRenderMode;
-        }
-    }
-
-    if (isS3D() && mFlingerS3D->isInterleaveRender() && mRenderMode == eRenderStereo) {
-        glEnable(GL_STENCIL_TEST);
-    } else if (isS3D() && mFlingerS3D->isAnaglyphRender() && mRenderMode == eRenderStereo) {
-        //Left view = RED
-        glColorMask(GL_TRUE, GL_FALSE, GL_FALSE, GL_TRUE);
-    }
-
-    drawWithOpenGL(clip, isDrawingFirstHalf(viewToRender));
-
-    //This layer draws its right view here as the viewport is not changed.
-    //This is done so that blending of any higher z layers with this one is correct.
-    if (isS3D() && mRenderMode == eRenderStereo &&
-        !mFlingerS3D->isFramePackingRender() && !mFlingerS3D->isMonoRender()) {
-        mFlingerS3D->setDrawState(S3DSurfaceFlinger::eDrawingS3DRight);
-        if (mFlingerS3D->isAnaglyphRender()) {
-            //right view = cyan
-            glColorMask(GL_FALSE, GL_TRUE, GL_TRUE, GL_TRUE);
-        }
-        drawWithOpenGL(clip, isDrawingFirstHalf(eRenderRight));
-        mFlingerS3D->setDrawState(S3DSurfaceFlinger::eDrawingS3DLeft);
-    }
-
-    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
-    glDisable(GL_STENCIL_TEST);
-}
-
-void OmapLayer::drawWithOpenGL(const Region& clip, bool drawFirstHalf) const
-{
-    const DisplayHardware& hw(graphicPlane(0).displayHardware());
-    const uint32_t fbHeight = hw.getHeight();
-    const State& s(drawingState());
-
-    GLenum src = mPremultipliedAlpha ? GL_ONE : GL_SRC_ALPHA;
-    if (CC_UNLIKELY(s.alpha < 0xFF)) {
-        const GLfloat alpha = s.alpha * (1.0f/255.0f);
-        if (mPremultipliedAlpha) {
-            glColor4f(alpha, alpha, alpha, alpha);
-        } else {
-            glColor4f(1, 1, 1, alpha);
-        }
-        glEnable(GL_BLEND);
-        glBlendFunc(src, GL_ONE_MINUS_SRC_ALPHA);
-        glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-    } else {
-        glColor4f(1, 1, 1, 1);
-        glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-        if (!isOpaque()) {
-            glEnable(GL_BLEND);
-            glBlendFunc(src, GL_ONE_MINUS_SRC_ALPHA);
-        } else {
-            glDisable(GL_BLEND);
-        }
-    }
-
-    struct TexCoords {
-        GLfloat u;
-        GLfloat v;
-    };
-
-    Rect crop(s.active.w, s.active.h);
-    if (!s.active.crop.isEmpty()) {
-        crop = s.active.crop;
-    }
-
-    GLfloat left = GLfloat(crop.left) / GLfloat(s.active.w);
-    GLfloat top = GLfloat(crop.top) / GLfloat(s.active.h);
-    GLfloat right = GLfloat(crop.right) / GLfloat(s.active.w);
-    GLfloat bottom = GLfloat(crop.bottom) / GLfloat(s.active.h);
-
-    if (isS3D()) {
-        if (drawFirstHalf) {
-            switch(mType) {
-                //top half
-                case eTopBottom:
-                    top *= 0.5f;
-                    bottom *= 0.5f;
-                    break;
-                //left half
-                case eSideBySide:
-                    left *= 0.5f;
-                    right *= 0.5f;
-                    break;
-                default:
-                    //Should never happen!
-                    break;
-            }
-        } else {
-            switch(mType) {
-                //bottom half
-                case eTopBottom:
-                    top = top*0.5f + 0.5f;
-                    bottom = bottom*0.5f + 0.5f;
-                    break;
-                //right half
-                case eSideBySide:
-                    left = left*0.5f + 0.5f;
-                    right = right*0.5f + 0.5f;
-                    break;
-                default:
-                    //Should never happen!
-                    break;
-            }
-        }
-    }
-
-    TexCoords texCoords[4];
-    texCoords[0].u = left;
-    texCoords[0].v = top;
-    texCoords[1].u = left;
-    texCoords[1].v = bottom;
-    texCoords[2].u = right;
-    texCoords[2].v = bottom;
-    texCoords[3].u = right;
-    texCoords[3].v = top;
-    for (int i = 0; i < 4; i++) {
-        texCoords[i].v = 1.0f - texCoords[i].v;
-    }
-
-    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-    glVertexPointer(2, GL_FLOAT, 0, mVertices);
-    glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
-    glDrawArrays(GL_TRIANGLE_FAN, 0, mNumVertices);
-
-    glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-    glDisable(GL_BLEND);
-}
-
-};
diff --git a/./frameworks/native/services/surfaceflinger/OmapLayer.h b/./frameworks/native/services/surfaceflinger/OmapLayer.h
deleted file mode 100644
index 93335fb..0000000
--- a/./frameworks/native/services/surfaceflinger/OmapLayer.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#ifndef _OMAPLAYER_H_
-#define _OMAPLAYER_H_
-
-#include "Layer.h"
-#include <ui/S3DFormat.h>
-
-namespace android {
-
-// ---------------------------------------------------------------------------
-class S3DSurfaceFlinger;
-
-// ---------------------------------------------------------------------------
-class OmapLayer : public Layer
-{
-public:
-    OmapLayer(S3DSurfaceFlinger* flinger, DisplayID display,
-                    const sp<Client>& client);
-
-    //Overriden from Layer
-    virtual const char* getTypeId() const { return "OmapLayer"; }
-    virtual void onRemoved();
-    virtual void setGeometry(hwc_layer_t* hwcl);
-    virtual void lockPageFlip(bool& recomputeVisibleRegions);
-
-    void setConfig(S3DLayoutType type, S3DLayoutOrder order, S3DRenderMode mode);
-    inline bool isS3D() const { return mType != eMono; }
-
-    inline bool isDrawingFirstHalf(S3DRenderMode mode) const {
-        return mViewOrder == static_cast<S3DLayoutOrder>(mode);
-    }
-
-private:
-    //This is overriden from LayerBase
-    virtual void drawWithOpenGL(const Region& clip) const;
-    //We need to do our own custom drawing here
-    void drawWithOpenGL(const Region& clip, bool drawFirstHalf) const;
-
-    S3DSurfaceFlinger *mFlingerS3D;
-    S3DLayoutType mType;
-    S3DLayoutOrder mViewOrder;
-    S3DRenderMode mRenderMode;
-};
-
-};
-
-#endif //_OMAPLAYER_H_
\ No newline at end of file
diff --git a/./frameworks/native/services/surfaceflinger/OmapLayerScreenshot.cpp b/./frameworks/native/services/surfaceflinger/OmapLayerScreenshot.cpp
deleted file mode 100644
index 7ebd116..0000000
--- a/./frameworks/native/services/surfaceflinger/OmapLayerScreenshot.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#include "OmapLayerScreenshot.h"
-#include "S3DSurfaceFlinger.h"
-
-namespace android {
-
-OmapLayerScreenshot::OmapLayerScreenshot(S3DSurfaceFlinger* flinger,
-            DisplayID display,const sp<Client>& client)
-         :  LayerScreenshot(flinger, display, client),
-            mFlingerS3D(flinger)
-{
-    mType = eMono;
-    mViewOrder = eLeftViewFirst;
-}
-
-uint32_t OmapLayerScreenshot::doTransaction(uint32_t flags)
-{
-    const Layer::State& draw(drawingState());
-    const Layer::State& curr(currentState());
-
-    if (draw.flags & ISurfaceComposer::eLayerHidden) {
-        if (!(curr.flags & ISurfaceComposer::eLayerHidden)) {
-            // we're going from hidden to visible
-            if (mFlingerS3D->isS3DLayerVisible_l()) {
-                mType = eSideBySide;
-                flags = LayerScreenshot::doTransaction(flags);
-                mFlingerS3D->addS3DLayer_l(this);
-                return flags;
-            } else {
-                mType = eMono;
-            }
-        }
-    }
-    return LayerScreenshot::doTransaction(flags);
-}
-
-void OmapLayerScreenshot::onRemoved()
-{
-    mFlingerS3D->removeS3DLayer_l(this);
-    LayerScreenshot::onRemoved();
-}
-
-void OmapLayerScreenshot::drawS3DRegion(const Region& clip, int hw_w, int hw_h) const
-{
-    GLfloat u = mTexCoords[4];
-    GLfloat v = mTexCoords[1];
-
-    struct TexCoords {
-        GLfloat u;
-        GLfloat v;
-    };
-
-    TexCoords texCoords[4];
-    texCoords[0].u = 0;
-    texCoords[0].v = v;
-    texCoords[1].u = 0;
-    texCoords[1].v = 0;
-    texCoords[2].u = u;
-    texCoords[2].v = 0;
-    texCoords[3].u = u;
-    texCoords[3].v = v;
-
-    if(mFlingerS3D->isDrawingLeft()) {
-        texCoords[2].u = 0.5f*u;
-        texCoords[3].u = 0.5f*u;
-    }
-    else {
-        texCoords[0].u = 0.5f*u;
-        texCoords[1].u = 0.5f*u;
-    }
-
-    glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
-    glDrawArrays(GL_TRIANGLE_FAN, 0, mNumVertices);
-}
-
-void OmapLayerScreenshot::drawRegion(const Region& clip, int hw_w, int hw_h) const
-{
-    if (mFlingerS3D->isDefaultRender() || (!isS3D() && !mFlingerS3D->isFramePackingRender())) {
-        LayerScreenshot::drawRegion(clip, hw_w, hw_h);
-        return;
-    }
-
-    if (isS3D() && mFlingerS3D->isInterleaveRender()) {
-        glEnable(GL_STENCIL_TEST);
-    } else if (isS3D() && mFlingerS3D->isAnaglyphRender()) {
-        //Left view = RED
-        glColorMask(GL_TRUE, GL_FALSE, GL_FALSE, GL_TRUE);
-    }
-
-    drawS3DRegion(clip, hw_w, hw_h);
-
-    //This layer draws its right view here as the viewport is not changed.
-    //This is done so that blending of any higher z layers with this one is correct.
-    if(isS3D() && !mFlingerS3D->isFramePackingRender()) {
-        mFlingerS3D->setDrawState(S3DSurfaceFlinger::eDrawingS3DRight);
-        if (mFlingerS3D->isAnaglyphRender()) {
-            //right view = cyan
-            glColorMask(GL_FALSE, GL_TRUE, GL_TRUE, GL_TRUE);
-        }
-        drawS3DRegion(clip, hw_w, hw_h);
-        mFlingerS3D->setDrawState(S3DSurfaceFlinger::eDrawingS3DLeft);
-    }
-
-    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
-    glDisable(GL_STENCIL_TEST);
-}
-
-};
diff --git a/./frameworks/native/services/surfaceflinger/OmapLayerScreenshot.h b/./frameworks/native/services/surfaceflinger/OmapLayerScreenshot.h
deleted file mode 100644
index 1887071..0000000
--- a/./frameworks/native/services/surfaceflinger/OmapLayerScreenshot.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#ifndef _OMAP_LAYERSCREENSHOT_H_
-#define _OMAP_LAYERSCREENSHOT_H_
-
-#include "LayerScreenshot.h"
-#include <ui/S3DFormat.h>
-
-namespace android {
-
-// ---------------------------------------------------------------------------
-class S3DSurfaceFlinger;
-
-// ---------------------------------------------------------------------------
-class OmapLayerScreenshot : public LayerScreenshot
-{
-public:
-    OmapLayerScreenshot(S3DSurfaceFlinger* flinger, DisplayID display,
-                        const sp<Client>& client);
-
-    //Overriden from LayerScreenshot
-    virtual const char* getTypeId() const { return "OmapLayerScreenshot"; }
-    virtual uint32_t doTransaction(uint32_t flags);
-    virtual void onRemoved();
-    virtual void drawRegion(const Region& clip, int hw_w, int hw_h) const;
-
-    inline bool isS3D() const { return mType != eMono; }
-
-private:
-    void drawS3DRegion(const Region& clip, int hw_w, int hw_h) const;
-
-    S3DSurfaceFlinger *mFlingerS3D;
-    S3DLayoutType mType;
-    S3DLayoutOrder mViewOrder;
-};
-
-};
-
-#endif //_OMAP_LAYERSCREENSHOT_H_
diff --git a/./frameworks/native/services/surfaceflinger/S3DSurfaceFlinger.cpp b/./frameworks/native/services/surfaceflinger/S3DSurfaceFlinger.cpp
deleted file mode 100644
index de476da..0000000
--- a/./frameworks/native/services/surfaceflinger/S3DSurfaceFlinger.cpp
+++ /dev/null
@@ -1,486 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "S3DSurfaceFlinger.h"
-#include "DisplayHardware/HWComposer.h"
-
-#include <cutils/properties.h>
-
-namespace android {
-
-
-StencilMask::StencilMask()
-    :   mVboId(0),
-        mCount(0),
-        mType(NONE)
-{
-}
-
-StencilMask::~StencilMask()
-{
-    if (mVboId) {
-        glDeleteBuffers(1, &mVboId);
-    }
-}
-
-void StencilMask::setupCoords(int w, int h, InterleavingType type)
-{
-    if (mType == type) {
-        return;
-    }
-
-    size_t i =0, j=0;
-    mType = type;
-    mCount = type == ROW ? h : w;
-    int lineCount = mCount/2;
-    GLshort* coords = new GLshort[4*lineCount];
-
-    if (type == ROW) {
-        while(lineCount > 0) {
-            coords[i] = 0;
-            coords[i+1] = j;
-            coords[i+2] = w;
-            coords[i+3] = j;
-            i+=4; j+=2;
-            lineCount--;
-        }
-    }
-    else if (type == COLUMN) {
-        while(lineCount > 0) {
-            coords[i] = j;
-            coords[i+1] = 0;
-            coords[i+2] = j;
-            coords[i+3] = h;
-            i+=4; j+=2;
-            lineCount--;
-        }
-    }
-    glGenBuffers(1, &mVboId);
-    glBindBuffer(GL_ARRAY_BUFFER, mVboId);
-    glBufferData(GL_ARRAY_BUFFER, sizeof(GLshort)*mCount*2, coords, GL_STATIC_DRAW);
-
-    delete[] coords;
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-}
-
-void StencilMask::drawStencil(int w, int h)
-{
-    glDisable(GL_SCISSOR_TEST);
-    glEnable(GL_STENCIL_TEST);
-    glClear(GL_STENCIL_BUFFER_BIT);
-    glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
-    glStencilMask(1);
-
-    glStencilFunc(GL_NEVER, 0x1, 0x1);
-    glStencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE);
-
-    glBindBuffer(GL_ARRAY_BUFFER, mVboId);
-    glVertexPointer(2, GL_SHORT, 0, NULL);
-    glDrawArrays(GL_LINES, 0, mCount);
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-
-    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
-    glStencilMask(0);
-    glDisable(GL_STENCIL_TEST);
-    glEnable(GL_SCISSOR_TEST);
-}
-
-void StencilMask::configStencilOp(bool drawEvenLines)
-{
-    if (drawEvenLines) {
-        glStencilFunc(GL_EQUAL, 0x1, 0x1);
-    } else {
-        glStencilFunc(GL_EQUAL, 0x0, 0x1);
-    }
-    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
-}
-
-// ---------------------------------------------------------------------------
-S3DSurfaceFlinger::S3DSurfaceFlinger()
-  : mWasS3DLayerVisible(false),
-    mDrawState(eDrawingS3DLeft),
-    mRenderMode(eRenderDefault),
-    mViewPortNeedsReset(false),
-    mOutputType(eMono)
-{
-    char prop[PROPERTY_VALUE_MAX];
-    //This should be a system setting, for now use a property and we default
-    //to anaglyph rendering.
-    property_get("omap.sf.s3d.anaglyph", prop, "1");
-    mDefaultRenderMode = atoi(prop) ? eRenderAnaglyph : eRenderMono;
-}
-
-sp<OmapLayer> S3DSurfaceFlinger::getLayer_l(const wp<IBinder>& binder)
-{
-    sp<Layer> layer(mLayerMap.valueFor(binder).promote());
-    sp<OmapLayer> layerSub;
-    if (layer != 0) {
-        layerSub = static_cast<OmapLayer*>(layer.get());
-    }
-    return layerSub;
-}
-
-void S3DSurfaceFlinger::addS3DLayer_l(const sp<LayerBase>& layer)
-{
-    sp<LayerBaseClient> lbc(layer->getLayerBaseClient());
-    if (lbc != 0) {
-        mS3DLayers.add(lbc->getSurfaceBinder(), layer);
-    }
-}
-
-void S3DSurfaceFlinger::removeS3DLayer_l(const sp<LayerBase>& layer)
-{
-    sp<LayerBaseClient> lbc(layer->getLayerBaseClient());
-    if (lbc != 0) {
-        mS3DLayers.removeItem( lbc->getSurfaceBinder() );
-    }
-}
-
-bool S3DSurfaceFlinger::isS3DLayerVisible_l() const {
-    bool s3dLayerVisible = false;
-    const DefaultKeyedVector< wp<IBinder>, wp<LayerBase> >& layers(mS3DLayers);
-    size_t count = layers.size();
-    for (size_t i=0 ; i<count ; i++) {
-        const sp<LayerBase>& layer(layers.valueAt(i).promote());
-        if (layer != 0 && !layer->visibleRegionScreen.isEmpty()) {
-            s3dLayerVisible = true;
-            break;
-        }
-    }
-    return s3dLayerVisible;
-}
-
-void S3DSurfaceFlinger::handleS3DVisibility()
-{
-    Mutex::Autolock _l(mStateLock);
-    bool s3dLayerVisible = isS3DLayerVisible_l();
-    const DisplayHardware& hw(graphicPlane(0).displayHardware());
-
-    //Redraw everything if we have transitioned from or to S3D rendering state
-    if (s3dLayerVisible != mWasS3DLayerVisible) {
-        mDirtyRegion.set(hw.bounds());
-    }
-
-    determineRenderMode(s3dLayerVisible);
-    mWasS3DLayerVisible = s3dLayerVisible;
-}
-
-void S3DSurfaceFlinger::determineRenderMode(bool s3dLayerVisible)
-{
-    if (s3dLayerVisible) {
-        if (mS3Dhw.initCheck() != NO_ERROR) {
-            mRenderMode = mDefaultRenderMode;
-        } else {
-            //S3D hardware is available, we need custom drawing
-            mRenderMode = mS3Dhw.isInterleaved() ? eRenderInterleaved : eRenderFramePacking;
-        }
-    } else {
-        //We need custom drawing for hardware that expects S3D data all the time
-        //even if there's no S3D layer visible
-        if (mS3Dhw.initCheck() == NO_ERROR && !mS3Dhw.isSwitcheable()) {
-            mRenderMode = mS3Dhw.isInterleaved() ? eRenderInterleaved : eRenderFramePacking;
-        }
-    }
-
-    mS3Dhw.enableS3D(isInterleaveRender() || isFramePackingRender());
-}
-
-void S3DSurfaceFlinger::setupViewport(int hw, int hh)
-{
-    GLint x =0, y = 0;
-    GLsizei w = hw;
-    GLsizei h = hh;
-    modifyCoords(x, y, w, h);
-    glViewport(x, y, w, h);
-    mViewPortNeedsReset = true;
-}
-
-void S3DSurfaceFlinger::setDrawState(DrawViewState state)
-{
-    mDrawState = state;
-    if (isInterleaveRender()) {
-        mStencilMask.configStencilOp(isDrawingFirstHalf());
-    }
-}
-
-void S3DSurfaceFlinger::modifyCoords(GLint& x, GLint& y, GLsizei& w, GLsizei& h) const
-{
-    if (!isFramePackingRender()) {
-        return;
-    }
-
-    //This is only applicable to frame packing as the viewport is changed
-    const DisplayHardware& hw(graphicPlane(0).displayHardware());
-    GLsizei dispw = hw.getWidth();
-    GLsizei disph = hw.getHeight();
-    if (isDrawingFirstHalf()) {
-        switch(mOutputType) {
-            //top half
-            case eTopBottom:
-                y /= 2;
-                y += disph/2;
-                h /= 2;
-                break;
-            //left half
-            case eSideBySide:
-                x /= 2;
-                w /= 2;
-                break;
-            default:
-                break;
-        }
-    }else {
-        switch(mOutputType) {
-            //bottom half
-            case eTopBottom:
-                y /= 2;
-                h /= 2;
-                break;
-            //right half
-            case eSideBySide:
-                x /=2;
-                x += dispw/2;
-                w /= 2;
-                break;
-                default:
-                    break;
-        }
-    }
-
-}
-
-status_t S3DSurfaceFlinger::onTransact(uint32_t code, const Parcel& data,
-                                        Parcel* reply, uint32_t flags)
-{
-    switch(code) {
-        case SET_SURF_CONFIG:
-        case GET_PREF_LAYOUT:
-        case FORCE_S3D_DISPLAY_CONFIG:
-        case SET_WINDOW_CONFIG:
-            //We don't check specific permissions to access surface flinger
-            //as we are not returning an interface to surfaceflinger or internal
-            //layers and we are not providing any capture services
-            CHECK_INTERFACE(ISurfaceComposer, data, reply);
-            break;
-        default:
-            return SurfaceFlinger::onTransact(code, data, reply, flags);
-    }
-
-    status_t err = NO_ERROR;
-    switch(code) {
-        case SET_SURF_CONFIG: {
-            Mutex::Autolock _l(mStateLock);
-            wp<IBinder> binder = data.readWeakBinder();
-            sp<OmapLayer> layerSub = getLayer_l(binder);
-            if (layerSub != 0) {
-                S3DLayoutType type = static_cast<S3DLayoutType>(data.readInt32());
-                S3DLayoutOrder order = static_cast<S3DLayoutOrder>(data.readInt32());
-                S3DRenderMode mode = static_cast<S3DRenderMode>(data.readInt32());
-                layerSub->setConfig(type, order, mode);
-                if (layerSub->isS3D()) {
-                    mS3DLayers.add(binder,layerSub);
-                } else {
-                    mS3DLayers.removeItem(binder);
-                }
-            }
-        } break;
-        case SET_WINDOW_CONFIG: {
-            Mutex::Autolock _l(mStateLock);
-            String8 windowName(data.readString8());
-            sp<OmapLayer> layerSub;
-            for (size_t i = 0; i < mLayerMap.size(); i++) {
-                sp<Layer> layer(mLayerMap.valueAt(i).promote());
-                if (layer.get() && windowName == layer->getName()) {
-                    layerSub = static_cast<OmapLayer*>(layer.get());
-                    break;
-                }
-            }
-            if (layerSub != 0) {
-                S3DLayoutType type = static_cast<S3DLayoutType>(data.readInt32());
-                S3DLayoutOrder order = static_cast<S3DLayoutOrder>(data.readInt32());
-                S3DRenderMode mode = static_cast<S3DRenderMode>(data.readInt32());
-                layerSub->setConfig(type, order, mode);
-                if (layerSub->isS3D()) {
-                    mS3DLayers.add(layerSub->getSurfaceBinder(),layerSub);
-                } else {
-                    mS3DLayers.removeItem(layerSub->getSurfaceBinder());
-                }
-            }
-        } break;
-        case GET_PREF_LAYOUT: {
-            if (mS3Dhw.getType() == eRowInterleaved) {
-                reply->writeInt32(eTopBottom);
-            } else if (mS3Dhw.getType() == eColInterleaved) {
-                 reply->writeInt32(eSideBySide);
-            } else {
-                reply->writeInt32(mS3Dhw.getType());
-            }
-            reply->writeInt32(mS3Dhw.getOrdering());
-        } break;
-        case FORCE_S3D_DISPLAY_CONFIG: {
-            S3DLayoutType type = static_cast<S3DLayoutType>(data.readInt32());
-            S3DLayoutOrder order = static_cast<S3DLayoutOrder>(data.readInt32());
-            bool switcheable = data.readInt32();
-            Mutex::Autolock _l(mStateLock);
-            mS3Dhw.forceConfiguration(type, order, switcheable);
-            invalidateHwcGeometry();
-            repaintEverything();
-        } break;
-        default:
-            err = PERMISSION_DENIED;
-            break;
-    }
-    return err;
-}
-
-//This method is overriden for the only purpose of instantiating
-//OmapLayer objects (instead of Layer) so we can do custom drawing if needed
-sp<Layer> S3DSurfaceFlinger::createNormalSurface(
-        const sp<Client>& client, DisplayID display,
-        uint32_t w, uint32_t h, uint32_t flags,
-        PixelFormat& format)
-{
-    // initialize the surfaces
-    switch (format) { // TODO: take h/w into account
-    case PIXEL_FORMAT_TRANSPARENT:
-    case PIXEL_FORMAT_TRANSLUCENT:
-        format = PIXEL_FORMAT_RGBA_8888;
-        break;
-    case PIXEL_FORMAT_OPAQUE:
-#ifdef NO_RGBX_8888
-        format = PIXEL_FORMAT_RGB_565;
-#else
-        format = PIXEL_FORMAT_RGBX_8888;
-#endif
-        break;
-    }
-
-#ifdef NO_RGBX_8888
-    if (format == PIXEL_FORMAT_RGBX_8888) {
-        format = PIXEL_FORMAT_RGBA_8888;
-    }
-#endif
-
-    sp<OmapLayer> layer = new OmapLayer(this, display, client);
-    status_t err = layer->setBuffers(w, h, format, flags);
-    if (CC_LIKELY(err != NO_ERROR)) {
-        ALOGE("createNormalSurfaceLocked() failed (%s)", strerror(-err));
-        layer.clear();
-    }
-    return layer;
-}
-
-sp<LayerScreenshot> S3DSurfaceFlinger::createScreenshotSurface(
-        const sp<Client>& client, DisplayID display,
-        uint32_t w, uint32_t h, uint32_t flags)
-{
-    sp<LayerScreenshot> layer = new OmapLayerScreenshot(this, display, client);
-    return layer;
-}
-
-status_t S3DSurfaceFlinger::captureScreenImplLocked(DisplayID dpy,
-        sp<IMemoryHeap>* heap,
-        uint32_t* w, uint32_t* h, PixelFormat* f,
-        uint32_t sw, uint32_t sh,
-        uint32_t minLayerZ, uint32_t maxLayerZ)
-{
-    status_t ret;
-    if (isS3DLayerVisible_l()) {
-        mRenderMode = eRenderMono;
-    }
-    ret = SurfaceFlinger::captureScreenImplLocked(dpy, heap, w, h, f, sw, sh,
-                                                    minLayerZ, maxLayerZ);
-    mRenderMode = eRenderDefault;
-    return ret;
-}
-
-void S3DSurfaceFlinger::drawLayersForScreenshotLocked()
-{
-    if (!isS3DLayerVisible_l()) {
-        return SurfaceFlinger::drawLayersForScreenshotLocked();
-    }
-
-    const DisplayHardware& hw(graphicPlane(0).displayHardware());
-    int w = hw.getWidth();
-    int h = hw.getHeight();
-
-    //If an S3D layer is visible, an S3D screenshot will be generated
-    //in side-by-side format.
-    //This is done so that transitions while drawing S3D content occur
-    //without artifacts
-    mRenderMode = eRenderFramePacking;
-    mOutputType = eSideBySide;
-    mDrawState = eDrawingS3DLeft;
-    setupViewport(w, h);
-    SurfaceFlinger::drawLayersForScreenshotLocked();
-
-    mDrawState = eDrawingS3DRight;
-    setupViewport(w, h);
-    SurfaceFlinger::drawLayersForScreenshotLocked();
-
-    glViewport(0, 0, w, h);
-    mRenderMode = eRenderDefault;
-    mOutputType = mS3Dhw.getType();
-}
-
-void  S3DSurfaceFlinger::handlePageFlip()
-{
-    SurfaceFlinger::handlePageFlip();
-    handleS3DVisibility();
-}
-
-void S3DSurfaceFlinger::composeSurfaces(const Region& dirty)
-{
-    if (mRenderMode == eRenderDefault) {
-        //No custom drawing neeeded, punt to base class
-        SurfaceFlinger::composeSurfaces(dirty);
-        return;
-    }
-
-    const DisplayHardware& hw(graphicPlane(0).displayHardware());
-    int w = hw.getWidth();
-    int h = hw.getHeight();
-
-    mDrawState = eDrawingS3DLeft;
-    mOutputType = mS3Dhw.getType();
-
-    if (isInterleaveRender()) {
-        mStencilMask.setupCoords(w, h, (StencilMask::InterleavingType)mS3Dhw.getType());
-        mStencilMask.drawStencil(w, h);
-        mStencilMask.configStencilOp(isDrawingFirstHalf());
-    } else if (isFramePackingRender()) {
-        setupViewport(w, h);
-    }
-    SurfaceFlinger::composeSurfaces(dirty);
-
-    //For frame packing rendering, the visible stack of layers has to drawn twice
-    //as the Mono layers need to be replicated.
-    if (isFramePackingRender()) {
-        mDrawState = eDrawingS3DRight;
-        setupViewport(w, h);
-        SurfaceFlinger::composeSurfaces(dirty);
-    }
-
-    if (mViewPortNeedsReset) {
-        glViewport(0, 0, w, h);
-    }
-
-    mRenderMode = eRenderDefault;
-}
-
-};
diff --git a/./frameworks/native/services/surfaceflinger/S3DSurfaceFlinger.h b/./frameworks/native/services/surfaceflinger/S3DSurfaceFlinger.h
deleted file mode 100644
index feae789..0000000
--- a/./frameworks/native/services/surfaceflinger/S3DSurfaceFlinger.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2011 Texas Instruments Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _S3DSURFACEFLINGER_H_
-#define _S3DSURFACEFLINGER_H_
-
-#include "SurfaceFlinger.h"
-#include "OmapLayer.h"
-#include "OmapLayerScreenshot.h"
-#include "DisplayHardware/S3DHardware.h"
-
-#include <ui/S3DFormat.h>
-
-namespace android {
-
-// ---------------------------------------------------------------------------
-
-class StencilMask
-{
-public:
-    StencilMask();
-    ~StencilMask();
-
-    enum InterleavingType {
-        NONE,
-        COLUMN = eColInterleaved,
-        ROW    = eRowInterleaved
-    };
-    void setupCoords(int w, int h, InterleavingType type);
-    void drawStencil(int w, int h);
-    void configStencilOp(bool drawEvenLines);
-    void reset();
-
-private:
-    GLuint mVboId;
-    int mCount;
-    InterleavingType mType;
-};
-
-// ---------------------------------------------------------------------------
-class S3DSurfaceFlinger : public SurfaceFlinger
-{
-public:
-    S3DSurfaceFlinger();
-
-    //Custom codes we'll handle, the rest is handled by base class
-    enum {
-        SET_SURF_CONFIG = 4000,
-        GET_PREF_LAYOUT = 4001,
-        FORCE_S3D_DISPLAY_CONFIG = 4002,
-        SET_WINDOW_CONFIG = 4003,
-    };
-    //Handles custom codes but delegates all else to base class onTransact
-    virtual status_t onTransact(
-        uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags);
-
-    inline bool isDefaultRender() const { return mRenderMode == eRenderDefault; }
-    inline bool isAnaglyphRender() const { return mRenderMode == eRenderAnaglyph; }
-    inline bool isInterleaveRender() const { return (mRenderMode == eRenderInterleaved); }
-    inline bool isFramePackingRender() const { return (mRenderMode == eRenderFramePacking); }
-    inline bool isMonoRender() const { return (mRenderMode == eRenderMono); }
-    inline bool isDrawingLeft() const { return mDrawState == eDrawingS3DLeft; };
-    inline bool isDrawingFirstHalf() const {
-        return mDrawState == static_cast<DrawViewState>(mS3Dhw.getOrdering());
-    };
-
-    bool isS3DLayerVisible_l() const;
-
-    enum DrawViewState {
-        eDrawingS3DLeft = eLeftViewFirst,
-        eDrawingS3DRight = eRightViewFirst
-    };
-
-    enum RenderMode {
-        //No custom drawing needed. Punts to base class drawing.
-        eRenderDefault      = 0x1,
-        //Custom drawing needed, but only one view out of a stereo layer is rendered.
-        //Mono layers are rendered as they are.
-        eRenderMono         = 0x2,
-        //Custom drawing with stencil masking will be used.
-        //Mono layers are ideally filterd to avoid aliasing artifacts.
-        eRenderInterleaved  = 0x4,
-        //The visible layer stack has to be drawn twice. Mono layers are replicated
-        //for each view.
-        eRenderFramePacking = 0x8,
-        //Custom drawing by color coding stereo layers. Mono layers are drawn as they are.
-        eRenderAnaglyph     = 0x10
-    };
-
-private:
-    friend class OmapLayer;
-    friend class OmapLayerScreenshot;
-
-    //Overriden from base class
-    virtual void handlePageFlip();
-    virtual void composeSurfaces(const Region& dirty);
-    virtual void modifyCoords(GLint& x, GLint& y, GLsizei& rw, GLsizei& rh) const;
-    virtual void drawLayersForScreenshotLocked();
-    virtual sp<Layer> createNormalSurface(
-                            const sp<Client>& client, DisplayID display,
-                            uint32_t w, uint32_t h, uint32_t flags,
-                            PixelFormat& format);
-    virtual sp<LayerScreenshot> createScreenshotSurface(
-            const sp<Client>& client, DisplayID display,
-            uint32_t w, uint32_t h, uint32_t flags);
-    virtual status_t captureScreenImplLocked(DisplayID dpy,
-                    sp<IMemoryHeap>* heap,
-                    uint32_t* width, uint32_t* height, PixelFormat* format,
-                    uint32_t reqWidth, uint32_t reqHeight,
-                    uint32_t minLayerZ, uint32_t maxLayerZ);
-
-    //These belong to S3DSurfaceFlinger
-    void handleS3DVisibility();
-    void determineRenderMode(bool s3dLayerVisible);
-    void setupViewport(int w, int h);
-    void setDrawState(DrawViewState state);
-    // access must be protected by mStateLock
-    void addS3DLayer_l(const sp<LayerBase>& layer);
-    void removeS3DLayer_l(const sp<LayerBase>& layer);
-    sp<OmapLayer> getLayer_l(const wp<IBinder>& binder);
-
-    // access must be protected by mStateLock
-    DefaultKeyedVector< wp<IBinder>, wp<LayerBase> > mS3DLayers;
-
-    // Can only accessed from the main thread, these members
-    // don't need synchronization
-    bool mWasS3DLayerVisible;
-
-    DrawViewState mDrawState;
-    RenderMode mRenderMode;
-    //This is the render mode used when there's no S3D hardware
-    //and we need to render a stereo layer (can only be analglyph or mono)
-    RenderMode mDefaultRenderMode;
-
-    bool mViewPortNeedsReset;
-    StencilMask mStencilMask;
-    S3DHardware mS3Dhw;
-
-    //This mirrors the s3d hardware output type most of the time
-    //except during screenshots
-    S3DLayoutType mOutputType;
-};
-};
-#endif//_S3DSURFACEFLINGER_H_
diff --git a/./frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
index 184b8ae..51fcce4 100644
--- a/./frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
@@ -258,9 +258,6 @@ status_t SurfaceFlinger::readyToRun()
     dcblk->ydpi         = hw.getDpiY();
     dcblk->fps          = hw.getRefreshRate();
     dcblk->density      = hw.getDensity();
-#ifdef OMAP_ENHANCEMENT
-    dcblk->maxTex       = hw.getMaxTextureSize();
-#endif
 
     // Initialize OpenGL|ES
     glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
@@ -1786,18 +1783,6 @@ status_t SurfaceFlinger::renderScreenToTexture(DisplayID dpy,
     return renderScreenToTextureLocked(dpy, textureName, uOut, vOut);
 }
 
-#ifdef OMAP_ENHANCEMENT_S3D
-void SurfaceFlinger::drawLayersForScreenshotLocked()
-{
-    const Vector< sp<LayerBase> >& layers(mVisibleLayersSortedByZ);
-    const size_t count = layers.size();
-    for (size_t i=0 ; i<count ; ++i) {
-        const sp<LayerBase>& layer(layers[i]);
-        layer->drawForSreenShot();
-    }
-}
-#endif
-
 status_t SurfaceFlinger::renderScreenToTextureLocked(DisplayID dpy,
         GLuint* textureName, GLfloat* uOut, GLfloat* vOut)
 {
@@ -1845,16 +1830,13 @@ status_t SurfaceFlinger::renderScreenToTextureLocked(DisplayID dpy,
     glClear(GL_COLOR_BUFFER_BIT);
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
-#ifdef OMAP_ENHANCEMENT_S3D
-    drawLayersForScreenshotLocked();
-#else
     const Vector< sp<LayerBase> >& layers(mVisibleLayersSortedByZ);
     const size_t count = layers.size();
     for (size_t i=0 ; i<count ; ++i) {
         const sp<LayerBase>& layer(layers[i]);
         layer->drawForSreenShot();
     }
-#endif
+
     hw.compositionComplete();
 
     // back to main framebuffer
diff --git a/./frameworks/native/services/surfaceflinger/SurfaceFlinger.h b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
index f1dad18..b20973b 100644
--- a/./frameworks/native/services/surfaceflinger/SurfaceFlinger.h
+++ b/home/DL/gdallolio/backup/Google-4.1.1/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
@@ -238,10 +238,6 @@ private:
     friend class LayerBase;
     friend class LayerBaseClient;
     friend class Layer;
-#ifdef OMAP_ENHANCEMENT_S3D
-    friend class S3DSurfaceFlinger;
-    friend class OmapLayer;
-#endif
 
     sp<ISurface> createSurface(
             ISurfaceComposerClient::surface_data_t* params,
@@ -250,11 +246,7 @@ private:
             DisplayID display, uint32_t w, uint32_t h, PixelFormat format,
             uint32_t flags);
 
-#ifdef OMAP_ENHANCEMENT_S3D
-    virtual sp<Layer> createNormalSurface(
-#else
     sp<Layer> createNormalSurface(
-#endif
             const sp<Client>& client, DisplayID display,
             uint32_t w, uint32_t h, uint32_t flags,
             PixelFormat& format);
@@ -263,11 +255,7 @@ private:
             const sp<Client>& client, DisplayID display,
             uint32_t w, uint32_t h, uint32_t flags);
 
-#ifdef OMAP_ENHANCEMENT_S3D
-    virtual sp<LayerScreenshot> createScreenshotSurface(
-#else
     sp<LayerScreenshot> createScreenshotSurface(
-#endif
             const sp<Client>& client, DisplayID display,
             uint32_t w, uint32_t h, uint32_t flags);
 
@@ -322,28 +310,17 @@ private:
                             const LayerVector& currentLayers,
                             Region& dirtyRegion,
                             Region& wormholeRegion);
-#ifdef OMAP_ENHANCEMENT_S3D
-            virtual void        handlePageFlip();
-#else
+
             void        handlePageFlip();
-#endif
             bool        lockPageFlip(const LayerVector& currentLayers);
             void        unlockPageFlip(const LayerVector& currentLayers);
             void        handleRefresh();
-#ifdef OMAP_ENHANCEMENT_S3D
-            virtual void        handleWorkList();
-#else
             void        handleWorkList();
-#endif
             void        handleRepaint();
             void        postFramebuffer();
             void        setupHardwareComposer();
-#ifdef OMAP_ENHANCEMENT_S3D
-            virtual void        composeSurfaces(const Region& dirty);
-#else
             void        composeSurfaces(const Region& dirty);
 
-#endif
 
             void        setInvalidateRegion(const Region& reg);
             Region      getAndClearInvalidateRegion();
@@ -359,12 +336,8 @@ private:
             uint32_t    setTransactionFlags(uint32_t flags);
             void        commitTransaction();
 
-#ifdef OMAP_ENHANCEMENT_S3D
-    virtual void     drawLayersForScreenshotLocked();
-    virtual status_t captureScreenImplLocked(DisplayID dpy,
-#else
+
             status_t captureScreenImplLocked(DisplayID dpy,
-#endif
                     sp<IMemoryHeap>* heap,
                     uint32_t* width, uint32_t* height, PixelFormat* format,
                     uint32_t reqWidth, uint32_t reqHeight,
@@ -378,9 +351,6 @@ private:
             void        debugFlashRegions();
             void        drawWormhole() const;
 
-#ifdef OMAP_ENHANCEMENT_S3D
-    virtual void modifyCoords(GLint& x, GLint& y, GLsizei& rw, GLsizei& rh) const {};
-#endif
             void        startBootAnim();
 
             void listLayersLocked(const Vector<String16>& args, size_t& index,
